{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"code/","title":"Modules","text":""},{"location":"code/#overview","title":"Overview","text":"<p>These are the modules used in the docstring-format-checker package:</p> Module Description Core The <code>core</code> module contains the main <code>DocstringChecker</code> class responsible for parsing Python files with AST, extracting docstrings from functions/classes/methods, and validating them against configured section requirements. Configuration The <code>config</code> module handles loading and validating configuration from TOML files. It supports automatic discovery of <code>pyproject.toml</code> files and defines section validation rules through the <code>SectionConfig</code> dataclass. CLI The <code>cli</code> module provides the command-line interface using Typer. It supports both <code>docstring-format-checker</code> and <code>dfc</code> entry points with subcommands for checking files/directories and generating configuration examples. Exceptions The <code>exceptions</code> module defines custom exception classes for structured error handling, including <code>DocstringError</code> for validation failures, <code>InvalidFileError</code> for non-Python files, and <code>DirectoryNotFoundError</code> for path validation."},{"location":"code/#key-features","title":"Key Features","text":"<ul> <li>AST-based parsing: Uses Python's AST module for robust code analysis</li> <li>Configurable validation: TOML-based configuration with 4 section types: <code>free_text</code>, <code>list_name</code>, <code>list_type</code>, <code>list_name_and_type</code></li> <li>Hierarchical config discovery: Automatically finds configuration in <code>pyproject.toml</code> files</li> <li>Rich output formatting: Uses Rich library for colored console output and error tables</li> <li>Dual CLI entry points: Available as both <code>docstring-format-checker</code> and <code>dfc</code></li> <li>Comprehensive error handling: Custom exceptions for different failure scenarios</li> </ul>"},{"location":"code/#section-types","title":"Section Types","text":"<p>The checker supports four types of docstring sections:</p> <ol> <li><code>free_text</code>: Admonition-style sections like summary, details, examples</li> <li><code>list_name</code>: Simple name lists</li> <li><code>list_type</code>: Type-only lists for raises, yields sections</li> <li><code>list_name_and_type</code>: Name and type lists for parameters, returns sections</li> </ol>"},{"location":"code/#testing","title":"Testing","text":"<p>This package maintains 100% test coverage with comprehensive testing against:</p> <ol> <li>Unit tests: Complete test coverage for all modules and functions</li> <li>Integration tests: CLI and end-to-end workflow testing</li> <li>Configuration tests: TOML parsing and validation testing</li> <li>Error handling tests: Exception scenarios and edge cases</li> <li>AST parsing tests: Python code analysis and docstring extraction</li> </ol> <p>Tests are run in matrix against:</p> <ol> <li>Python Versions:</li> <li><code>3.10</code></li> <li><code>3.11</code></li> <li><code>3.12</code></li> <li><code>3.13</code></li> <li>Operating Systems:</li> <li><code>ubuntu-latest</code></li> <li><code>windows-latest</code></li> <li><code>macos-latest</code></li> </ol>"},{"location":"code/#coverage","title":"Coverage","text":""},{"location":"code/cli/","title":"CLI","text":""},{"location":"code/cli/#docstring_format_checker.cli","title":"docstring_format_checker.cli","text":"<p>Summary</p> <p>Command-line interface for the docstring format checker.</p>"},{"location":"code/cli/#docstring_format_checker.cli.main","title":"main","text":"<pre><code>main(\n    ctx: Context,\n    path: Optional[str] = Argument(\n        None,\n        help=\"Path to Python file or directory to check\",\n    ),\n    config: Optional[str] = Option(\n        None,\n        \"--config\",\n        \"-f\",\n        help=\"Path to configuration file (TOML format)\",\n    ),\n    exclude: Optional[list[str]] = Option(\n        None,\n        \"--exclude\",\n        \"-x\",\n        help=\"Glob patterns to exclude (can be used multiple times)\",\n    ),\n    output: str = Option(\n        \"list\",\n        \"--output\",\n        \"-o\",\n        help=\"Output format: 'table' or 'list'\",\n        show_default=True,\n    ),\n    check: bool = Option(\n        False,\n        \"--check\",\n        \"-c\",\n        help=\"Throw error (exit 1) if any issues are found\",\n    ),\n    quiet: bool = Option(\n        False,\n        \"--quiet\",\n        \"-q\",\n        help=\"Only output pass/fail confirmation, suppress errors unless failing\",\n    ),\n    example: Optional[str] = Option(\n        None,\n        \"--example\",\n        \"-e\",\n        callback=_example_callback,\n        is_eager=True,\n        help=\"Show examples: 'config' for configuration example, 'usage' for usage examples\",\n    ),\n    version: Optional[bool] = Option(\n        None,\n        \"--version\",\n        \"-v\",\n        callback=_version_callback,\n        is_eager=True,\n        help=\"Show version and exit\",\n    ),\n    help_flag: Optional[bool] = Option(\n        None,\n        \"--help\",\n        \"-h\",\n        callback=_help_callback_main,\n        is_eager=True,\n        help=\"Show this message and exit\",\n    ),\n) -&gt; None\n</code></pre> <p>Summary</p> <p>Check Python docstring formatting and completeness.</p> Details <p>This tool analyzes Python files and validates that functions, methods, and classes have properly formatted docstrings according to the configured sections.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The context object for the command.</p> required <code>path</code> <code>Optional[str]</code> <p>Path to Python file or directory to check.</p> <code>Argument(None, help='Path to Python file or directory to check')</code> <code>config</code> <code>Optional[str]</code> <p>Path to configuration file (TOML format).</p> <code>Option(None, '--config', '-f', help='Path to configuration file (TOML format)')</code> <code>exclude</code> <code>Optional[list[str]]</code> <p>Glob patterns to exclude.</p> <code>Option(None, '--exclude', '-x', help='Glob patterns to exclude (can be used multiple times)')</code> <code>output</code> <code>str</code> <p>Output format: 'table' or 'list'.</p> <code>Option('list', '--output', '-o', help=\"Output format: 'table' or 'list'\", show_default=True)</code> <code>check</code> <code>bool</code> <p>Throw error if any issues are found.</p> <code>Option(False, '--check', '-c', help='Throw error (exit 1) if any issues are found')</code> <code>quiet</code> <code>bool</code> <p>Only output pass/fail confirmation.</p> <code>Option(False, '--quiet', '-q', help='Only output pass/fail confirmation, suppress errors unless failing')</code> <code>example</code> <code>Optional[str]</code> <p>Show examples: 'config' or 'usage'.</p> <code>Option(None, '--example', '-e', callback=_example_callback, is_eager=True, help=\"Show examples: 'config' for configuration example, 'usage' for usage examples\")</code> <code>version</code> <code>Optional[bool]</code> <p>Show version and exit.</p> <code>Option(None, '--version', '-v', callback=_version_callback, is_eager=True, help='Show version and exit')</code> <code>help_flag</code> <code>Optional[bool]</code> <p>Show help message and exit.</p> <code>Option(None, '--help', '-h', callback=_help_callback_main, is_eager=True, help='Show this message and exit')</code> <p>Returns:</p> Type Description <code>None</code> <p>Nothing is returned.</p> Source code in <code>src/docstring_format_checker/cli.py</code> <pre><code>@app.callback(invoke_without_command=True)\ndef main(\n    ctx: Context,\n    path: Optional[str] = Argument(None, help=\"Path to Python file or directory to check\"),\n    config: Optional[str] = Option(None, \"--config\", \"-f\", help=\"Path to configuration file (TOML format)\"),\n    exclude: Optional[list[str]] = Option(\n        None,\n        \"--exclude\",\n        \"-x\",\n        help=\"Glob patterns to exclude (can be used multiple times)\",\n    ),\n    output: str = Option(\n        \"list\",\n        \"--output\",\n        \"-o\",\n        help=\"Output format: 'table' or 'list'\",\n        show_default=True,\n    ),\n    check: bool = Option(\n        False,\n        \"--check\",\n        \"-c\",\n        help=\"Throw error (exit 1) if any issues are found\",\n    ),\n    quiet: bool = Option(\n        False,\n        \"--quiet\",\n        \"-q\",\n        help=\"Only output pass/fail confirmation, suppress errors unless failing\",\n    ),\n    example: Optional[str] = Option(\n        None,\n        \"--example\",\n        \"-e\",\n        callback=_example_callback,\n        is_eager=True,\n        help=\"Show examples: 'config' for configuration example, 'usage' for usage examples\",\n    ),\n    version: Optional[bool] = Option(\n        None,\n        \"--version\",\n        \"-v\",\n        callback=_version_callback,\n        is_eager=True,\n        help=\"Show version and exit\",\n    ),\n    help_flag: Optional[bool] = Option(\n        None,\n        \"--help\",\n        \"-h\",\n        callback=_help_callback_main,\n        is_eager=True,\n        help=\"Show this message and exit\",\n    ),\n) -&gt; None:\n    \"\"\"\n    !!! note \"Summary\"\n        Check Python docstring formatting and completeness.\n\n    ???+ abstract \"Details\"\n        This tool analyzes Python files and validates that functions, methods, and classes have properly formatted docstrings according to the configured sections.\n\n    Params:\n        ctx (Context):\n            The context object for the command.\n        path (Optional[str]):\n            Path to Python file or directory to check.\n        config (Optional[str]):\n            Path to configuration file (TOML format).\n        exclude (Optional[list[str]]):\n            Glob patterns to exclude.\n        output (str):\n            Output format: 'table' or 'list'.\n        check (bool):\n            Throw error if any issues are found.\n        quiet (bool):\n            Only output pass/fail confirmation.\n        example (Optional[str]):\n            Show examples: 'config' or 'usage'.\n        version (Optional[bool]):\n            Show version and exit.\n        help_flag (Optional[bool]):\n            Show help message and exit.\n\n    Returns:\n        (None):\n            Nothing is returned.\n    \"\"\"\n\n    # If no path is provided, show help\n    if path is None:\n        echo(ctx.get_help())\n        raise Exit(0)\n\n    # Validate output format\n    if output not in [\"table\", \"list\"]:\n        console.print(_red(f\"Error: Invalid output format '{output}'. Use 'table' or 'list'.\"))\n        raise Exit(1)\n\n    check_docstrings(\n        path=path,\n        config=config,\n        exclude=exclude,\n        quiet=quiet,\n        output=output,\n        check=check,\n    )\n</code></pre>"},{"location":"code/cli/#docstring_format_checker.cli.entry_point","title":"entry_point","text":"<pre><code>entry_point() -&gt; None\n</code></pre> <p>Summary</p> <p>Entry point for the CLI scripts defined in pyproject.toml.</p> Source code in <code>src/docstring_format_checker/cli.py</code> <pre><code>def entry_point() -&gt; None:\n    \"\"\"\n    !!! note \"Summary\"\n        Entry point for the CLI scripts defined in pyproject.toml.\n    \"\"\"\n    app()\n</code></pre>"},{"location":"code/config/","title":"Config","text":""},{"location":"code/config/#docstring_format_checker.config","title":"docstring_format_checker.config","text":"<p>Summary</p> <p>Configuration handling for the docstring format checker.</p>"},{"location":"code/config/#docstring_format_checker.config.SectionConfig","title":"SectionConfig  <code>dataclass</code>","text":"<p>Configuration for a docstring section.</p> Source code in <code>src/docstring_format_checker/config.py</code> <pre><code>@dataclass\nclass SectionConfig:\n    \"\"\"\n    Configuration for a docstring section.\n    \"\"\"\n\n    order: int\n    name: str\n    type: Literal[\"free_text\", \"list_name\", \"list_type\", \"list_name_and_type\"]\n    admonition: Union[bool, str] = False\n    prefix: str = \"\"  # Support any prefix string\n    required: bool = False\n    message: str = \"\"  # Optional message for validation errors\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate configuration after initialization.\"\"\"\n        self._validate_types()\n        self._validate_admonition_prefix_combination()\n\n    def _validate_types(self) -&gt; None:\n        \"\"\"Validate the 'type' field.\"\"\"\n        if self.type not in VALID_TYPES:\n            raise InvalidTypeValuesError(f\"Invalid section type: {self.type}. Valid types: {VALID_TYPES}\")\n\n    def _validate_admonition_prefix_combination(self) -&gt; None:\n        \"\"\"Validate admonition and prefix combination rules.\"\"\"\n\n        if isinstance(self.admonition, bool):\n            # Rule: admonition cannot be True (only False or string)\n            if self.admonition is True:\n                raise ValueError(f\"Section '{self.name}': admonition cannot be True, must be False or a string\")\n\n            # Rule: if admonition is False, prefix cannot be provided\n            if self.admonition is False and self.prefix:\n                raise ValueError(f\"Section '{self.name}': when admonition=False, prefix cannot be provided\")\n\n        elif isinstance(self.admonition, str):\n            # Rule: if admonition is a string, prefix must be provided\n            if not self.prefix:\n                raise ValueError(f\"Section '{self.name}': when admonition is a string, prefix must be provided\")\n\n        else:\n            raise ValueError(\n                f\"Section '{self.name}': admonition must be a boolean or string, got {type(self.admonition)}\"\n            )\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.SectionConfig.__init__","title":"__init__","text":"<pre><code>__init__(\n    order: int,\n    name: str,\n    type: Literal[\n        \"free_text\",\n        \"list_name\",\n        \"list_type\",\n        \"list_name_and_type\",\n    ],\n    admonition: Union[bool, str] = False,\n    prefix: str = \"\",\n    required: bool = False,\n    message: str = \"\",\n) -&gt; None\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.SectionConfig.order","title":"order  <code>instance-attribute</code>","text":"<pre><code>order: int\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.SectionConfig.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.SectionConfig.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal[\n    \"free_text\",\n    \"list_name\",\n    \"list_type\",\n    \"list_name_and_type\",\n]\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.SectionConfig.admonition","title":"admonition  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>admonition: Union[bool, str] = False\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.SectionConfig.prefix","title":"prefix  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prefix: str = ''\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.SectionConfig.required","title":"required  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>required: bool = False\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.SectionConfig.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message: str = ''\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.SectionConfig.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate configuration after initialization.</p> Source code in <code>src/docstring_format_checker/config.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate configuration after initialization.\"\"\"\n    self._validate_types()\n    self._validate_admonition_prefix_combination()\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.DEFAULT_CONFIG","title":"DEFAULT_CONFIG  <code>module-attribute</code>","text":"<pre><code>DEFAULT_CONFIG: list[SectionConfig] = [\n    SectionConfig(\n        order=1,\n        name=\"summary\",\n        type=\"free_text\",\n        admonition=\"note\",\n        prefix=\"!!!\",\n        required=True,\n    ),\n    SectionConfig(\n        order=2,\n        name=\"details\",\n        type=\"free_text\",\n        admonition=\"info\",\n        prefix=\"???+\",\n        required=False,\n    ),\n    SectionConfig(\n        order=3,\n        name=\"params\",\n        type=\"list_name_and_type\",\n        required=True,\n    ),\n    SectionConfig(\n        order=4,\n        name=\"returns\",\n        type=\"list_name_and_type\",\n        required=False,\n    ),\n    SectionConfig(\n        order=5,\n        name=\"yields\",\n        type=\"list_type\",\n        required=False,\n    ),\n    SectionConfig(\n        order=6,\n        name=\"raises\",\n        type=\"list_type\",\n        required=False,\n    ),\n    SectionConfig(\n        order=7,\n        name=\"examples\",\n        type=\"free_text\",\n        admonition=\"example\",\n        prefix=\"???+\",\n        required=False,\n    ),\n    SectionConfig(\n        order=8,\n        name=\"notes\",\n        type=\"free_text\",\n        admonition=\"note\",\n        prefix=\"???\",\n        required=False,\n    ),\n]\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.load_config","title":"load_config","text":"<pre><code>load_config(\n    config_path: Optional[Union[str, Path]] = None,\n) -&gt; list[SectionConfig]\n</code></pre> <p>Summary</p> <p>Load configuration from a TOML file or return default configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Optional[Union[str, Path]]</code> <p>Path to the TOML configuration file. If <code>None</code>, looks for <code>pyproject.toml</code> in current directory. Default: <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[SectionConfig]</code> <p>List of SectionConfig objects defining the docstring sections to check.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the specified config file doesn't exist.</p> <code>InvalidConfigError</code> <p>If the configuration is invalid.</p> Source code in <code>src/docstring_format_checker/config.py</code> <pre><code>def load_config(config_path: Optional[Union[str, Path]] = None) -&gt; list[SectionConfig]:\n    \"\"\"\n    !!! note \"Summary\"\n        Load configuration from a TOML file or return default configuration.\n\n    Params:\n        config_path (Optional[Union[str, Path]]):\n            Path to the TOML configuration file.\n            If `None`, looks for `pyproject.toml` in current directory.\n            Default: `None`.\n\n    Returns:\n        (list[SectionConfig]):\n            List of SectionConfig objects defining the docstring sections to check.\n\n    Raises:\n        (FileNotFoundError):\n            If the specified config file doesn't exist.\n        (InvalidConfigError):\n            If the configuration is invalid.\n    \"\"\"\n\n    if config_path is None:\n        # Look for pyproject.toml in current directory\n        pyproject_path: Path = Path.cwd().joinpath(\"pyproject.toml\")\n        if pyproject_path.exists():\n            config_path = pyproject_path\n        else:\n            return DEFAULT_CONFIG\n\n    config_path = Path(config_path)\n    if not config_path.exists():\n        raise FileNotFoundError(f\"Configuration file not found: {config_path}\")\n\n    try:\n        with open(config_path, \"rb\") as f:\n            config_data: dict[str, Any] = tomllib.load(f)\n    except Exception as e:\n        raise InvalidConfigError(f\"Failed to parse TOML file {config_path}: {e}\") from e\n\n    # Try to find configuration under [tool.dfc] or [tool.docstring-format-checker]\n    tool_config = None\n    if \"tool\" in config_data:\n        if \"dfc\" in config_data[\"tool\"]:\n            tool_config = config_data[\"tool\"][\"dfc\"]\n        elif \"docstring-format-checker\" in config_data[\"tool\"]:\n            tool_config = config_data[\"tool\"][\"docstring-format-checker\"]\n\n    if tool_config is None:\n        return DEFAULT_CONFIG\n\n    # Parse sections configuration\n    sections_config: list[SectionConfig] = []\n    if \"sections\" in tool_config:\n        sections_data = tool_config[\"sections\"]\n        for section_data in sections_data:\n            try:\n                # Get admonition value with proper default handling\n                admonition_value: Union[str, bool] = section_data.get(\"admonition\")\n                if admonition_value is None:\n                    admonition_value = False  # Use SectionConfig default\n\n                section = SectionConfig(\n                    order=section_data.get(\"order\", 0),\n                    name=section_data.get(\"name\", \"\"),\n                    type=section_data.get(\"type\", \"\"),\n                    admonition=admonition_value,\n                    prefix=section_data.get(\"prefix\", \"\"),\n                    required=section_data.get(\"required\", False),\n                )\n                sections_config.append(section)\n            except (KeyError, TypeError, ValueError, InvalidTypeValuesError) as e:\n                raise InvalidConfigError(f\"Invalid section configuration: {section_data}. Error: {e}\") from e\n\n    if not sections_config:\n        return DEFAULT_CONFIG\n\n    # Validate no duplicate order values\n    _validate_config_order(config_sections=sections_config)\n\n    # Sort by order\n    sections_config.sort(key=lambda x: x.order)\n\n    return sections_config\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.find_config_file","title":"find_config_file","text":"<pre><code>find_config_file(\n    start_path: Optional[Path] = None,\n) -&gt; Optional[Path]\n</code></pre> <p>Summary</p> <p>Find configuration file by searching up the directory tree.</p> <p>Parameters:</p> Name Type Description Default <code>start_path</code> <code>Optional[Path]</code> <p>Directory to start searching from. If <code>None</code>, resolves to current directory. Default: <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Path]</code> <p>Path to the configuration file if found, None otherwise.</p> Source code in <code>src/docstring_format_checker/config.py</code> <pre><code>def find_config_file(start_path: Optional[Path] = None) -&gt; Optional[Path]:\n    \"\"\"\n    !!! note \"Summary\"\n        Find configuration file by searching up the directory tree.\n\n    Params:\n        start_path (Optional[Path]):\n            Directory to start searching from.\n            If `None`, resolves to current directory.\n            Default: `None`.\n\n    Returns:\n        (Optional[Path]):\n            Path to the configuration file if found, None otherwise.\n    \"\"\"\n    if start_path is None:\n        start_path = Path.cwd()\n\n    current_path: Path = start_path.resolve()\n\n    while current_path != current_path.parent:\n        pyproject_path: Path = current_path.joinpath(\"pyproject.toml\")\n        if pyproject_path.exists():\n            # Check if it contains dfc configuration\n            try:\n                with open(pyproject_path, \"rb\") as f:\n                    config_data: dict[str, Any] = tomllib.load(f)\n                    if \"tool\" in config_data and (\n                        \"dfc\" in config_data[\"tool\"] or \"docstring-format-checker\" in config_data[\"tool\"]\n                    ):\n                        return pyproject_path\n            except Exception:\n                pass\n\n        current_path = current_path.parent\n\n    return None\n</code></pre>"},{"location":"code/core/","title":"Core","text":""},{"location":"code/core/#docstring_format_checker.core","title":"docstring_format_checker.core","text":"<p>Summary</p> <p>Core docstring checking functionality.</p>"},{"location":"code/core/#docstring_format_checker.core.SectionConfig","title":"SectionConfig  <code>dataclass</code>","text":"<p>Configuration for a docstring section.</p> Source code in <code>src/docstring_format_checker/config.py</code> <pre><code>@dataclass\nclass SectionConfig:\n    \"\"\"\n    Configuration for a docstring section.\n    \"\"\"\n\n    order: int\n    name: str\n    type: Literal[\"free_text\", \"list_name\", \"list_type\", \"list_name_and_type\"]\n    admonition: Union[bool, str] = False\n    prefix: str = \"\"  # Support any prefix string\n    required: bool = False\n    message: str = \"\"  # Optional message for validation errors\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate configuration after initialization.\"\"\"\n        self._validate_types()\n        self._validate_admonition_prefix_combination()\n\n    def _validate_types(self) -&gt; None:\n        \"\"\"Validate the 'type' field.\"\"\"\n        if self.type not in VALID_TYPES:\n            raise InvalidTypeValuesError(f\"Invalid section type: {self.type}. Valid types: {VALID_TYPES}\")\n\n    def _validate_admonition_prefix_combination(self) -&gt; None:\n        \"\"\"Validate admonition and prefix combination rules.\"\"\"\n\n        if isinstance(self.admonition, bool):\n            # Rule: admonition cannot be True (only False or string)\n            if self.admonition is True:\n                raise ValueError(f\"Section '{self.name}': admonition cannot be True, must be False or a string\")\n\n            # Rule: if admonition is False, prefix cannot be provided\n            if self.admonition is False and self.prefix:\n                raise ValueError(f\"Section '{self.name}': when admonition=False, prefix cannot be provided\")\n\n        elif isinstance(self.admonition, str):\n            # Rule: if admonition is a string, prefix must be provided\n            if not self.prefix:\n                raise ValueError(f\"Section '{self.name}': when admonition is a string, prefix must be provided\")\n\n        else:\n            raise ValueError(\n                f\"Section '{self.name}': admonition must be a boolean or string, got {type(self.admonition)}\"\n            )\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.SectionConfig.order","title":"order  <code>instance-attribute</code>","text":"<pre><code>order: int\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.SectionConfig.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.SectionConfig.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal[\n    \"free_text\",\n    \"list_name\",\n    \"list_type\",\n    \"list_name_and_type\",\n]\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.SectionConfig.admonition","title":"admonition  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>admonition: Union[bool, str] = False\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.SectionConfig.prefix","title":"prefix  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prefix: str = ''\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.SectionConfig.required","title":"required  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>required: bool = False\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.SectionConfig.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message: str = ''\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.SectionConfig.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate configuration after initialization.</p> Source code in <code>src/docstring_format_checker/config.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate configuration after initialization.\"\"\"\n    self._validate_types()\n    self._validate_admonition_prefix_combination()\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.SectionConfig.__init__","title":"__init__","text":"<pre><code>__init__(\n    order: int,\n    name: str,\n    type: Literal[\n        \"free_text\",\n        \"list_name\",\n        \"list_type\",\n        \"list_name_and_type\",\n    ],\n    admonition: Union[bool, str] = False,\n    prefix: str = \"\",\n    required: bool = False,\n    message: str = \"\",\n) -&gt; None\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringError","title":"DocstringError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when a docstring validation error occurs.</p> Source code in <code>src/docstring_format_checker/utils/exceptions.py</code> <pre><code>class DocstringError(Exception):\n    \"\"\"\n    Exception raised when a docstring validation error occurs.\n    \"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        file_path: str,\n        line_number: int,\n        item_name: str,\n        item_type: str,\n    ) -&gt; None:\n        self.message = message\n        self.file_path = file_path\n        self.line_number = line_number\n        self.item_name = item_name\n        self.item_type = item_type\n        super().__init__(f\"Line {line_number}, {item_type} '{item_name}': {message}\")\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringError.__init__","title":"__init__","text":"<pre><code>__init__(\n    message: str,\n    file_path: str,\n    line_number: int,\n    item_name: str,\n    item_type: str,\n) -&gt; None\n</code></pre> Source code in <code>src/docstring_format_checker/utils/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    file_path: str,\n    line_number: int,\n    item_name: str,\n    item_type: str,\n) -&gt; None:\n    self.message = message\n    self.file_path = file_path\n    self.line_number = line_number\n    self.item_name = item_name\n    self.item_type = item_type\n    super().__init__(f\"Line {line_number}, {item_type} '{item_name}': {message}\")\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringError.file_path","title":"file_path  <code>instance-attribute</code>","text":"<pre><code>file_path = file_path\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringError.line_number","title":"line_number  <code>instance-attribute</code>","text":"<pre><code>line_number = line_number\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringError.item_name","title":"item_name  <code>instance-attribute</code>","text":"<pre><code>item_name = item_name\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringError.item_type","title":"item_type  <code>instance-attribute</code>","text":"<pre><code>item_type = item_type\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.FunctionAndClassDetails","title":"FunctionAndClassDetails","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Details about a function or class found in the AST.</p> Source code in <code>src/docstring_format_checker/core.py</code> <pre><code>class FunctionAndClassDetails(NamedTuple):\n    \"\"\"\n    Details about a function or class found in the AST.\n    \"\"\"\n\n    item_type: Literal[\"function\", \"class\", \"method\"]\n    name: str\n    node: Union[ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef]\n    lineno: int\n    parent_class: Optional[str] = None\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.FunctionAndClassDetails.item_type","title":"item_type  <code>instance-attribute</code>","text":"<pre><code>item_type: Literal['function', 'class', 'method']\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.FunctionAndClassDetails.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.FunctionAndClassDetails.node","title":"node  <code>instance-attribute</code>","text":"<pre><code>node: Union[FunctionDef, AsyncFunctionDef, ClassDef]\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.FunctionAndClassDetails.lineno","title":"lineno  <code>instance-attribute</code>","text":"<pre><code>lineno: int\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.FunctionAndClassDetails.parent_class","title":"parent_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_class: Optional[str] = None\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringChecker","title":"DocstringChecker","text":"<p>Main class for checking docstring format and completeness.</p> Source code in <code>src/docstring_format_checker/core.py</code> <pre><code>class DocstringChecker:\n    \"\"\"\n    Main class for checking docstring format and completeness.\n    \"\"\"\n\n    def __init__(self, sections_config: list[SectionConfig]) -&gt; None:\n        \"\"\"\n        !!! note \"Summary\"\n            Initialize the docstring checker.\n\n        Params:\n            sections_config (list[SectionConfig]):\n                List of section configurations to check against.\n        \"\"\"\n        self.sections_config: list[SectionConfig] = sections_config\n        self.required_sections: list[SectionConfig] = [s for s in sections_config if s.required]\n        self.optional_sections: list[SectionConfig] = [s for s in sections_config if not s.required]\n\n    def check_file(self, file_path: Union[str, Path]) -&gt; list[DocstringError]:\n        \"\"\"\n        !!! note \"Summary\"\n            Check docstrings in a Python file.\n\n        Params:\n            file_path (Union[str, Path]):\n                Path to the Python file to check.\n\n        Returns:\n            (list[DocstringError]):\n                List of DocstringError objects for any validation failures.\n\n        Raises:\n            (FileNotFoundError):\n                If the file doesn't exist.\n            (InvalidFileError):\n                If the file is not a Python file.\n            (UnicodeError):\n                If the file can't be decoded.\n            (SyntaxError):\n                If the file contains invalid Python syntax.\n        \"\"\"\n\n        file_path = Path(file_path)\n        if not file_path.exists():\n            raise FileNotFoundError(f\"File not found: {file_path}\")\n\n        if file_path.suffix != \".py\":\n            raise InvalidFileError(f\"File must be a Python file (.py): {file_path}\")\n\n        # Read and parse the file\n        try:\n            with open(file_path, encoding=\"utf-8\") as f:\n                content: str = f.read()\n        except UnicodeDecodeError as e:\n            raise UnicodeError(f\"Cannot decode file {file_path}: {e}\") from e\n\n        try:\n            tree: ast.Module = ast.parse(content)\n        except SyntaxError as e:\n            raise SyntaxError(f\"Invalid Python syntax in {file_path}: {e}\") from e\n\n        # Extract all functions and classes\n        items: list[FunctionAndClassDetails] = self._extract_items(tree)\n\n        # Check each item\n        errors: list[DocstringError] = []\n        for item in items:\n            try:\n                self._check_single_docstring(item, str(file_path))\n            except DocstringError as e:\n                errors.append(e)\n\n        return errors\n\n    def check_directory(\n        self,\n        directory_path: Union[str, Path],\n        exclude_patterns: Optional[list[str]] = None,\n    ) -&gt; dict[str, list[DocstringError]]:\n        \"\"\"\n        !!! note \"Summary\"\n            Check docstrings in all Python files in a directory recursively.\n\n        Params:\n            directory_path (Union[str, Path]):\n                Path to the directory to check.\n            exclude_patterns (Optional[list[str]]):\n                List of glob patterns to exclude.\n\n        Raises:\n            (FileNotFoundError):\n                If the directory doesn't exist.\n            (DirectoryNotFoundError):\n                If the path is not a directory.\n\n        Returns:\n            (dict[str, list[DocstringError]]):\n                Dictionary mapping file paths to lists of DocstringError objects.\n        \"\"\"\n\n        directory_path = Path(directory_path)\n        if not directory_path.exists():\n            raise FileNotFoundError(f\"Directory not found: {directory_path}\")\n\n        if not directory_path.is_dir():\n            raise DirectoryNotFoundError(f\"Path is not a directory: {directory_path}\")\n\n        python_files: list[Path] = list(directory_path.glob(\"**/*.py\"))\n\n        # Filter out excluded patterns\n        if exclude_patterns:\n            filtered_files: list[Path] = []\n            for file_path in python_files:\n                relative_path: Path = file_path.relative_to(directory_path)\n                should_exclude = False\n                for pattern in exclude_patterns:\n                    if fnmatch.fnmatch(str(relative_path), pattern):\n                        should_exclude = True\n                        break\n                if not should_exclude:\n                    filtered_files.append(file_path)\n            python_files = filtered_files\n\n        # Check each file\n        results: dict[str, list[DocstringError]] = {}\n        for file_path in python_files:\n            try:\n                errors: list[DocstringError] = self.check_file(file_path)\n                if errors:  # Only include files with errors\n                    results[str(file_path)] = errors\n            except (FileNotFoundError, ValueError, SyntaxError) as e:\n                # Create a special error for file-level issues\n                error = DocstringError(\n                    message=str(e),\n                    file_path=str(file_path),\n                    line_number=0,\n                    item_name=\"\",\n                    item_type=\"file\",\n                )\n                results[str(file_path)] = [error]\n\n        return results\n\n    def _is_overload_function(self, node: Union[ast.FunctionDef, ast.AsyncFunctionDef]) -&gt; bool:\n        \"\"\"\n        !!! note \"Summary\"\n            Check if a function definition is decorated with @overload.\n\n        Params:\n            node (Union[ast.FunctionDef, ast.AsyncFunctionDef]):\n                The function node to check for @overload decorator.\n\n        Returns:\n            (bool):\n                True if the function has @overload decorator, False otherwise.\n        \"\"\"\n\n        for decorator in node.decorator_list:\n            # Handle direct name reference: @overload\n            if isinstance(decorator, ast.Name) and decorator.id == \"overload\":\n                return True\n            # Handle attribute reference: @typing.overload\n            elif isinstance(decorator, ast.Attribute) and decorator.attr == \"overload\":\n                return True\n        return False\n\n    def _extract_items(self, tree: ast.AST) -&gt; list[FunctionAndClassDetails]:\n        \"\"\"\n        !!! note \"Summary\"\n            Extract all functions and classes from the AST.\n\n        Params:\n            tree (ast.AST):\n                The Abstract Syntax Tree (AST) to extract items from.\n\n        Returns:\n            (list[FunctionAndClassDetails]):\n                A list of extracted function and class details.\n        \"\"\"\n\n        items: list[FunctionAndClassDetails] = []\n\n        class ItemVisitor(ast.NodeVisitor):\n\n            def __init__(self, checker: DocstringChecker) -&gt; None:\n                self.class_stack: list[str] = []\n                self.checker: DocstringChecker = checker\n\n            def visit_ClassDef(self, node: ast.ClassDef) -&gt; None:\n                if not node.name.startswith(\"_\"):  # Skip private classes\n                    items.append(\n                        FunctionAndClassDetails(\n                            item_type=\"class\",\n                            name=node.name,\n                            node=node,\n                            lineno=node.lineno,\n                            parent_class=None,\n                        )\n                    )\n\n                # Visit methods in this class\n                self.class_stack.append(node.name)\n                self.generic_visit(node)\n                self.class_stack.pop()\n\n            def visit_FunctionDef(self, node: ast.FunctionDef) -&gt; None:\n                self._visit_function(node)\n\n            def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -&gt; None:\n                self._visit_function(node)\n\n            def _visit_function(self, node: Union[ast.FunctionDef, ast.AsyncFunctionDef]) -&gt; None:\n                \"\"\"Visit function definition node (sync or async).\"\"\"\n\n                if not node.name.startswith(\"_\"):  # Skip private functions\n                    # Skip @overload functions - they don't need docstrings\n\n                    if not self.checker._is_overload_function(node):\n                        item_type: Literal[\"function\", \"method\"] = \"method\" if self.class_stack else \"function\"\n                        parent_class: Optional[str] = self.class_stack[-1] if self.class_stack else None\n\n                        items.append(\n                            FunctionAndClassDetails(\n                                item_type=item_type,\n                                name=node.name,\n                                node=node,\n                                lineno=node.lineno,\n                                parent_class=parent_class,\n                            )\n                        )\n\n                self.generic_visit(node)\n\n        visitor = ItemVisitor(self)\n        visitor.visit(tree)\n\n        return items\n\n    def _check_single_docstring(self, item: FunctionAndClassDetails, file_path: str) -&gt; None:\n        \"\"\"\n        !!! note \"Summary\"\n            Check a single function or class docstring.\n\n        Params:\n            item (FunctionAndClassDetails):\n                The function or class to check.\n            file_path (str):\n                The path to the file containing the item.\n\n        Returns:\n            (None):\n                Nothing is returned.\n        \"\"\"\n\n        docstring: Optional[str] = ast.get_docstring(item.node)\n\n        # Check if any required sections apply to this item type\n        requires_docstring = False\n        applicable_sections: list[SectionConfig] = []\n\n        for section in self.sections_config:\n            if section.required:\n                # Check if this section applies to this item type\n                if section.type == \"free_text\":\n                    # Free text sections apply only to functions and methods, not classes\n                    if isinstance(item.node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n                        requires_docstring = True\n                        applicable_sections.append(section)\n                elif section.type == \"list_name_and_type\":\n                    if section.name.lower() == \"params\" and isinstance(\n                        item.node, (ast.FunctionDef, ast.AsyncFunctionDef)\n                    ):\n                        # Params only apply to functions/methods\n                        requires_docstring = True\n                        applicable_sections.append(section)\n                    elif section.name.lower() in [\"returns\", \"return\"] and isinstance(\n                        item.node, (ast.FunctionDef, ast.AsyncFunctionDef)\n                    ):\n                        # Returns only apply to functions/methods\n                        requires_docstring = True\n                        applicable_sections.append(section)\n                elif section.type in [\"list_type\", \"list_name\"]:\n                    # These sections apply to functions/methods that might have them\n                    if isinstance(item.node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n                        requires_docstring = True\n                        applicable_sections.append(section)\n\n        if not docstring:\n            if requires_docstring:\n                message: str = f\"Missing docstring for {item.item_type}\"\n                raise DocstringError(\n                    message=message,\n                    file_path=file_path,\n                    line_number=item.lineno,\n                    item_name=item.name,\n                    item_type=item.item_type,\n                )\n            return  # No docstring required\n\n        # Validate docstring sections if docstring exists\n        self._validate_docstring_sections(docstring, item, file_path)\n\n    def _validate_docstring_sections(\n        self,\n        docstring: str,\n        item: FunctionAndClassDetails,\n        file_path: str,\n    ) -&gt; None:\n        \"\"\"\n        !!! note \"Summary\"\n            Validate the sections within a docstring.\n\n        Params:\n            docstring (str):\n                The docstring to validate.\n            item (FunctionAndClassDetails):\n                The function or class to check.\n            file_path (str):\n                The path to the file containing the item.\n\n        Returns:\n            (None):\n                Nothing is returned.\n        \"\"\"\n\n        errors: list[str] = []\n\n        # Check each required section\n        for section in self.required_sections:\n            if section.type == \"free_text\":\n                if not self._check_free_text_section(docstring, section):\n                    errors.append(f\"Missing required section: {section.name}\")\n\n            elif section.type == \"list_name_and_type\":\n                if section.name.lower() == \"params\" and isinstance(item.node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n                    if not self._check_params_section(docstring, item.node):\n                        errors.append(\"Missing or invalid Params section\")\n                elif section.name.lower() in [\"returns\", \"return\"]:\n                    if not self._check_returns_section(docstring):\n                        errors.append(\"Missing or invalid Returns section\")\n\n            elif section.type == \"list_type\":\n                if section.name.lower() in [\"raises\", \"raise\"]:\n                    if not self._check_raises_section(docstring):\n                        errors.append(\"Missing or invalid Raises section\")\n                elif section.name.lower() in [\"yields\", \"yield\"]:\n                    if not self._check_yields_section(docstring):\n                        errors.append(\"Missing or invalid Yields section\")\n\n            elif section.type == \"list_name\":\n                # Simple name sections - check if they exist\n                if not self._check_simple_section(docstring, section.name):\n                    errors.append(f\"Missing required section: {section.name}\")\n\n        # Check section order\n        order_errors: list[str] = self._check_section_order(docstring)\n        errors.extend(order_errors)\n\n        # Check for mutual exclusivity (returns vs yields)\n        if self._has_both_returns_and_yields(docstring):\n            errors.append(\"Docstring cannot have both Returns and Yields sections\")\n\n        # Check for undefined sections in docstring\n        undefined_errors: list[str] = self._check_undefined_sections(docstring)\n        errors.extend(undefined_errors)\n\n        # Check admonition values match configuration\n        admonition_errors: list[str] = self._check_admonition_values(docstring)\n        errors.extend(admonition_errors)\n\n        # Check colon usage for admonition vs non-admonition sections\n        colon_errors: list[str] = self._check_colon_usage(docstring)\n        errors.extend(colon_errors)\n\n        # Check title case for non-admonition sections\n        title_case_errors: list[str] = self._check_title_case_sections(docstring)\n        errors.extend(title_case_errors)\n\n        # Check parentheses for list type sections\n        parentheses_errors: list[str] = self._check_parentheses_validation(docstring)\n        errors.extend(parentheses_errors)\n\n        if errors:\n            combined_message: str = \"; \".join(errors)\n            raise DocstringError(\n                message=combined_message,\n                file_path=file_path,\n                line_number=item.lineno,\n                item_name=item.name,\n                item_type=item.item_type,\n            )\n\n    def _check_free_text_section(self, docstring: str, section: SectionConfig) -&gt; bool:\n        \"\"\"\n        !!! note \"Summary\"\n            Check if a free text section exists in the docstring.\n\n        Params:\n            docstring (str):\n                The docstring to check.\n            section (SectionConfig):\n                The section configuration to validate.\n\n        Returns:\n            (bool):\n                `True` if the section exists, `False` otherwise.\n        \"\"\"\n\n        if isinstance(section.admonition, str) and section.admonition and section.prefix:\n            # Format like: !!! note \"Summary\"\n            # Make the section name part case-insensitive too\n            escaped_name = re.escape(section.name)\n            pattern = rf'{re.escape(section.prefix)}\\s+{re.escape(section.admonition)}\\s+\"[^\"]*{escaped_name}[^\"]*\"'\n            return bool(re.search(pattern, docstring, re.IGNORECASE))\n        elif section.name.lower() in [\"summary\"]:\n            # For summary, accept either formal format or simple docstring\n            formal_pattern = r'!!! note \"Summary\"'\n            if re.search(formal_pattern, docstring, re.IGNORECASE):\n                return True\n            # Accept any non-empty docstring as summary\n            return len(docstring.strip()) &gt; 0\n        elif section.name.lower() in [\"examples\", \"example\"]:\n            # Look for examples section\n            return bool(re.search(r'\\?\\?\\?\\+ example \"Examples\"', docstring, re.IGNORECASE))\n\n        return True  # Default to true for unknown free text sections\n\n    def _check_params_section(self, docstring: str, node: Union[ast.FunctionDef, ast.AsyncFunctionDef]) -&gt; bool:\n        \"\"\"\n        !!! note \"Summary\"\n            Check if the Params section exists and documents all parameters.\n\n        Params:\n            docstring (str):\n                The docstring to check.\n            node (Union[ast.FunctionDef, ast.AsyncFunctionDef]):\n                The function node to check.\n\n        Returns:\n            (bool):\n                `True` if the section exists and is valid, `False` otherwise.\n        \"\"\"\n\n        # Get function parameters (excluding 'self' for methods)\n        params: list[str] = [arg.arg for arg in node.args.args if arg.arg != \"self\"]\n\n        if not params:\n            return True  # No parameters to document\n\n        # Check if Params section exists\n        if not re.search(r\"Params:\", docstring):\n            return False\n\n        # Check each parameter is documented\n        for param in params:\n            param_pattern: str = rf\"{re.escape(param)}\\s*\\([^)]+\\):\"\n            if not re.search(param_pattern, docstring):\n                return False\n\n        return True\n\n    def _check_returns_section(self, docstring: str) -&gt; bool:\n        \"\"\"\n        !!! note \"Summary\"\n            Check if the Returns section exists.\n\n        Params:\n            docstring (str):\n                The docstring to check.\n\n        Returns:\n            (bool):\n                `True` if the section exists, `False` otherwise.\n        \"\"\"\n\n        return bool(re.search(r\"Returns:\", docstring))\n\n    def _check_raises_section(self, docstring: str) -&gt; bool:\n        \"\"\"\n        !!! note \"Summary\"\n            Check if the Raises section exists.\n\n        Params:\n            docstring (str):\n                The docstring to check.\n\n        Returns:\n            (bool):\n                `True` if the section exists, `False` otherwise.\n        \"\"\"\n\n        return bool(re.search(r\"Raises:\", docstring))\n\n    def _has_both_returns_and_yields(self, docstring: str) -&gt; bool:\n        \"\"\"\n        !!! note \"Summary\"\n            Check if docstring has both Returns and Yields sections.\n\n        Params:\n            docstring (str):\n                The docstring to check.\n\n        Returns:\n            (bool):\n                `True` if the section exists, `False` otherwise.\n        \"\"\"\n\n        has_returns = bool(re.search(r\"Returns:\", docstring))\n        has_yields = bool(re.search(r\"Yields:\", docstring))\n        return has_returns and has_yields\n\n    def _check_section_order(self, docstring: str) -&gt; list[str]:\n        \"\"\"\n        !!! note \"Summary\"\n            Check that sections appear in the correct order.\n\n        Params:\n            docstring (str):\n                The docstring to check.\n\n        Returns:\n            (list[str]):\n                A list of error messages, if any.\n        \"\"\"\n\n        # Build expected order from configuration\n        section_patterns: list[tuple[str, str]] = []\n        for section in sorted(self.sections_config, key=lambda x: x.order):\n            if (\n                section.type == \"free_text\"\n                and isinstance(section.admonition, str)\n                and section.admonition\n                and section.prefix\n            ):\n                pattern: str = (\n                    rf'{re.escape(section.prefix)}\\s+{re.escape(section.admonition)}\\s+\".*{re.escape(section.name)}\"'\n                )\n                section_patterns.append((pattern, section.name))\n            elif section.name.lower() == \"params\":\n                section_patterns.append((r\"Params:\", \"Params\"))\n            elif section.name.lower() in [\"returns\", \"return\"]:\n                section_patterns.append((r\"Returns:\", \"Returns\"))\n            elif section.name.lower() in [\"yields\", \"yield\"]:\n                section_patterns.append((r\"Yields:\", \"Yields\"))\n            elif section.name.lower() in [\"raises\", \"raise\"]:\n                section_patterns.append((r\"Raises:\", \"Raises\"))\n\n        # Add some default patterns for common sections\n        default_patterns: list[tuple[str, str]] = [\n            (r'!!! note \"Summary\"', \"Summary\"),\n            (r'!!! details \"Details\"', \"Details\"),\n            (r'\\?\\?\\?\\+ example \"Examples\"', \"Examples\"),\n            (r'\\?\\?\\?\\+ success \"Credit\"', \"Credit\"),\n            (r'\\?\\?\\?\\+ calculation \"Equation\"', \"Equation\"),\n            (r'\\?\\?\\?\\+ info \"Notes\"', \"Notes\"),\n            (r'\\?\\?\\? question \"References\"', \"References\"),\n            (r'\\?\\?\\? tip \"See Also\"', \"See Also\"),\n        ]\n\n        all_patterns: list[tuple[str, str]] = section_patterns + default_patterns\n\n        found_sections: list[tuple[int, str]] = []\n        for pattern, section_name in all_patterns:\n            match: Optional[re.Match[str]] = re.search(pattern, docstring, re.IGNORECASE)\n            if match:\n                found_sections.append((match.start(), section_name))\n\n        # Sort by position in docstring\n        found_sections.sort(key=lambda x: x[0])\n\n        # Build expected order\n        expected_order: list[str] = [s.name.title() for s in sorted(self.sections_config, key=lambda x: x.order)]\n        expected_order.extend(\n            [\n                \"Summary\",\n                \"Details\",\n                \"Examples\",\n                \"Credit\",\n                \"Equation\",\n                \"Notes\",\n                \"References\",\n                \"See Also\",\n            ]\n        )\n\n        # Check order matches expected order\n        errors: list[str] = []\n        last_expected_index = -1\n        for _, section_name in found_sections:\n            try:\n                current_index: int = expected_order.index(section_name)\n                if current_index &lt; last_expected_index:\n                    errors.append(f\"Section '{section_name}' appears out of order\")\n                last_expected_index: int = current_index\n            except ValueError:\n                # Section not in expected order list - might be OK\n                pass\n\n        return errors\n\n    def _check_yields_section(self, docstring: str) -&gt; bool:\n        \"\"\"\n        !!! note \"Summary\"\n            Check if the Yields section exists.\n\n        Params:\n            docstring (str):\n                The docstring to check.\n\n        Returns:\n            (bool):\n                `True` if the section exists, `False` otherwise.\n        \"\"\"\n\n        return bool(re.search(r\"Yields:\", docstring))\n\n    def _check_simple_section(self, docstring: str, section_name: str) -&gt; bool:\n        \"\"\"\n        !!! note \"Summary\"\n            Check if a simple named section exists.\n\n        Params:\n            docstring (str):\n                The docstring to check.\n            section_name (str):\n                The name of the section to check for.\n\n        Returns:\n            (bool):\n                `True` if the section exists, `False` otherwise.\n        \"\"\"\n\n        pattern: str = rf\"{re.escape(section_name)}:\"\n        return bool(re.search(pattern, docstring, re.IGNORECASE))\n\n    def _check_undefined_sections(self, docstring: str) -&gt; list[str]:\n        \"\"\"\n        !!! note \"Summary\"\n            Check for sections in docstring that are not defined in configuration.\n\n        Params:\n            docstring (str):\n                The docstring to check.\n\n        Returns:\n            (list[str]):\n                A list of error messages for undefined sections.\n        \"\"\"\n\n        errors: list[str] = []\n\n        # Get all configured section names (case-insensitive)\n        configured_sections: set[str] = {section.name.lower() for section in self.sections_config}\n\n        # Common patterns for different section types\n        section_patterns: list[tuple[str, str]] = [\n            # Standard sections with colons (but not inside quotes)\n            (r\"^(\\w+):\\s*\", \"colon\"),\n            # Admonition sections with various prefixes\n            (r\"(?:\\?\\?\\?[+]?|!!!)\\s+\\w+\\s+\\\"([^\\\"]+)\\\"\", \"admonition\"),\n        ]\n\n        found_sections: set[str] = set()\n\n        for pattern, pattern_type in section_patterns:\n            matches: Iterator[re.Match[str]] = re.finditer(pattern, docstring, re.IGNORECASE | re.MULTILINE)\n            for match in matches:\n                section_name: str = match.group(1).lower().strip()\n\n                # Remove colon if present (for colon pattern matches)\n                section_name = section_name.rstrip(\":\")\n\n                # Skip empty matches or common docstring content\n                if not section_name or section_name in [\"\", \"py\", \"python\", \"sh\", \"shell\"]:\n                    continue\n\n                # Skip code blocks and inline code\n                if any(char in section_name for char in [\"`\", \".\", \"/\", \"\\\\\"]):\n                    continue\n\n                found_sections.add(section_name)\n\n        # Check which found sections are not configured\n        for section_name in found_sections:\n            if section_name not in configured_sections:\n                errors.append(f\"Section '{section_name}' found in docstring but not defined in configuration\")\n\n        return errors\n\n    def _check_admonition_values(self, docstring: str) -&gt; list[str]:\n        \"\"\"\n        !!! note \"Summary\"\n            Check that admonition values in docstring match configuration.\n\n        Params:\n            docstring (str):\n                The docstring to check.\n\n        Returns:\n            (list[str]):\n                A list of error messages for mismatched admonitions.\n        \"\"\"\n\n        errors: list[str] = []\n\n        # Create mapping of section names to expected admonitions\n        section_admonitions: dict[str, str] = {}\n        for section in self.sections_config:\n            if section.type == \"free_text\" and isinstance(section.admonition, str) and section.admonition:\n                section_admonitions[section.name.lower()] = section.admonition.lower()\n\n        # Pattern to find all admonition sections\n        admonition_pattern = r\"(?:\\?\\?\\?[+]?|!!!)\\s+(\\w+)\\s+\\\"([^\\\"]+)\\\"\"\n        matches: Iterator[re.Match[str]] = re.finditer(admonition_pattern, docstring, re.IGNORECASE)\n\n        for match in matches:\n            actual_admonition: str = match.group(1).lower()\n            section_title: str = match.group(2).lower()\n\n            # Check if this section is configured with a specific admonition\n            if section_title in section_admonitions:\n                expected_admonition: str = section_admonitions[section_title]\n                if actual_admonition != expected_admonition:\n                    errors.append(\n                        f\"Section '{section_title}' has incorrect admonition '{actual_admonition}', \"\n                        f\"expected '{expected_admonition}'\"\n                    )\n\n            # Check if section shouldn't have admonition but does\n            section_config: Optional[SectionConfig] = next(\n                (s for s in self.sections_config if s.name.lower() == section_title), None\n            )\n            if section_config and section_config.admonition is False:\n                errors.append(f\"Section '{section_title}' is configured as non-admonition but found as admonition\")\n\n        return errors\n\n    def _check_colon_usage(self, docstring: str) -&gt; list[str]:\n        \"\"\"\n        Check that colons are used correctly for admonition vs non-admonition sections.\n        \"\"\"\n\n        errors: list[str] = []\n\n        # Check admonition sections (should not end with colon)\n        admonition_pattern = r\"(?:\\?\\?\\?[+]?|!!!)\\s+\\w+\\s+\\\"([^\\\"]+)\\\"\"\n        matches: Iterator[re.Match[str]] = re.finditer(admonition_pattern, docstring, re.IGNORECASE)\n\n        for match in matches:\n            section_title: str = match.group(1)\n            has_colon: bool = section_title.endswith(\":\")\n            section_title_clean: str = section_title.rstrip(\":\").lower()\n\n            # Find config for this section\n            section_config: Optional[SectionConfig] = next(\n                (s for s in self.sections_config if s.name.lower() == section_title_clean), None\n            )\n            if section_config and isinstance(section_config.admonition, str) and section_config.admonition:\n                if has_colon:\n                    errors.append(\n                        f\"Section '{section_title_clean}' is an admonition, therefore it should not end with ':', \"\n                        f\"see: '{match.group(0)}'\"\n                    )\n\n        # Check non-admonition sections (should end with colon)\n        non_admonition_pattern = r\"^(\\w+)(:?)$\"\n        for line in docstring.split(\"\\n\"):\n            line: str = line.strip()\n            match: Optional[re.Match[str]] = re.match(non_admonition_pattern, line)\n            if match:\n                section_name: str = match.group(1).lower()\n                has_colon: bool = match.group(2) == \":\"\n\n                # Find config for this section\n                section_config = next((s for s in self.sections_config if s.name.lower() == section_name), None)\n                if section_config and section_config.admonition is False:\n                    if not has_colon:\n                        errors.append(\n                            f\"Section '{section_name}' is non-admonition, therefore it must end with ':', \"\n                            f\"see: '{line}'\"\n                        )\n\n        return errors\n\n    def _check_title_case_sections(self, docstring: str) -&gt; list[str]:\n        \"\"\"\n        Check that non-admonition sections are single word, title case, and match config name.\n        \"\"\"\n\n        errors: list[str] = []\n\n        # Pattern to find section headers (single word followed by optional colon)\n        section_pattern = r\"^(\\w+):?$\"\n\n        for line in docstring.split(\"\\n\"):\n            line: str = line.strip()\n            match: Optional[re.Match[str]] = re.match(section_pattern, line)\n            if match:\n                section_word: str = match.group(1)\n                section_name_lower: str = section_word.lower()\n\n                # Check if this is a configured non-admonition section\n                section_config: Optional[SectionConfig] = next(\n                    (s for s in self.sections_config if s.name.lower() == section_name_lower), None\n                )\n                if section_config and section_config.admonition is False:\n                    # Check if it's title case\n                    expected_title_case: str = section_config.name.title()\n                    if section_word != expected_title_case:\n                        errors.append(\n                            f\"Section '{section_name_lower}' must be in title case as '{expected_title_case}', \"\n                            f\"found: '{section_word}'\"\n                        )\n\n        return errors\n\n    def _check_parentheses_validation(self, docstring: str) -&gt; list[str]:\n        \"\"\"\n        Check that list_type and list_name_and_type sections have proper parentheses.\n        \"\"\"\n\n        errors: list[str] = []\n\n        # Get sections that require parentheses\n        parentheses_sections: list[SectionConfig] = [\n            s for s in self.sections_config if s.type in [\"list_type\", \"list_name_and_type\"]\n        ]\n\n        if not parentheses_sections:\n            return errors\n\n        # Check each line in the docstring\n        lines: list[str] = docstring.split(\"\\n\")\n        current_section = None\n\n        for i, line in enumerate(lines):\n            stripped_line: str = line.strip()\n\n            # Detect section headers\n            # Admonition sections\n            admonition_match: Optional[re.Match[str]] = re.match(\n                r\"(?:\\?\\?\\?[+]?|!!!)\\s+\\w+\\s+\\\"([^\\\"]+)\\\"\", stripped_line, re.IGNORECASE\n            )\n            if admonition_match:\n                section_name: str = admonition_match.group(1).lower()\n                current_section: Optional[SectionConfig] = next(\n                    (s for s in parentheses_sections if s.name.lower() == section_name), None\n                )\n                continue\n\n            # Non-admonition sections - only match actual section headers, not indented content\n            # Section headers should be at the start of the line (no leading whitespace)\n            if not line.startswith((\" \", \"\\t\")):  # Not indented\n                simple_section_match: Optional[re.Match[str]] = re.match(r\"^(\\w+):?$\", stripped_line)\n                if simple_section_match:\n                    section_name: str = simple_section_match.group(1).lower()\n                    # Only consider it a section if it matches our known sections\n                    potential_section: Optional[SectionConfig] = next(\n                        (s for s in self.sections_config if s.name.lower() == section_name), None\n                    )\n                    if potential_section:\n                        # This is a real section header\n                        current_section = next(\n                            (s for s in parentheses_sections if s.name.lower() == section_name), None\n                        )\n                        continue\n                    # If it doesn't match a known section, fall through to content processing\n\n            # Check content lines if we're in a parentheses-required section\n            if current_section and stripped_line and not stripped_line.startswith((\"!\", \"?\", \"#\")):\n                # Look for parameter/type definitions\n                if \":\" in stripped_line:\n                    # Skip description lines that start with common description words\n                    description_prefixes = [\n                        \"default:\",\n                        \"note:\",\n                        \"example:\",\n                        \"see:\",\n                        \"warning:\",\n                        \"info:\",\n                        \"tip:\",\n                        \"returns:\",\n                    ]\n                    is_description_line = any(\n                        stripped_line.lower().startswith(prefix) for prefix in description_prefixes\n                    )\n\n                    # Skip lines that are clearly descriptions (containing \"Default:\", etc.)\n                    if (\n                        is_description_line\n                        or \"Default:\" in stripped_line\n                        or \"Output format:\" in stripped_line\n                        or \"Show examples:\" in stripped_line\n                    ):\n                        continue\n\n                    # For list_name_and_type sections, check format like \"name (type):\" or \"(type):\"\n                    if current_section.type == \"list_name_and_type\":\n                        # Pattern: name (type): or (type):\n                        # But skip if it doesn't look like a parameter definition (e.g., has multiple words before the colon)\n                        colon_part = stripped_line.split(\":\")[0].strip()\n                        # Skip if it contains phrases that indicate it's a description, not a parameter\n                        if any(\n                            word in colon_part.lower() for word in [\"default\", \"output\", \"format\", \"show\", \"example\"]\n                        ):\n                            continue\n\n                        if not re.search(r\"\\([^)]+\\):\", stripped_line):\n                            errors.append(\n                                f\"Section '{current_section.name}' (type: '{current_section.type}') requires \"\n                                f\"parenthesized types, see: '{stripped_line}'\"\n                            )\n\n                    # For list_type sections, check format like \"(Type):\"\n                    elif current_section.type == \"list_type\":\n                        # Pattern: (Type):\n                        if not re.search(r\"^\\s*\\([^)]+\\):\", stripped_line):\n                            errors.append(\n                                f\"Section '{current_section.name}' (type: '{current_section.type}') requires \"\n                                f\"parenthesized types, see: '{stripped_line}'\"\n                            )\n\n        return errors\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringChecker.__init__","title":"__init__","text":"<pre><code>__init__(sections_config: list[SectionConfig]) -&gt; None\n</code></pre> <p>Summary</p> <p>Initialize the docstring checker.</p> <p>Parameters:</p> Name Type Description Default <code>sections_config</code> <code>list[SectionConfig]</code> <p>List of section configurations to check against.</p> required Source code in <code>src/docstring_format_checker/core.py</code> <pre><code>def __init__(self, sections_config: list[SectionConfig]) -&gt; None:\n    \"\"\"\n    !!! note \"Summary\"\n        Initialize the docstring checker.\n\n    Params:\n        sections_config (list[SectionConfig]):\n            List of section configurations to check against.\n    \"\"\"\n    self.sections_config: list[SectionConfig] = sections_config\n    self.required_sections: list[SectionConfig] = [s for s in sections_config if s.required]\n    self.optional_sections: list[SectionConfig] = [s for s in sections_config if not s.required]\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringChecker.sections_config","title":"sections_config  <code>instance-attribute</code>","text":"<pre><code>sections_config: list[SectionConfig] = sections_config\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringChecker.required_sections","title":"required_sections  <code>instance-attribute</code>","text":"<pre><code>required_sections: list[SectionConfig] = [\n    s for s in sections_config if required\n]\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringChecker.optional_sections","title":"optional_sections  <code>instance-attribute</code>","text":"<pre><code>optional_sections: list[SectionConfig] = [\n    s for s in sections_config if not required\n]\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringChecker.check_file","title":"check_file","text":"<pre><code>check_file(\n    file_path: Union[str, Path],\n) -&gt; list[DocstringError]\n</code></pre> <p>Summary</p> <p>Check docstrings in a Python file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Union[str, Path]</code> <p>Path to the Python file to check.</p> required <p>Returns:</p> Type Description <code>list[DocstringError]</code> <p>List of DocstringError objects for any validation failures.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist.</p> <code>InvalidFileError</code> <p>If the file is not a Python file.</p> <code>UnicodeError</code> <p>If the file can't be decoded.</p> <code>SyntaxError</code> <p>If the file contains invalid Python syntax.</p> Source code in <code>src/docstring_format_checker/core.py</code> <pre><code>def check_file(self, file_path: Union[str, Path]) -&gt; list[DocstringError]:\n    \"\"\"\n    !!! note \"Summary\"\n        Check docstrings in a Python file.\n\n    Params:\n        file_path (Union[str, Path]):\n            Path to the Python file to check.\n\n    Returns:\n        (list[DocstringError]):\n            List of DocstringError objects for any validation failures.\n\n    Raises:\n        (FileNotFoundError):\n            If the file doesn't exist.\n        (InvalidFileError):\n            If the file is not a Python file.\n        (UnicodeError):\n            If the file can't be decoded.\n        (SyntaxError):\n            If the file contains invalid Python syntax.\n    \"\"\"\n\n    file_path = Path(file_path)\n    if not file_path.exists():\n        raise FileNotFoundError(f\"File not found: {file_path}\")\n\n    if file_path.suffix != \".py\":\n        raise InvalidFileError(f\"File must be a Python file (.py): {file_path}\")\n\n    # Read and parse the file\n    try:\n        with open(file_path, encoding=\"utf-8\") as f:\n            content: str = f.read()\n    except UnicodeDecodeError as e:\n        raise UnicodeError(f\"Cannot decode file {file_path}: {e}\") from e\n\n    try:\n        tree: ast.Module = ast.parse(content)\n    except SyntaxError as e:\n        raise SyntaxError(f\"Invalid Python syntax in {file_path}: {e}\") from e\n\n    # Extract all functions and classes\n    items: list[FunctionAndClassDetails] = self._extract_items(tree)\n\n    # Check each item\n    errors: list[DocstringError] = []\n    for item in items:\n        try:\n            self._check_single_docstring(item, str(file_path))\n        except DocstringError as e:\n            errors.append(e)\n\n    return errors\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringChecker.check_directory","title":"check_directory","text":"<pre><code>check_directory(\n    directory_path: Union[str, Path],\n    exclude_patterns: Optional[list[str]] = None,\n) -&gt; dict[str, list[DocstringError]]\n</code></pre> <p>Summary</p> <p>Check docstrings in all Python files in a directory recursively.</p> <p>Parameters:</p> Name Type Description Default <code>directory_path</code> <code>Union[str, Path]</code> <p>Path to the directory to check.</p> required <code>exclude_patterns</code> <code>Optional[list[str]]</code> <p>List of glob patterns to exclude.</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the directory doesn't exist.</p> <code>DirectoryNotFoundError</code> <p>If the path is not a directory.</p> <p>Returns:</p> Type Description <code>dict[str, list[DocstringError]]</code> <p>Dictionary mapping file paths to lists of DocstringError objects.</p> Source code in <code>src/docstring_format_checker/core.py</code> <pre><code>def check_directory(\n    self,\n    directory_path: Union[str, Path],\n    exclude_patterns: Optional[list[str]] = None,\n) -&gt; dict[str, list[DocstringError]]:\n    \"\"\"\n    !!! note \"Summary\"\n        Check docstrings in all Python files in a directory recursively.\n\n    Params:\n        directory_path (Union[str, Path]):\n            Path to the directory to check.\n        exclude_patterns (Optional[list[str]]):\n            List of glob patterns to exclude.\n\n    Raises:\n        (FileNotFoundError):\n            If the directory doesn't exist.\n        (DirectoryNotFoundError):\n            If the path is not a directory.\n\n    Returns:\n        (dict[str, list[DocstringError]]):\n            Dictionary mapping file paths to lists of DocstringError objects.\n    \"\"\"\n\n    directory_path = Path(directory_path)\n    if not directory_path.exists():\n        raise FileNotFoundError(f\"Directory not found: {directory_path}\")\n\n    if not directory_path.is_dir():\n        raise DirectoryNotFoundError(f\"Path is not a directory: {directory_path}\")\n\n    python_files: list[Path] = list(directory_path.glob(\"**/*.py\"))\n\n    # Filter out excluded patterns\n    if exclude_patterns:\n        filtered_files: list[Path] = []\n        for file_path in python_files:\n            relative_path: Path = file_path.relative_to(directory_path)\n            should_exclude = False\n            for pattern in exclude_patterns:\n                if fnmatch.fnmatch(str(relative_path), pattern):\n                    should_exclude = True\n                    break\n            if not should_exclude:\n                filtered_files.append(file_path)\n        python_files = filtered_files\n\n    # Check each file\n    results: dict[str, list[DocstringError]] = {}\n    for file_path in python_files:\n        try:\n            errors: list[DocstringError] = self.check_file(file_path)\n            if errors:  # Only include files with errors\n                results[str(file_path)] = errors\n        except (FileNotFoundError, ValueError, SyntaxError) as e:\n            # Create a special error for file-level issues\n            error = DocstringError(\n                message=str(e),\n                file_path=str(file_path),\n                line_number=0,\n                item_name=\"\",\n                item_type=\"file\",\n            )\n            results[str(file_path)] = [error]\n\n    return results\n</code></pre>"},{"location":"code/exceptions/","title":"Exceptions","text":""},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions","title":"docstring_format_checker.utils.exceptions","text":""},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.DocstringError","title":"DocstringError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when a docstring validation error occurs.</p> Source code in <code>src/docstring_format_checker/utils/exceptions.py</code> <pre><code>class DocstringError(Exception):\n    \"\"\"\n    Exception raised when a docstring validation error occurs.\n    \"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        file_path: str,\n        line_number: int,\n        item_name: str,\n        item_type: str,\n    ) -&gt; None:\n        self.message = message\n        self.file_path = file_path\n        self.line_number = line_number\n        self.item_name = item_name\n        self.item_type = item_type\n        super().__init__(f\"Line {line_number}, {item_type} '{item_name}': {message}\")\n</code></pre>"},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.DocstringError.__init__","title":"__init__","text":"<pre><code>__init__(\n    message: str,\n    file_path: str,\n    line_number: int,\n    item_name: str,\n    item_type: str,\n) -&gt; None\n</code></pre> Source code in <code>src/docstring_format_checker/utils/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    file_path: str,\n    line_number: int,\n    item_name: str,\n    item_type: str,\n) -&gt; None:\n    self.message = message\n    self.file_path = file_path\n    self.line_number = line_number\n    self.item_name = item_name\n    self.item_type = item_type\n    super().__init__(f\"Line {line_number}, {item_type} '{item_name}': {message}\")\n</code></pre>"},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.DocstringError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.DocstringError.file_path","title":"file_path  <code>instance-attribute</code>","text":"<pre><code>file_path = file_path\n</code></pre>"},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.DocstringError.line_number","title":"line_number  <code>instance-attribute</code>","text":"<pre><code>line_number = line_number\n</code></pre>"},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.DocstringError.item_name","title":"item_name  <code>instance-attribute</code>","text":"<pre><code>item_name = item_name\n</code></pre>"},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.DocstringError.item_type","title":"item_type  <code>instance-attribute</code>","text":"<pre><code>item_type = item_type\n</code></pre>"},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.InvalidConfigError","title":"InvalidConfigError","text":"<p>               Bases: <code>Exception</code></p> Source code in <code>src/docstring_format_checker/utils/exceptions.py</code> <pre><code>class InvalidConfigError(Exception):\n    pass\n</code></pre>"},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.InvalidConfigError_DuplicateOrderValues","title":"InvalidConfigError_DuplicateOrderValues","text":"<p>               Bases: <code>Exception</code></p> Source code in <code>src/docstring_format_checker/utils/exceptions.py</code> <pre><code>class InvalidConfigError_DuplicateOrderValues(Exception):\n    pass\n</code></pre>"},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.InvalidTypeValuesError","title":"InvalidTypeValuesError","text":"<p>               Bases: <code>Exception</code></p> Source code in <code>src/docstring_format_checker/utils/exceptions.py</code> <pre><code>class InvalidTypeValuesError(Exception):\n    pass\n</code></pre>"},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.InvalidFileError","title":"InvalidFileError","text":"<p>               Bases: <code>OSError</code></p> Source code in <code>src/docstring_format_checker/utils/exceptions.py</code> <pre><code>class InvalidFileError(OSError):\n    pass\n</code></pre>"},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.DirectoryNotFoundError","title":"DirectoryNotFoundError","text":"<p>               Bases: <code>OSError</code></p> Source code in <code>src/docstring_format_checker/utils/exceptions.py</code> <pre><code>class DirectoryNotFoundError(OSError):\n    pass\n</code></pre>"},{"location":"usage/changelog/","title":"Change Log","text":"<p>v0.6.0</p> <p>v0.5.0</p> <p>v0.4.0</p> <p>v0.3.0</p> <p>v0.2.0</p> <p>v0.1.0</p> <p></p> <p>             Hardcoded absolute path used in test. The <code>cwd</code> parameter contains a hardcoded personal directory path that will not work on other systems. This should use a relative path or be made configurable.             Co-authored-by: Copilot 175728472+Copilot@users.noreply.github.com (by chrimaho) View</p> <pre><code>    * Add a nice README (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/6db7b02cf00e7e931170055c30e17f2b3a48beda)\n\n    * Fix a typo (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/af7ac2cfa65570f0247195f19ce46d27a8f6e8eb)\n\n    * Add docs structure and config (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/44d4d04063ea3b21d4f7fc9266973ba0294baada)\n\n    * Add project guidelines (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/779197007301f3ee9fa8f997a0f39d577b096482)\n\n    * Refactor exception handling: rename exceptions for clarity and consistency (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/864f6021a25d165e50da7f4c5791e4922645797a)\n\n    * Remove `check-docstrings` from the `pre-commit` checks (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/f80b83a6cdcf156058218981fa3bc1f9d310659d)\n\n    * Fix failing Unit Tests (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/ec53fa70fe4c524ced0c05646b742e31ebc1415f)\n\n    * Clarify some of the `raise` sections to instead use Exceptions defined in the local module, instead of the default Exceptions from the builtins module (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/0719d8e11d3da4ed40d131d19ff2d61ceb494f14)\n\n    * Refine any sections which use the `/` operator to merge objects in the `Path` package to instead use the `.joinpath()` method. This is to make the code more robust and more readable. (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/cffa310c67ac19aca060b74f5d9616262f89140a)\n\n    * Correct and refine some of the docstrings in the `config` and `core` modules (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/8921f24d6096d5193ed5f4326cdbd41769b3a752)\n\n    * Add new `_validate_config_order()` function to the `config` module (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/98a2409976dec6daebe4d007ec3c14a0267cbfea)\n\n    * Refine how the `import`'s and `export`'s are defined across both the `cli` and `config` modules (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/f711ac7df7adc2d27f251238dcc84c551c8b4c8d)\n\n    * Restructure how the `VALID_TYPES` constant is defined and utilised in the `config` module (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/6cdc073a2c089ac4253102b9d176566b6d81e1f1)\n\n    * Add helpful docstrings and additional headers to the `cli` and `config` modules (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/5e9869a0612fb51eb072afe439554c3355f3bee9)\n\n    * Refactor the Callbacks in the `cli` module to have better structure and organisation (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/5e227ec35cc69cddcd4b6be244a7241ea1066112)\n\n    * Reorder the steps for the checks scripts (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/22286e4be755a13499b3cac7a06ad26910622dd8)\n\n    * Add new exception classes for improved clarity and organization (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/07799214a39c33aa82559b5df846f49cb68e778b)\n\n    * Bring code coverage for all unit tests up to 100% coverage (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/12aa070a8d220781789a7618d7a5e65510475a4b)\n\n    * Update dependencies and refine project configuration in `pyproject.toml` (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/d98ed78b8cf46b25d647f15c41b58efa4accc49e)\n\n    * Initial commit of all package unit tests (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/7331f758dcd4707af4a24065a81c2751a19fe0d6)\n\n    * Initial commit of all package modules (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/91493ee736bdbf4c840b523fcfeb7d5940e6a15c)\n\n    * Add utility scripts for command execution and linting checks (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/609e9cb37b1f5d68a0dd0970cce8cf3e5c6092ce)\n\n    * Fix typo (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/4c0e003d2226a19a8f0596f821f5ca8c9feafa7b)\n\n    * Tweak some of the core package config (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/7d870ad6959ed15496b74615b91517c1697fb4ff)\n\n    * Initial commit of package config (by []()) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/32acad04208e5ac6302e261dcd5f76f7b09d61a1)\n\n    * Initial commit (by [chrimaho](https://github.com/chrimaho)) [View](https://github.com/data-science-extensions/docstring-format-checker/commit/416b0b36cf5c4615295a7464a1544911aaa253d5)\n</code></pre>"},{"location":"usage/changelog/#v060-advanced-list-output-formatting-error-summary-display","title":"v0.6.0 - Advanced List Output Formatting &amp; Error Summary Display","text":"<p><code>v0.6.0</code> <code>2025-09-08</code> data-science-extensions/docstring-format-checker/releases/v0.6.0</p> Release Notes Updates <ul> <li>Resove issues with the output when <code>-o list</code> and with the summary stats on the printed output (by chrimaho) View</li> </ul>"},{"location":"usage/changelog/#whats-changed","title":"What's Changed","text":"<ul> <li>Advanced List Output Formatting &amp; Error Summary Display by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/6</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/docstring-format-checker/compare/v0.5.0...v0.6.0</p>"},{"location":"usage/changelog/#v050-streamline-cli-architecture","title":"v0.5.0 - Streamline CLI Architecture","text":"<p><code>v0.5.0</code> <code>2025-09-07</code> data-science-extensions/docstring-format-checker/releases/v0.5.0</p> Release Notes Updates <ul> <li> <p>Increase code coverage (by chrimaho) View</p> </li> <li> <p>Fix failing unit tests (by chrimaho) View</p> </li> <li> <p>Add <code>--examples</code>/<code>-e</code> flags to the CLI, instead of using a sub-command (by chrimaho) View</p> </li> <li> <p>Remove the unnecessary <code>_parse_boolean_flag()</code> function and all associated unit tests (by chrimaho) View</p> </li> <li> <p>Remove all references to the <code>--recursive</code>/<code>-r</code> flag, and ensure that it will always be recursive by default (by chrimaho) View</p> </li> <li> <p>Update docstring format in CLI module to be more pythonic (by chrimaho) View</p> </li> </ul>"},{"location":"usage/changelog/#whats-changed_1","title":"What's Changed","text":"<ul> <li>Streamline CLI Architecture: Simplify Interface Design and Achieve Complete Test Coverage by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/5</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/docstring-format-checker/compare/v0.4.0...v0.5.0</p>"},{"location":"usage/changelog/#v040-enhance-cli-error-output-formatting","title":"v0.4.0 - Enhance CLI Error Output Formatting","text":"<p><code>v0.4.0</code> <code>2025-09-06</code> data-science-extensions/docstring-format-checker/releases/v0.4.0</p> Release Notes Updates <ul> <li> <p>Fix typo (by chrimaho) View</p> </li> <li> <p>Enhance error message formatting in CLI output and add corresponding unit tests (by chrimaho) View</p> </li> </ul>"},{"location":"usage/changelog/#whats-changed_2","title":"What's Changed","text":"<ul> <li>Enhanced CLI Error Output Formatting: Improve Multi-Error Message Presentation and Achieve Comprehensive Test Coverage by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/4</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/docstring-format-checker/compare/v0.3.0...v0.4.0</p>"},{"location":"usage/changelog/#v030-enhance-validation-configuration-rules","title":"v0.3.0 - Enhance Validation &amp; Configuration Rules","text":"<p><code>v0.3.0</code> <code>2025-09-06</code> data-science-extensions/docstring-format-checker/releases/v0.3.0</p> Release Notes Updates <ul> <li> <p>Fix typo (by chrimaho) View</p> </li> <li> <p>Add additional unit tests to check more edge cases (by chrimaho) View</p> </li> <li> <p>Add more unit tests for edge cases (by chrimaho) View</p> </li> <li> <p>Enhance admonition validation by ensuring admonition is a string and refining section name matching patterns (by chrimaho) View</p> </li> <li> <p>Add parentheses validation for list type sections in docstring checks (by chrimaho) View</p> </li> <li> <p>Add title case validation for non-admonition sections in docstrings (by chrimaho) View</p> </li> <li> <p>Add colon usage checks for admonition and non-admonition sections in docstrings (by chrimaho) View</p> </li> <li> <p>Add blank lines after docstrings for improved readability (by chrimaho) View</p> </li> <li> <p>Refactor <code>SectionConfig()</code> to enhance admonition validation and type handling (by chrimaho) View</p> </li> <li> <p>Extend the <code>core</code> module to better handle edge-cases     This will now throw errors when:</p> <ol> <li>When there is a section in a docstring which are not defined in the config</li> <li>When the admonition used in the docstring does not match the admonition defined in the config (by chrimaho) View</li> </ol> </li> </ul>"},{"location":"usage/changelog/#whats-changed_3","title":"What's Changed","text":"<ul> <li>Comprehensive Docstring Validation Enhancement: Introduce Advanced Rule Enforcement and Achieve 100% Test Coverage by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/3</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/docstring-format-checker/compare/v0.2.0...v0.3.0</p>"},{"location":"usage/changelog/#v020-allow-app-to-properly-handle-functions-with-overload-decorator","title":"v0.2.0 - Allow app to properly handle functions with @overload decorator","text":"<p><code>v0.2.0</code> <code>2025-09-04</code> data-science-extensions/docstring-format-checker/releases/v0.2.0</p> Release Notes Updates <ul> <li> <p>typo (by chrimaho) View</p> </li> <li> <p>Fix typo (by chrimaho) View</p> </li> <li> <p>Fix bug regarding bumping versions during CD workflow (by chrimaho) View</p> </li> <li> <p>Add support for ignoring <code>@overload</code> functions in docstring checks (by chrimaho) View</p> </li> </ul>"},{"location":"usage/changelog/#whats-changed_4","title":"What's Changed","text":"<ul> <li>Fix <code>@overload</code> Function Handling: Enhance Docstring Checker to Properly Ignore Function Type Overloads by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/2</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/docstring-format-checker/compare/v0.1.0...v0.2.0</p>"},{"location":"usage/changelog/#v010-first-minor-release","title":"v0.1.0 - First Minor Release","text":"<p><code>v0.1.0</code> <code>2025-08-31</code> data-science-extensions/docstring-format-checker/releases/v0.1.0</p> Release Notes Updates <ul> <li> <p>Fix bug in CD workflow when building package (by chrimaho) View</p> </li> <li> <p>Fix bugs in Git commit processes during CD workflow (by chrimaho) View</p> </li> <li> <p>Fix bug (by chrimaho) View</p> </li> <li> <p>Fix git command for coverage report (by chrimaho) View</p> </li> <li> <p>Fix git commands (by chrimaho) View</p> </li> <li> <p>Update Code Coverage info (by chrimaho) View</p> </li> <li> <p>Ensure coverage report directory exists before copying files (by chrimaho) View</p> </li> <li> <p>Streamline constants in the <code>scripts</code> module     Co-authored-by: Copilot 175728472+Copilot@users.noreply.github.com (by chrimaho) View</p> </li> <li> <p>Fix failing unit tests for macos, caused by <code>rm</code> flags (by chrimaho) View</p> </li> <li> <p>Enhance CLI test assertions for output flexibility and Windows compatibility (by chrimaho) View</p> </li> <li> <p>Resolve failing unit tests on macos (by chrimaho) View</p> </li> <li> <p>Fix failing unit tests (by chrimaho) View</p> </li> <li> <p>Restructure unit tests to better handle temp files on the windows os (by chrimaho) View</p> </li> <li> <p>Fix failing <code>macos</code> unit test (by chrimaho) View</p> </li> <li> <p>Fix bug (by chrimaho) View</p> </li> <li> <p>Fix configuration file path assertion in CLI tests (by chrimaho) View</p> </li> <li> <p>Fix failing unit tests (by chrimaho) View</p> </li> <li> <p>Update CI workflow to only run on Python versions 3.9 to 3.13 (by chrimaho) View</p> </li> <li> <p>Refactor type hints in <code>test_config.py</code> for consistency and clarity (by chrimaho) View</p> </li> <li> <p>Strip ANSI codes from all <code>CliRunner</code> output in unit tests (by chrimaho) View</p> </li> <li> <p>Update <code>pyupgrade</code> pre-commit config to target Python 3.7 features (previously 3.9) (by chrimaho) View</p> </li> <li> <p>Refactor all type hints to use <code>Optional</code> and <code>Union</code> instead of <code>|</code> for improved clarity,  consistency, and compatability (by chrimaho) View</p> </li> <li> <p>Add Python 3.7 to CI workflow matrix for enhanced compatibility (by chrimaho) View</p> </li> <li> <p>Add detailed docstrings to all core modules (by chrimaho) View</p> </li> <li> <p>Add <code>strip_ansi_codes()</code> function to generic Unit Tests setup and update CLI tests to use it for robust output validation (by chrimaho) View</p> </li> <li> <p>Do more debugging in the CLI unit tests (by chrimaho) View</p> </li> <li> <p>Add <code>re</code> to CLI unit tests (by chrimaho) View</p> </li> <li> <p>Add <code>strip_ansi_codes()</code> function to the CLI Unit Tests (by chrimaho) View</p> </li> <li> <p>Debug CLI Unit Test 19 (by chrimaho) View</p> </li> <li> <p>Temporarily turn off <code>pylint</code> checks during pre-commit hooks (by chrimaho) View</p> </li> <li> <p>Refactor CLI to use Typer imports directly and improve error messages (by chrimaho) View</p> </li> <li> <p>Fix linting (by chrimaho) View</p> </li> <li> <p>Remove redundant reference code (by chrimaho) View</p> </li> <li> <p>Update CI and CD workflows to use specific script paths for running checks (by chrimaho) View</p> </li> <li> <p>Fix CLI tests: Disable Rich colors to prevent ANSI formatting issues in CI</p> <ul> <li>Set NO_COLOR=1 environment variable in CliRunner to ensure consistent test output</li> <li>Resolves GitHub Actions test failures due to Rich library adding ANSI color codes</li> <li>Local and CI environments now produce identical plain text error messages</li> <li>All 175 tests now pass with 100% coverage in both local and CI environments (by chrimaho) View</li> </ul> </li> <li> <p>Improve error message assertions for invalid recursive flag in CLI tests (by chrimaho) View</p> </li> <li> <p>Add CD workflow along with scripts to bump version and generate changelog (by chrimaho) View</p> </li> <li> <p>Fix typo (by chrimaho) View</p> </li> <li> <p>Streamline automation scripts (by chrimaho) View</p> </li> <li> <p>Add CI workflow (by chrimaho) View</p> </li> <li> <p>Fix hardcoding in the Unit Tests</p> </li> </ul>"},{"location":"usage/changelog/#whats-changed_5","title":"What's Changed","text":"<ul> <li>Complete Foundation Setup: Introduce Docstring Format Checker CLI Tool with 100% Test Coverage and Professional Documentation by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/1</li> </ul>"},{"location":"usage/changelog/#new-contributors","title":"New Contributors","text":"<ul> <li>@chrimaho made their first contribution in https://github.com/data-science-extensions/docstring-format-checker/pull/1</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/docstring-format-checker/commits/v0.1.0</p>"},{"location":"usage/contributing/","title":"Contribution Guidelines","text":"<p>All contributions are welcome! Please follow these guidelines to ensure a smooth contribution process.</p>"},{"location":"usage/contributing/#overview","title":"Overview","text":"<p>Here are some guidelines to help you get started:</p> <ol> <li>Raise an Issue: Before starting work on a new feature or bug fix, please raise an issue to discuss it. All enhancements and changes are discussed in the issues section. This helps us avoid duplicate work and ensures that your contribution aligns with the project's goals.</li> <li>Check the issues and milestones: Look at the issues and milestones to see if your contribution fits into the current roadmap.</li> <li>Fork the Repository: Create a fork of the repository to work on your changes. This allows you to make changes without affecting the main codebase.</li> <li>Create a new branch: When working on a new feature or bug fix, create a new branch from the <code>main</code> branch. Use a descriptive name for your branch that reflects the changes you are making.</li> <li>Clone the repository: Clone your forked repository to your local machine to start working on it.</li> <li>Creating your environment: Set up your development environment according to the project's requirements. This may include installing dependencies, setting up virtual environments, and configuring tools like uv, pre-commit, pytest, and mypy.</li> <li>Make your changes: Implement your changes in the new branch. Ensure that your code adheres to the project's coding standards and style guidelines.</li> <li>Commit your changes: Commit your changes with a clear and descriptive commit message.</li> <li>Write tests: If you are adding new features or fixing bugs, please write tests to ensure that your changes work as expected.</li> <li>Submit a Pull Request: Once you have made your changes and committed them, submit a pull request to the main repository. Provide a clear description of the changes you made and reference any related issues.</li> </ol>"},{"location":"usage/contributing/#raise-an-issue","title":"Raise an Issue","text":"<p>If you find a bug or have a feature request, please raise an issue. This helps us track and prioritize contributions effectively.</p> <p>Raise an Issue</p> <p>When raising an issue, please follow these guidelines to ensure clarity and effectiveness:</p> <ol> <li>Title: Provide a clear and concise title that summarizes the issue or feature request.</li> <li>Description: Include a detailed description of the issue or feature request. Explain what the problem is, how it can be reproduced, and any relevant context.</li> <li>Steps to Reproduce: If applicable, provide a step-by-step guide on how to reproduce the issue. This helps us understand the problem better.</li> <li>Expected vs Actual Behavior: Describe what you expected to happen and what actually happened. This helps clarify the issue.</li> <li>Screenshots or Logs: If possible, include screenshots or logs that illustrate the issue. This can be very helpful for debugging.</li> <li>Context: Provide any additional context that might be relevant, such as the environment in which the issue occurred (e.g., operating system, Python version, etc.).</li> </ol>"},{"location":"usage/contributing/#issues-and-milestones","title":"Issues and Milestones","text":"<p>We are using issues to track bugs, feature requests, and enhancements, and milestones to organize these issues into manageable chunks.</p> <p>If you want to contribute to the project, please check the current issues and milestones before starting work to ensure that your contribution aligns with the project's goals and priorities. This will help avoid duplication of effort and ensure that your contributions align with the project's roadmap. If you want to add something that is not already listed in the milestones, please raise an issue to discuss it first.</p> <p>You can view the current issues and milestones on the project's GitHub page.</p> <p>View Issues</p> <p>View Milestones</p>"},{"location":"usage/contributing/#create-a-fork","title":"Create a Fork","text":"<p>To contribute to this project, you need to create a fork of the repository. This allows you to make changes without affecting the main codebase.</p> <p>Create a Fork</p>"},{"location":"usage/contributing/#create-a-new-branch","title":"Create a New Branch","text":"<p>When working on a new feature or bug fix, create a new branch from the <code>main</code> branch. Use a descriptive name for your branch that reflects the changes you are making.</p> <p>Create a New Branch</p>"},{"location":"usage/contributing/#clone-the-repository","title":"Clone the Repository","text":"<p>To start working on your forked repository, you need to clone it to your local machine. This allows you to make changes and test them locally before submitting a pull request.</p>"},{"location":"usage/contributing/#creating-your-environment","title":"Creating your Environment","text":"<p>When you are ready to start working on your changes, set up your development environment according to the project's requirements. In this project, we use uv to manage the Python environments, pre-commit for code quality checks, and pytest for testing.</p> <p>This project is a Python docstring format checker that validates docstring structure and content according to configurable rules. The main components include:</p> <ul> <li>Core checker: Validates docstring sections, types, and formatting</li> <li>CLI interface: Command-line tool for checking files and directories</li> <li>Configuration system: TOML-based configuration for customizing validation rules</li> <li>Exception handling: Custom exceptions for different error types</li> </ul> <p>Follow these steps to set up your environment:</p> <ol> <li>Install uv: Follow the instructions in the uv installation guide to install uv.     <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre></li> <li>Sync the environment: Use <code>uv</code> to set up the environment with the required dependencies.     <pre><code>uv sync --all-groups --link-mode=copy\n</code></pre></li> <li>Install pre-commit: Install pre-commit to manage code quality checks.     <pre><code>uv run --link-mode=copy pre-commit install\n</code></pre></li> <li>Update pre-commit hooks: Ensure that the pre-commit hooks are up to date.     <pre><code>uv run --link-mode=copy pre-commit autoupdate\n</code></pre></li> <li>Run tests to verify setup: Verify your environment is working correctly by running the test suite.     <pre><code>uv run ./src/utils/scripts.py check_pytest\n</code></pre></li> </ol>"},{"location":"usage/contributing/#testing-your-changes","title":"Testing Your Changes","text":"<p>This project maintains 100% test coverage. When making changes, ensure you:</p> <ol> <li>Run the full test suite: Use <code>uv run ./src/utils/scripts.py check_pytest</code> to run all tests with coverage reporting</li> <li>Test specific modules: You can run tests for specific modules:    <pre><code>uv run pytest src/tests/test_core.py\nuv run pytest src/tests/test_config.py\nuv run pytest src/tests/test_cli.py\n</code></pre></li> <li>Test the CLI: Test the command-line interface with real files:    <pre><code>uv run docstring-format-checker examples/example_code.py\n</code></pre></li> <li>Add tests for new features: Any new functionality must include comprehensive tests</li> <li>Maintain coverage: Ensure your changes don't reduce the overall test coverage</li> </ol>"},{"location":"usage/contributing/#make-your-changes","title":"Make Your Changes","text":"<p>Make your changes in the new branch you created. Ensure that your code adheres to the project's coding standards and style guidelines. If you are adding new features or fixing bugs, please write tests to ensure that your changes work as expected.</p> <p>This project has specific areas where contributions are especially valuable:</p> <ul> <li>Core validation logic (<code>src/docstring_format_checker/core.py</code>): Enhance docstring parsing and validation</li> <li>Configuration system (<code>src/docstring_format_checker/config.py</code>): Improve TOML configuration handling</li> <li>CLI interface (<code>src/docstring_format_checker/cli.py</code>): Add new command-line options and features</li> <li>Exception handling (<code>src/docstring_format_checker/utils/exceptions.py</code>): Custom exception types</li> <li>Documentation and examples: Help users understand how to use the tool effectively</li> </ul> <p>Ensure you follow the project's coding standards and style guidelines. This includes:</p> <ol> <li>Code Style: Follow the PEP 8 style guide for Python code.</li> <li>Docstrings: Use clear and concise docstrings for all functions, classes, and modules. Since this is a docstring format checker, we practice what we preach! Follow the project's own validation rules and ensure docstrings include:</li> <li>Clear summary sections</li> <li>Proper parameter descriptions with types</li> <li>Return value descriptions</li> <li>Exception documentation where applicable</li> <li>Examples for complex functions</li> <li>Testing: Write unit tests for your code using unittest or pytest. Ensure that your tests cover all new functionality and edge cases.</li> <li>Code Coverage: Maintain high code coverage for your tests. Use Codecov to check your coverage reports.</li> <li>Type Checking: Use mypy for static type checking. Ensure that your code passes all type checks.</li> <li>Docstring Validation: Use the project's own tool to validate your docstrings:    <pre><code>uv run docstring-format-checker src/docstring_format_checker/\n</code></pre></li> </ol> <p>Because you have set up <code>pre-commit</code>, these checks will be run automatically when you commit your changes. If any checks fail, you will need to fix them before you can successfully commit your changes. Further checks will also be run when you submit a pull request, so it's a good idea to ensure your code passes all checks before proceeding.</p>"},{"location":"usage/contributing/#commit-your-changes","title":"Commit Your Changes","text":"<p>Once you have made your changes, commit them with a clear and descriptive commit message. This helps reviewers understand the purpose of your changes. A good commit message should:</p> <ul> <li>Start with a short summary of the changes (50 characters or less).</li> <li>Follow the summary with a blank line.</li> <li>Provide a detailed description of the changes, including why they were made and any relevant context.</li> <li>Use the imperative mood (e.g., \"Add feature\" instead of \"Added feature\").</li> <li>Reference any related issues or pull requests.</li> <li>Use bullet points or paragraphs to organize the description for readability.</li> <li>Avoid using vague terms like \"fixes\" or \"changes\" without context.</li> <li>Be concise but informative, providing enough detail for someone unfamiliar with the code to understand the changes.</li> <li>Avoid including unnecessary information or personal opinions.</li> <li>Use proper grammar and punctuation to enhance clarity.</li> <li>If applicable, include any relevant links to documentation or resources that provide additional context for the changes.</li> <li>If the commit is related to a specific issue, include the issue number in the commit message (e.g., \"Fixes #123\").</li> <li>If the commit is part of a larger feature or task, consider using a prefix like \"feat:\", \"fix:\", or \"chore:\" to categorize the commit (e.g., \"feat: add new feature for user authentication\").</li> <li>If the commit is a work in progress, consider using a prefix like \"WIP:\" to indicate that it is not yet complete (e.g., \"WIP: start implementing new feature for user authentication\").</li> <li>If the commit is a refactor or cleanup, consider using a prefix like \"refactor:\" to indicate that it does not introduce new functionality (e.g., \"refactor: improve code readability and maintainability\").</li> <li>If the commit is a documentation update, consider using a prefix like \"docs:\" to indicate that it only affects documentation (e.g., \"docs: update README with installation instructions\").</li> <li>If the commit is a test update, consider using a prefix like \"test:\" to indicate that it only affects tests (e.g., \"test: add unit tests for new feature\").</li> </ul> <p>Ensure that any pre-commit checks pass before committing your changes. This includes code style checks, linting, and tests. If any checks fail, you will need to fix them before you can successfully commit your changes.</p>"},{"location":"usage/contributing/#submit-a-pull-request","title":"Submit a Pull Request","text":"<p>Once you have made your changes and committed them, submit a pull request to the main repository. Provide a clear description of the changes you made and reference any related issues.</p> <p>When submitting a pull request, please follow these guidelines:</p> <ol> <li>Title: Use a clear and descriptive title that summarizes the changes you made.</li> <li>Description: Provide a detailed description of the changes you made, including:</li> <li>What the changes do.</li> <li>Why the changes were made.</li> <li>Any relevant context or background information.</li> <li>How to test the changes.</li> <li>Reference Issues: If your changes address a specific issue, reference it in the pull request description (e.g., \"Fixes #123\" or \"Closes #123).</li> <li>Link to Related Pull Requests: If your changes are related to other pull requests, link to them in the description.</li> <li>Reviewers: Optionally, you can request specific reviewers to review your pull request.</li> <li>Milestone: Optionally, you can assign your pull request to a specific milestone if it is related to a larger feature or task.</li> <li>Check for Merge Conflicts: Ensure that your branch is up to date with the main branch and that there are no merge conflicts. If there are conflicts, resolve them before submitting the pull request.</li> <li>Be Responsive: Be prepared to respond to feedback from reviewers. They may request changes or ask for clarification on certain aspects of your pull request. Address their comments promptly and respectfully.</li> <li>Be Patient: Reviewers may take some time to review your pull request, especially if they are busy with other tasks. Be patient and give them time to provide feedback.</li> <li>Follow Up: After your pull request is merged, consider following up with any additional changes or improvements based on feedback from the review process. This helps maintain a high-quality codebase and shows that you are committed to improving the project.</li> </ol> <p>Submit a Pull Request</p>"},{"location":"usage/overview/","title":"Overview","text":"<code>docstring-format-checker</code>"},{"location":"usage/overview/#introduction","title":"Introduction","text":"<p>A powerful Python CLI tool that validates docstring formatting and completeness using AST parsing. Ensure consistent, high-quality documentation across your entire codebase with configurable validation rules and rich terminal output.</p> <p>Key Features:</p> <ul> <li>\ud83d\udd0d AST-based parsing - Robust code analysis without regex fragility</li> <li>\u2699\ufe0f Configurable validation - Four section types with TOML-based configuration</li> <li>\ud83d\udcc1 Hierarchical config discovery - Automatic <code>pyproject.toml</code> detection</li> <li>\ud83c\udfa8 Rich terminal output - Beautiful colored output and error tables</li> <li>\ud83d\ude80 Dual CLI entry points - Use <code>docstring-format-checker</code> or <code>dfc</code></li> <li>\ud83d\udee1\ufe0f 100% test coverage - Thoroughly tested and reliable</li> </ul>"},{"location":"usage/overview/#quick-start","title":"Quick Start","text":"<pre><code># Install\nuv add docstring-format-checker\n\n# Check a single file\ndfc check my_module.py\n\n# Check entire directory\ndfc check src/\n\n# Generate example configuration\ndfc config-example\n</code></pre>"},{"location":"usage/overview/#key-urls","title":"Key URLs","text":"<p>For reference, these URL's are used:</p> Type Source URL Git Repo GitHub https://github.com/data-science-extensions/docstring-format-checker Python Package PyPI https://pypi.org/project/docstring-format-checker Package Docs Pages https://data-science-extensions.com/docstring-format-checker"},{"location":"usage/overview/#section-types","title":"Section Types","text":"<p>Configure validation for four types of docstring sections:</p> Type Description Example Use <code>free_text</code> Admonition-style sections Summary, details, examples <code>list_name</code> Simple name lists Simple parameter lists <code>list_type</code> Type-only lists Raises, yields sections <code>list_name_and_type</code> Name and type lists Parameters, returns with types"},{"location":"usage/overview/#configuration","title":"Configuration","text":"<p>Create a <code>pyproject.toml</code> with your validation rules:</p> <pre><code>[tool.dfc]\n\n[[tool.dfc.sections]]\norder = 1\nname = \"summary\"\ntype = \"free_text\"\nadmonition = \"note\"\nprefix = \"!!!\"\nrequired = true\n\n[[tool.dfc.sections]]\norder = 2\nname = \"params\"\ntype = \"list_name_and_type\"\nrequired = true\n\n[[tool.dfc.sections]]\norder = 3\nname = \"returns\"\ntype = \"list_name_and_type\"\nrequired = false\n\n[[tool.dfc.sections]]\norder = 4\nname = \"raises\"\ntype = \"list_type\"\nrequired = false\n</code></pre>"},{"location":"usage/overview/#installation","title":"Installation","text":"<p>You can install and use this package multiple ways by using any of your preferred methods: <code>pip</code>, <code>pipenv</code>, <code>poetry</code>, or <code>uv</code>.</p>"},{"location":"usage/overview/#using-pip","title":"Using <code>pip</code>:","text":"<ol> <li> <p>In your terminal, run:</p> <pre><code>python3 -m pip install --upgrade pip\npython3 -m pip install docstring-format-checker\n</code></pre> </li> <li> <p>Or, in your <code>requirements.txt</code> file, add:</p> <pre><code>docstring-format-checker\n</code></pre> <p>Then run:</p> <pre><code>python3 -m pip install --upgrade pip\npython3 -m pip install --requirement=requirements.txt\n</code></pre> </li> </ol>"},{"location":"usage/overview/#using-pipenv","title":"Using <code>pipenv</code>:","text":"<ol> <li> <p>Install using environment variables:</p> <p>In your <code>Pipfile</code> file, add:</p> <pre><code>[[source]]\nurl = \"https://pypi.org/simple\"\nverify_ssl = false\nname = \"pypi\"\n\n[packages]\ndocstring-format-checker = \"*\"\n</code></pre> <p>Then run:</p> <pre><code>python3 -m pip install pipenv\npython3 -m pipenv install --verbose --skip-lock --categories=root index=pypi docstring-format-checker\n</code></pre> </li> <li> <p>Or, in your <code>requirements.txt</code> file, add:</p> <pre><code>docstring-format-checker\n</code></pre> <p>Then run:</p> <pre><code>python3 -m pipenv install --verbose --skip-lock --requirements=requirements.txt\n</code></pre> </li> <li> <p>Or just run this:</p> <pre><code>python3 -m pipenv install --verbose --skip-lock docstring-format-checker\n</code></pre> </li> </ol>"},{"location":"usage/overview/#using-poetry","title":"Using <code>poetry</code>:","text":"<ol> <li> <p>In your <code>pyproject.toml</code> file, add:</p> <pre><code>[project]\ndependencies = [\n    \"docstring-format-checker==0.*\",\n]\n</code></pre> <p>Then run:</p> <pre><code>poetry sync\npoetry install\n</code></pre> </li> <li> <p>Or just run this:</p> <pre><code>poetry add \"docstring-format-checker==0.*\"\npoetry sync\npoetry install\n</code></pre> </li> </ol>"},{"location":"usage/overview/#using-uv","title":"Using <code>uv</code>:","text":"<ol> <li> <p>In your <code>pyproject.toml</code> file, add:</p> <pre><code>[project]\ndependencies = [\n    \"docstring-format-checker==0.*\",\n]\n</code></pre> </li> </ol> <p>Then run:</p> <pre><code>uv sync\n</code></pre> <ol> <li> <p>Or run this:</p> <pre><code>uv add \"docstring-format-checker==0.*\"\nuv sync\n</code></pre> </li> <li> <p>Or just run this:</p> <pre><code>uv pip install \"docstring-format-checker==0.*\"\n</code></pre> </li> </ol>"},{"location":"usage/overview/#usage-examples","title":"Usage Examples","text":""},{"location":"usage/overview/#basic-usage","title":"Basic Usage","text":"<pre><code># Check a single Python file\ndfc check src/my_module.py\n\n# Check entire directory recursively\ndfc check src/\n\n# Check with verbose output\ndfc check --verbose src/\n\n# Generate example configuration file\ndfc config-example &gt; pyproject.toml\n</code></pre>"},{"location":"usage/overview/#advanced-configuration","title":"Advanced Configuration","text":"<pre><code># Use custom config file location\ndfc check --config custom_config.toml src/\n\n# Check specific function patterns\ndfc check --include-pattern \"**/api/*.py\" src/\n\n# Exclude test files\ndfc check --exclude-pattern \"**/test_*.py\" src/\n</code></pre>"},{"location":"usage/overview/#integration-with-cicd","title":"Integration with CI/CD","text":"<pre><code># .github/workflows/docs.yml\nname: Documentation Quality\non: [push, pull_request]\n\njobs:\n  docstring-check:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: astral-sh/setup-uv@v3\n      - run: uv pip install docstring-format-checker\n      - run: dfc check src/\n</code></pre>"},{"location":"usage/overview/#example-output","title":"Example Output","text":"<pre><code>\ud83d\udccb Docstring Format Checker Results\n\n\u2705 src/utils/helpers.py\n\u274c src/models/user.py\n   \u2514\u2500\u2500 Function 'create_user' missing required section: 'params'\n   \u2514\u2500\u2500 Function 'delete_user' missing required section: 'returns'\n\n\u274c src/api/endpoints.py\n   \u2514\u2500\u2500 Method 'UserAPI.get_user' invalid section format: 'raises'\n\n\ud83d\udcca Summary: 1/3 files passed (33.3%)\n</code></pre>"},{"location":"usage/overview/#architecture","title":"Architecture","text":"<p>The tool follows a clean, modular architecture:</p> <ul> <li><code>core.py</code> - <code>DocstringChecker</code> class with AST parsing and validation logic</li> <li><code>config.py</code> - Configuration loading and <code>SectionConfig</code> management</li> <li><code>cli.py</code> - Typer-based CLI with dual entry points</li> <li><code>utils/exceptions.py</code> - Custom exception classes for structured error handling</li> </ul>"},{"location":"usage/overview/#contribution","title":"Contribution","text":"<p>Check the CONTRIBUTING.md file or Contributing page.</p>"},{"location":"usage/overview/#development","title":"Development","text":"<ol> <li> <p>Clone the repository:</p> <pre><code>git clone https://github.com/data-science-extensions/docstring-format-checker.git\ncd docstring-format-checker\n</code></pre> </li> <li> <p>Set up development environment:</p> <pre><code>uv sync --all-groups\n</code></pre> </li> <li> <p>Run tests:</p> <pre><code>uv run pytest --config-file=pyproject.toml --cov-report=term-missing\n</code></pre> </li> <li> <p>Run CLI locally:</p> <pre><code>uv run dfc check examples/example_code.py\n</code></pre> </li> </ol>"},{"location":"usage/overview/#build-and-test","title":"Build and Test","text":"<p>To ensure that the package is working as expected, please ensure that:</p> <ol> <li>You write your code as per PEP8 requirements.</li> <li>You write a UnitTest for each function/feature you include.</li> <li>The CodeCoverage is 100%.</li> <li>All UnitTests are passing.</li> <li>MyPy is passing 100%.</li> </ol>"},{"location":"usage/overview/#testing","title":"Testing","text":"<ul> <li> <p>Run them all together:</p> <pre><code>uv run pytest --config-file=pyproject.toml\n</code></pre> </li> <li> <p>Or run them individually:</p> <ul> <li> <p>Tests with Coverage: <pre><code>uv run pytest --config-file=pyproject.toml --cov-report=term-missing\n</code></pre></p> </li> <li> <p>Type Checking: <pre><code>uv run mypy src/\n</code></pre></p> </li> <li> <p>Code Formatting: <pre><code>uv run black --check src/\n</code></pre></p> </li> <li> <p>Linting: <pre><code>uv run ruff check src/\n</code></pre></p> </li> </ul> </li> </ul>"},{"location":"usage/overview/#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"}]}