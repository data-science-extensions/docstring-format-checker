{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"code/","title":"Modules","text":""},{"location":"code/#overview","title":"Overview","text":"<p>These are the modules used in the docstring-format-checker package:</p> Module Description Core The <code>core</code> module contains the main <code>DocstringChecker</code> class responsible for parsing Python files with AST, extracting docstrings from functions/classes/methods, and validating them against configured section requirements. Configuration The <code>config</code> module handles loading and validating configuration from TOML files. It supports automatic discovery of <code>pyproject.toml</code> files and defines section validation rules through the <code>SectionConfig</code> dataclass. CLI The <code>cli</code> module provides the command-line interface using Typer. It supports both <code>docstring-format-checker</code> and <code>dfc</code> entry points with subcommands for checking files/directories and generating configuration examples. Exceptions The <code>exceptions</code> module defines custom exception classes for structured error handling, including <code>DocstringError</code> for validation failures, <code>InvalidFileError</code> for non-Python files, and <code>DirectoryNotFoundError</code> for path validation."},{"location":"code/#key-features","title":"Key Features","text":"<ul> <li>AST-based parsing: Uses Python's AST module for robust code analysis</li> <li>Configurable validation: TOML-based configuration with 4 section types: <code>free_text</code>, <code>list_name</code>, <code>list_type</code>, <code>list_name_and_type</code></li> <li>Hierarchical config discovery: Automatically finds configuration in <code>pyproject.toml</code> files</li> <li>Rich output formatting: Uses Rich library for colored console output and error tables</li> <li>Dual CLI entry points: Available as both <code>docstring-format-checker</code> and <code>dfc</code></li> <li>Comprehensive error handling: Custom exceptions for different failure scenarios</li> </ul>"},{"location":"code/#section-types","title":"Section Types","text":"<p>The checker supports four types of docstring sections:</p> <ol> <li><code>free_text</code>: Admonition-style sections like summary, details, examples</li> <li><code>list_name</code>: Simple name lists</li> <li><code>list_type</code>: Type-only lists for raises, yields sections</li> <li><code>list_name_and_type</code>: Name and type lists for parameters, returns sections</li> </ol>"},{"location":"code/#testing","title":"Testing","text":"<p>This package maintains 100% test coverage with comprehensive testing against:</p> <ol> <li>Unit tests: Complete test coverage for all modules and functions</li> <li>Integration tests: CLI and end-to-end workflow testing</li> <li>Configuration tests: TOML parsing and validation testing</li> <li>Error handling tests: Exception scenarios and edge cases</li> <li>AST parsing tests: Python code analysis and docstring extraction</li> </ol> <p>Tests are run in matrix against:</p> <ol> <li>Python Versions:</li> <li><code>3.10</code></li> <li><code>3.11</code></li> <li><code>3.12</code></li> <li><code>3.13</code></li> <li>Operating Systems:</li> <li><code>ubuntu-latest</code></li> <li><code>windows-latest</code></li> <li><code>macos-latest</code></li> </ol>"},{"location":"code/#coverage","title":"Coverage","text":""},{"location":"code/cli/","title":"CLI","text":""},{"location":"code/cli/#docstring_format_checker.cli","title":"docstring_format_checker.cli","text":"<p>Summary</p> <p>Command-line interface for the docstring format checker.</p>"},{"location":"code/cli/#docstring_format_checker.cli.check_docstrings","title":"check_docstrings","text":"<pre><code>check_docstrings(\n    paths: list[str],\n    config: Optional[str] = None,\n    exclude: Optional[list[str]] = None,\n    quiet: bool = False,\n    output: str = \"list\",\n    check: bool = False,\n) -&gt; None\n</code></pre> <p>Summary</p> <p>Core logic for checking docstrings.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>list[str]</code> <p>The path(s) to the file(s) or directory(ies) to check.</p> required <code>config</code> <code>Optional[str]</code> <p>The path to the configuration file. Default: <code>None</code>.</p> <code>None</code> <code>exclude</code> <code>Optional[list[str]]</code> <p>List of glob patterns to exclude from checking. Default: <code>None</code>.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Whether to suppress output. Default: <code>False</code>.</p> <code>False</code> <code>output</code> <code>str</code> <p>Output format: 'table' or 'list'. Default: <code>'list'</code>.</p> <code>'list'</code> <code>check</code> <code>bool</code> <p>Whether to throw error if issues are found. Default: <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>Nothing is returned.</p> Source code in <code>src/docstring_format_checker/cli.py</code> <pre><code>def check_docstrings(\n    paths: list[str],\n    config: Optional[str] = None,\n    exclude: Optional[list[str]] = None,\n    quiet: bool = False,\n    output: str = \"list\",\n    check: bool = False,\n) -&gt; None:\n    \"\"\"\n    !!! note \"Summary\"\n        Core logic for checking docstrings.\n\n    Params:\n        paths (list[str]):\n            The path(s) to the file(s) or directory(ies) to check.\n        config (Optional[str]):\n            The path to the configuration file.\n            Default: `None`.\n        exclude (Optional[list[str]]):\n            List of glob patterns to exclude from checking.\n            Default: `None`.\n        quiet (bool):\n            Whether to suppress output.\n            Default: `False`.\n        output (str):\n            Output format: 'table' or 'list'.\n            Default: `'list'`.\n        check (bool):\n            Whether to throw error if issues are found.\n            Default: `False`.\n\n    Returns:\n        (None):\n            Nothing is returned.\n    \"\"\"\n\n    # Validate all target paths\n    path_objs: list[Path] = [Path(path) for path in paths]\n    target_paths: list[Path] = [p for p in path_objs if p.exists()]\n    invalid_paths: list[Path] = [p for p in path_objs if not p.exists()]\n\n    if len(invalid_paths) &gt; 0:\n        console.print(\n            _red(f\"[bold]Error: Paths do not exist:[/bold]\"),\n            NEW_LINE,\n            NEW_LINE.join([f\"- '{invalid_path}'\" for invalid_path in invalid_paths]),\n        )\n        raise Exit(1)\n\n    # Load configuration (use first path for config discovery if no config specified)\n    try:\n        if config:\n            config_path = Path(config)\n            if not config_path.exists():\n                console.print(_red(f\"Error: Configuration file does not exist: {config}\"))\n                raise Exit(1)\n            config_obj = load_config(config_path)\n        else:\n            # Try to find config file automatically using the first path\n            first_path: Path = target_paths[0]\n            found_config: Optional[Path] = find_config_file(first_path if first_path.is_dir() else first_path.parent)\n            if found_config:\n                config_obj: Config = load_config(found_config)\n            else:\n                config_obj: Config = load_config()\n\n    except Exception as e:\n        console.print(_red(f\"Error loading configuration: {e}\"))\n        raise Exit(1)\n\n    # Initialize checker\n    checker = DocstringChecker(config_obj)\n\n    # Check all paths and collect results\n    all_results: dict[str, list[DocstringError]] = {}\n\n    try:\n        for target_path in target_paths:\n            if target_path.is_file():\n                errors: list[DocstringError] = checker.check_file(target_path)\n                if errors:\n                    all_results[str(target_path)] = errors\n            else:\n                directory_results: dict[str, list[DocstringError]] = checker.check_directory(\n                    target_path, exclude_patterns=exclude\n                )\n                all_results.update(directory_results)\n\n    except Exception as e:\n        console.print(_red(f\"Error during checking: {e}\"))\n        raise Exit(1)\n\n    # Display results\n    exit_code: int = _display_results(all_results, quiet, output, check)\n\n    # Always exit with error code if issues are found, regardless of check flag\n    if exit_code != 0:\n        raise Exit(exit_code)\n</code></pre>"},{"location":"code/cli/#docstring_format_checker.cli.main","title":"main","text":"<pre><code>main(\n    ctx: Context,\n    paths: Optional[list[str]] = Argument(\n        None,\n        help=\"Path(s) to Python file(s) or directory(s) for DFC to check\",\n    ),\n    config: Optional[str] = Option(\n        None,\n        \"--config\",\n        \"-f\",\n        help=\"Path to configuration file (TOML format)\",\n    ),\n    exclude: Optional[list[str]] = Option(\n        None,\n        \"--exclude\",\n        \"-x\",\n        help=\"Glob patterns to exclude (can be used multiple times)\",\n    ),\n    output: str = Option(\n        \"list\",\n        \"--output\",\n        \"-o\",\n        help=\"Output format: 'table' or 'list'\",\n        show_default=True,\n    ),\n    check: bool = Option(\n        False,\n        \"--check\",\n        \"-c\",\n        help=\"Throw error (exit 1) if any issues are found\",\n    ),\n    quiet: bool = Option(\n        False,\n        \"--quiet\",\n        \"-q\",\n        help=\"Only output pass/fail confirmation, suppress errors unless failing\",\n    ),\n    example: Optional[str] = Option(\n        None,\n        \"--example\",\n        \"-e\",\n        callback=_example_callback,\n        is_eager=True,\n        help=\"Show examples: 'config' for configuration example, 'usage' for usage examples\",\n    ),\n    version: Optional[bool] = Option(\n        None,\n        \"--version\",\n        \"-v\",\n        callback=_version_callback,\n        is_eager=True,\n        help=\"Show version and exit\",\n    ),\n    help_flag: Optional[bool] = Option(\n        None,\n        \"--help\",\n        \"-h\",\n        callback=_help_callback_main,\n        is_eager=True,\n        help=\"Show this message and exit\",\n    ),\n) -&gt; None\n</code></pre> <p>Summary</p> <p>Check Python docstring formatting and completeness.</p> Details <p>This tool analyzes Python files and validates that functions, methods, and classes have properly formatted docstrings according to the configured sections.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The context object for the command.</p> required <code>paths</code> <code>Optional[list[str]]</code> <p>Path(s) to Python file(s) or directory(ies) to check.</p> <code>Argument(None, help='Path(s) to Python file(s) or directory(s) for DFC to check')</code> <code>config</code> <code>Optional[str]</code> <p>Path to configuration file (TOML format).</p> <code>Option(None, '--config', '-f', help='Path to configuration file (TOML format)')</code> <code>exclude</code> <code>Optional[list[str]]</code> <p>Glob patterns to exclude.</p> <code>Option(None, '--exclude', '-x', help='Glob patterns to exclude (can be used multiple times)')</code> <code>output</code> <code>str</code> <p>Output format: 'table' or 'list'.</p> <code>Option('list', '--output', '-o', help=\"Output format: 'table' or 'list'\", show_default=True)</code> <code>check</code> <code>bool</code> <p>Throw error if any issues are found.</p> <code>Option(False, '--check', '-c', help='Throw error (exit 1) if any issues are found')</code> <code>quiet</code> <code>bool</code> <p>Only output pass/fail confirmation.</p> <code>Option(False, '--quiet', '-q', help='Only output pass/fail confirmation, suppress errors unless failing')</code> <code>example</code> <code>Optional[str]</code> <p>Show examples: 'config' or 'usage'.</p> <code>Option(None, '--example', '-e', callback=_example_callback, is_eager=True, help=\"Show examples: 'config' for configuration example, 'usage' for usage examples\")</code> <code>version</code> <code>Optional[bool]</code> <p>Show version and exit.</p> <code>Option(None, '--version', '-v', callback=_version_callback, is_eager=True, help='Show version and exit')</code> <code>help_flag</code> <code>Optional[bool]</code> <p>Show help message and exit.</p> <code>Option(None, '--help', '-h', callback=_help_callback_main, is_eager=True, help='Show this message and exit')</code> <p>Returns:</p> Type Description <code>None</code> <p>Nothing is returned.</p> Source code in <code>src/docstring_format_checker/cli.py</code> <pre><code>@app.callback(invoke_without_command=True)\ndef main(\n    ctx: Context,\n    paths: Optional[list[str]] = Argument(None, help=\"Path(s) to Python file(s) or directory(s) for DFC to check\"),\n    config: Optional[str] = Option(None, \"--config\", \"-f\", help=\"Path to configuration file (TOML format)\"),\n    exclude: Optional[list[str]] = Option(\n        None,\n        \"--exclude\",\n        \"-x\",\n        help=\"Glob patterns to exclude (can be used multiple times)\",\n    ),\n    output: str = Option(\n        \"list\",\n        \"--output\",\n        \"-o\",\n        help=\"Output format: 'table' or 'list'\",\n        show_default=True,\n    ),\n    check: bool = Option(\n        False,\n        \"--check\",\n        \"-c\",\n        help=\"Throw error (exit 1) if any issues are found\",\n    ),\n    quiet: bool = Option(\n        False,\n        \"--quiet\",\n        \"-q\",\n        help=\"Only output pass/fail confirmation, suppress errors unless failing\",\n    ),\n    example: Optional[str] = Option(\n        None,\n        \"--example\",\n        \"-e\",\n        callback=_example_callback,\n        is_eager=True,\n        help=\"Show examples: 'config' for configuration example, 'usage' for usage examples\",\n    ),\n    version: Optional[bool] = Option(\n        None,\n        \"--version\",\n        \"-v\",\n        callback=_version_callback,\n        is_eager=True,\n        help=\"Show version and exit\",\n    ),\n    help_flag: Optional[bool] = Option(\n        None,\n        \"--help\",\n        \"-h\",\n        callback=_help_callback_main,\n        is_eager=True,\n        help=\"Show this message and exit\",\n    ),\n) -&gt; None:\n    \"\"\"\n    !!! note \"Summary\"\n        Check Python docstring formatting and completeness.\n\n    ???+ abstract \"Details\"\n        This tool analyzes Python files and validates that functions, methods, and classes have properly formatted docstrings according to the configured sections.\n\n    Params:\n        ctx (Context):\n            The context object for the command.\n        paths (Optional[list[str]]):\n            Path(s) to Python file(s) or directory(ies) to check.\n        config (Optional[str]):\n            Path to configuration file (TOML format).\n        exclude (Optional[list[str]]):\n            Glob patterns to exclude.\n        output (str):\n            Output format: 'table' or 'list'.\n        check (bool):\n            Throw error if any issues are found.\n        quiet (bool):\n            Only output pass/fail confirmation.\n        example (Optional[str]):\n            Show examples: 'config' or 'usage'.\n        version (Optional[bool]):\n            Show version and exit.\n        help_flag (Optional[bool]):\n            Show help message and exit.\n\n    Returns:\n        (None):\n            Nothing is returned.\n    \"\"\"\n\n    # If no paths are provided, show help\n    if not paths:\n        echo(ctx.get_help())\n        raise Exit(0)\n\n    # Validate output format\n    if output not in [\"table\", \"list\"]:\n        console.print(_red(f\"Error: Invalid output format '{output}'. Use 'table' or 'list'.\"))\n        raise Exit(1)\n\n    check_docstrings(\n        paths=paths,\n        config=config,\n        exclude=exclude,\n        quiet=quiet,\n        output=output,\n        check=check,\n    )\n</code></pre>"},{"location":"code/cli/#docstring_format_checker.cli.entry_point","title":"entry_point","text":"<pre><code>entry_point() -&gt; None\n</code></pre> <p>Summary</p> <p>Entry point for the CLI scripts defined in pyproject.toml.</p> Source code in <code>src/docstring_format_checker/cli.py</code> <pre><code>def entry_point() -&gt; None:\n    \"\"\"\n    !!! note \"Summary\"\n        Entry point for the CLI scripts defined in pyproject.toml.\n    \"\"\"\n    app()\n</code></pre>"},{"location":"code/config/","title":"Config","text":""},{"location":"code/config/#docstring_format_checker.config","title":"docstring_format_checker.config","text":"<p>Summary</p> <p>Configuration handling for the docstring format checker.</p>"},{"location":"code/config/#docstring_format_checker.config.GlobalConfig","title":"GlobalConfig  <code>dataclass</code>","text":"<p>Summary</p> <p>Global configuration for docstring checking behavior.</p> Source code in <code>src/docstring_format_checker/config.py</code> <pre><code>@dataclass\nclass GlobalConfig:\n    \"\"\"\n    !!! note \"Summary\"\n        Global configuration for docstring checking behavior.\n    \"\"\"\n\n    allow_undefined_sections: bool = False\n    require_docstrings: bool = True\n    check_private: bool = False\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.GlobalConfig.__init__","title":"__init__","text":"<pre><code>__init__(\n    allow_undefined_sections: bool = False,\n    require_docstrings: bool = True,\n    check_private: bool = False,\n) -&gt; None\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.GlobalConfig.allow_undefined_sections","title":"allow_undefined_sections  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>allow_undefined_sections: bool = False\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.GlobalConfig.require_docstrings","title":"require_docstrings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>require_docstrings: bool = True\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.GlobalConfig.check_private","title":"check_private  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>check_private: bool = False\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.SectionConfig","title":"SectionConfig  <code>dataclass</code>","text":"<p>Summary</p> <p>Configuration for a docstring section.</p> Source code in <code>src/docstring_format_checker/config.py</code> <pre><code>@dataclass\nclass SectionConfig:\n    \"\"\"\n    !!! note \"Summary\"\n        Configuration for a docstring section.\n    \"\"\"\n\n    order: int\n    name: str\n    type: Literal[\"free_text\", \"list_name\", \"list_type\", \"list_name_and_type\"]\n    admonition: Union[bool, str] = False\n    prefix: str = \"\"  # Support any prefix string\n    required: bool = False\n    message: str = \"\"  # Optional message for validation errors\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"\n        !!! note \"Summary\"\n            Validate configuration after initialization.\n        \"\"\"\n        self._validate_types()\n        self._validate_admonition_prefix_combination()\n\n    def _validate_types(self) -&gt; None:\n        \"\"\"\n        !!! note \"Summary\"\n            Validate the 'type' field.\n        \"\"\"\n        if self.type not in VALID_TYPES:\n            raise InvalidTypeValuesError(f\"Invalid section type: {self.type}. Valid types: {VALID_TYPES}\")\n\n    def _validate_admonition_prefix_combination(self) -&gt; None:\n        \"\"\"\n        !!! note \"Summary\"\n            Validate admonition and prefix combination rules.\n        \"\"\"\n\n        if isinstance(self.admonition, bool):\n            # Rule: admonition cannot be True (only False or string)\n            if self.admonition is True:\n                raise ValueError(f\"Section '{self.name}': admonition cannot be True, must be False or a string\")\n\n            # Rule: if admonition is False, prefix cannot be provided\n            if self.admonition is False and self.prefix:\n                raise ValueError(f\"Section '{self.name}': when admonition=False, prefix cannot be provided\")\n\n        elif isinstance(self.admonition, str):\n            # Rule: if admonition is a string, prefix must be provided\n            if not self.prefix:\n                raise ValueError(f\"Section '{self.name}': when admonition is a string, prefix must be provided\")\n\n        else:\n            raise ValueError(\n                f\"Section '{self.name}': admonition must be a boolean or string, got {type(self.admonition)}\"\n            )\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.SectionConfig.__init__","title":"__init__","text":"<pre><code>__init__(\n    order: int,\n    name: str,\n    type: Literal[\n        \"free_text\",\n        \"list_name\",\n        \"list_type\",\n        \"list_name_and_type\",\n    ],\n    admonition: Union[bool, str] = False,\n    prefix: str = \"\",\n    required: bool = False,\n    message: str = \"\",\n) -&gt; None\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.SectionConfig.order","title":"order  <code>instance-attribute</code>","text":"<pre><code>order: int\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.SectionConfig.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.SectionConfig.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal[\n    \"free_text\",\n    \"list_name\",\n    \"list_type\",\n    \"list_name_and_type\",\n]\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.SectionConfig.admonition","title":"admonition  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>admonition: Union[bool, str] = False\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.SectionConfig.prefix","title":"prefix  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prefix: str = ''\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.SectionConfig.required","title":"required  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>required: bool = False\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.SectionConfig.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message: str = ''\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.SectionConfig.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Summary</p> <p>Validate configuration after initialization.</p> Source code in <code>src/docstring_format_checker/config.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"\n    !!! note \"Summary\"\n        Validate configuration after initialization.\n    \"\"\"\n    self._validate_types()\n    self._validate_admonition_prefix_combination()\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.Config","title":"Config  <code>dataclass</code>","text":"<p>Summary</p> <p>Complete configuration containing global settings and section definitions.</p> Source code in <code>src/docstring_format_checker/config.py</code> <pre><code>@dataclass\nclass Config:\n    \"\"\"\n    !!! note \"Summary\"\n        Complete configuration containing global settings and section definitions.\n    \"\"\"\n\n    global_config: GlobalConfig\n    sections: list[SectionConfig]\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.Config.__init__","title":"__init__","text":"<pre><code>__init__(\n    global_config: GlobalConfig,\n    sections: list[SectionConfig],\n) -&gt; None\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.Config.global_config","title":"global_config  <code>instance-attribute</code>","text":"<pre><code>global_config: GlobalConfig\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.Config.sections","title":"sections  <code>instance-attribute</code>","text":"<pre><code>sections: list[SectionConfig]\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.DEFAULT_CONFIG","title":"DEFAULT_CONFIG  <code>module-attribute</code>","text":"<pre><code>DEFAULT_CONFIG: Config = Config(\n    global_config=GlobalConfig(), sections=DEFAULT_SECTIONS\n)\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.load_config","title":"load_config","text":"<pre><code>load_config(\n    config_path: Optional[Union[str, Path]] = None,\n) -&gt; Config\n</code></pre> <p>Summary</p> <p>Load configuration from a TOML file or return default configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Optional[Union[str, Path]]</code> <p>Path to the TOML configuration file. If <code>None</code>, looks for <code>pyproject.toml</code> in current directory. Default: <code>None</code>.</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the specified config file doesn't exist.</p> <code>InvalidConfigError</code> <p>If the configuration is invalid.</p> <p>Returns:</p> Type Description <code>Config</code> <p>Configuration object containing global settings and section definitions.</p> Source code in <code>src/docstring_format_checker/config.py</code> <pre><code>def load_config(config_path: Optional[Union[str, Path]] = None) -&gt; Config:\n    \"\"\"\n    !!! note \"Summary\"\n        Load configuration from a TOML file or return default configuration.\n\n    Params:\n        config_path (Optional[Union[str, Path]]):\n            Path to the TOML configuration file.\n            If `None`, looks for `pyproject.toml` in current directory.\n            Default: `None`.\n\n    Raises:\n        (FileNotFoundError):\n            If the specified config file doesn't exist.\n        (InvalidConfigError):\n            If the configuration is invalid.\n\n    Returns:\n        (Config):\n            Configuration object containing global settings and section definitions.\n    \"\"\"\n\n    if config_path is None:\n        # Look for pyproject.toml in current directory\n        pyproject_path: Path = Path.cwd().joinpath(\"pyproject.toml\")\n        if pyproject_path.exists():\n            config_path = pyproject_path\n        else:\n            return DEFAULT_CONFIG\n\n    # Convert to Path object and check existence\n    config_path = Path(config_path)\n    if not config_path.exists():\n        raise FileNotFoundError(f\"Configuration file not found: {config_path}\")\n\n    try:\n        with open(config_path, \"rb\") as f:\n            config_data: dict[str, Any] = tomllib.load(f)\n    except Exception as e:\n        raise InvalidConfigError(f\"Failed to parse TOML file {config_path}: {e}\") from e\n\n    # Try to find configuration under [tool.dfc] or [tool.docstring-format-checker]\n    tool_config = None\n    if \"tool\" in config_data:\n        if \"dfc\" in config_data[\"tool\"]:\n            tool_config = config_data[\"tool\"][\"dfc\"]\n        elif \"docstring-format-checker\" in config_data[\"tool\"]:\n            tool_config = config_data[\"tool\"][\"docstring-format-checker\"]\n\n    if tool_config is None:\n        return DEFAULT_CONFIG\n\n    # Parse global configuration flags\n    global_config = GlobalConfig(\n        allow_undefined_sections=tool_config.get(\"allow_undefined_sections\", False),\n        require_docstrings=tool_config.get(\"require_docstrings\", True),\n        check_private=tool_config.get(\"check_private\", False),\n    )\n\n    # Parse sections configuration\n    sections_config: list[SectionConfig] = []\n    if \"sections\" in tool_config:\n        sections_data = tool_config[\"sections\"]\n        for section_data in sections_data:\n            try:\n                # Get admonition value with proper default handling\n                admonition_value: Union[str, bool] = section_data.get(\"admonition\")\n                if admonition_value is None:\n                    admonition_value = False  # Use SectionConfig default\n\n                section = SectionConfig(\n                    order=section_data.get(\"order\", 0),\n                    name=section_data.get(\"name\", \"\"),\n                    type=section_data.get(\"type\", \"\"),\n                    admonition=admonition_value,\n                    prefix=section_data.get(\"prefix\", \"\"),\n                    required=section_data.get(\"required\", False),\n                )\n                sections_config.append(section)\n            except (KeyError, TypeError, ValueError, InvalidTypeValuesError) as e:\n                raise InvalidConfigError(f\"Invalid section configuration: {section_data}. Error: {e}\") from e\n\n    # Use default sections if none provided, otherwise validate and sort\n    if not sections_config:\n        sections_config = DEFAULT_SECTIONS\n    else:\n        # Validate no duplicate order values\n        _validate_config_order(config_sections=sections_config)\n\n        # Sort by order\n        sections_config.sort(key=lambda x: x.order)\n\n    return Config(global_config=global_config, sections=sections_config)\n</code></pre>"},{"location":"code/config/#docstring_format_checker.config.find_config_file","title":"find_config_file","text":"<pre><code>find_config_file(\n    start_path: Optional[Path] = None,\n) -&gt; Optional[Path]\n</code></pre> <p>Summary</p> <p>Find configuration file by searching up the directory tree.</p> <p>Parameters:</p> Name Type Description Default <code>start_path</code> <code>Optional[Path]</code> <p>Directory to start searching from. If <code>None</code>, resolves to current directory. Default: <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Path]</code> <p>Path to the configuration file if found, None otherwise.</p> Source code in <code>src/docstring_format_checker/config.py</code> <pre><code>def find_config_file(start_path: Optional[Path] = None) -&gt; Optional[Path]:\n    \"\"\"\n    !!! note \"Summary\"\n        Find configuration file by searching up the directory tree.\n\n    Params:\n        start_path (Optional[Path]):\n            Directory to start searching from.\n            If `None`, resolves to current directory.\n            Default: `None`.\n\n    Returns:\n        (Optional[Path]):\n            Path to the configuration file if found, None otherwise.\n    \"\"\"\n    if start_path is None:\n        start_path = Path.cwd()\n\n    current_path: Path = start_path.resolve()\n\n    while current_path != current_path.parent:\n        pyproject_path: Path = current_path.joinpath(\"pyproject.toml\")\n        if pyproject_path.exists():\n            # Check if it contains dfc configuration\n            try:\n                with open(pyproject_path, \"rb\") as f:\n                    config_data: dict[str, Any] = tomllib.load(f)\n                    if \"tool\" in config_data and (\n                        \"dfc\" in config_data[\"tool\"] or \"docstring-format-checker\" in config_data[\"tool\"]\n                    ):\n                        return pyproject_path\n            except Exception:\n                pass\n\n        current_path = current_path.parent\n\n    return None\n</code></pre>"},{"location":"code/core/","title":"Core","text":""},{"location":"code/core/#docstring_format_checker.core","title":"docstring_format_checker.core","text":"<p>Summary</p> <p>Core docstring checking functionality.</p>"},{"location":"code/core/#docstring_format_checker.core.SectionConfig","title":"SectionConfig  <code>dataclass</code>","text":"<p>Summary</p> <p>Configuration for a docstring section.</p> Source code in <code>src/docstring_format_checker/config.py</code> <pre><code>@dataclass\nclass SectionConfig:\n    \"\"\"\n    !!! note \"Summary\"\n        Configuration for a docstring section.\n    \"\"\"\n\n    order: int\n    name: str\n    type: Literal[\"free_text\", \"list_name\", \"list_type\", \"list_name_and_type\"]\n    admonition: Union[bool, str] = False\n    prefix: str = \"\"  # Support any prefix string\n    required: bool = False\n    message: str = \"\"  # Optional message for validation errors\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"\n        !!! note \"Summary\"\n            Validate configuration after initialization.\n        \"\"\"\n        self._validate_types()\n        self._validate_admonition_prefix_combination()\n\n    def _validate_types(self) -&gt; None:\n        \"\"\"\n        !!! note \"Summary\"\n            Validate the 'type' field.\n        \"\"\"\n        if self.type not in VALID_TYPES:\n            raise InvalidTypeValuesError(f\"Invalid section type: {self.type}. Valid types: {VALID_TYPES}\")\n\n    def _validate_admonition_prefix_combination(self) -&gt; None:\n        \"\"\"\n        !!! note \"Summary\"\n            Validate admonition and prefix combination rules.\n        \"\"\"\n\n        if isinstance(self.admonition, bool):\n            # Rule: admonition cannot be True (only False or string)\n            if self.admonition is True:\n                raise ValueError(f\"Section '{self.name}': admonition cannot be True, must be False or a string\")\n\n            # Rule: if admonition is False, prefix cannot be provided\n            if self.admonition is False and self.prefix:\n                raise ValueError(f\"Section '{self.name}': when admonition=False, prefix cannot be provided\")\n\n        elif isinstance(self.admonition, str):\n            # Rule: if admonition is a string, prefix must be provided\n            if not self.prefix:\n                raise ValueError(f\"Section '{self.name}': when admonition is a string, prefix must be provided\")\n\n        else:\n            raise ValueError(\n                f\"Section '{self.name}': admonition must be a boolean or string, got {type(self.admonition)}\"\n            )\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.SectionConfig.order","title":"order  <code>instance-attribute</code>","text":"<pre><code>order: int\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.SectionConfig.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.SectionConfig.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal[\n    \"free_text\",\n    \"list_name\",\n    \"list_type\",\n    \"list_name_and_type\",\n]\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.SectionConfig.admonition","title":"admonition  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>admonition: Union[bool, str] = False\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.SectionConfig.prefix","title":"prefix  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prefix: str = ''\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.SectionConfig.required","title":"required  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>required: bool = False\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.SectionConfig.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message: str = ''\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.SectionConfig.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Summary</p> <p>Validate configuration after initialization.</p> Source code in <code>src/docstring_format_checker/config.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"\n    !!! note \"Summary\"\n        Validate configuration after initialization.\n    \"\"\"\n    self._validate_types()\n    self._validate_admonition_prefix_combination()\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.SectionConfig.__init__","title":"__init__","text":"<pre><code>__init__(\n    order: int,\n    name: str,\n    type: Literal[\n        \"free_text\",\n        \"list_name\",\n        \"list_type\",\n        \"list_name_and_type\",\n    ],\n    admonition: Union[bool, str] = False,\n    prefix: str = \"\",\n    required: bool = False,\n    message: str = \"\",\n) -&gt; None\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringError","title":"DocstringError","text":"<p>               Bases: <code>Exception</code></p> <p>Summary</p> <p>Exception raised when a docstring validation error occurs.</p> Source code in <code>src/docstring_format_checker/utils/exceptions.py</code> <pre><code>class DocstringError(Exception):\n    \"\"\"\n    !!! note \"Summary\"\n        Exception raised when a docstring validation error occurs.\n    \"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        file_path: str,\n        line_number: int,\n        item_name: str,\n        item_type: str,\n    ) -&gt; None:\n        \"\"\"\n        !!! note \"Summary\"\n            Initialize a DocstringError.\n        \"\"\"\n        self.message = message\n        self.file_path = file_path\n        self.line_number = line_number\n        self.item_name = item_name\n        self.item_type = item_type\n        super().__init__(f\"Line {line_number}, {item_type} '{item_name}': {message}\")\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringError.__init__","title":"__init__","text":"<pre><code>__init__(\n    message: str,\n    file_path: str,\n    line_number: int,\n    item_name: str,\n    item_type: str,\n) -&gt; None\n</code></pre> <p>Summary</p> <p>Initialize a DocstringError.</p> Source code in <code>src/docstring_format_checker/utils/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    file_path: str,\n    line_number: int,\n    item_name: str,\n    item_type: str,\n) -&gt; None:\n    \"\"\"\n    !!! note \"Summary\"\n        Initialize a DocstringError.\n    \"\"\"\n    self.message = message\n    self.file_path = file_path\n    self.line_number = line_number\n    self.item_name = item_name\n    self.item_type = item_type\n    super().__init__(f\"Line {line_number}, {item_type} '{item_name}': {message}\")\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringError.file_path","title":"file_path  <code>instance-attribute</code>","text":"<pre><code>file_path = file_path\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringError.line_number","title":"line_number  <code>instance-attribute</code>","text":"<pre><code>line_number = line_number\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringError.item_name","title":"item_name  <code>instance-attribute</code>","text":"<pre><code>item_name = item_name\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringError.item_type","title":"item_type  <code>instance-attribute</code>","text":"<pre><code>item_type = item_type\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.FunctionAndClassDetails","title":"FunctionAndClassDetails","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Summary</p> <p>Details about a function or class found in the AST.</p> Source code in <code>src/docstring_format_checker/core.py</code> <pre><code>class FunctionAndClassDetails(NamedTuple):\n    \"\"\"\n    !!! note \"Summary\"\n        Details about a function or class found in the AST.\n    \"\"\"\n\n    item_type: Literal[\"function\", \"class\", \"method\"]\n    name: str\n    node: Union[ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef]\n    lineno: int\n    parent_class: Optional[str] = None\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.FunctionAndClassDetails.item_type","title":"item_type  <code>instance-attribute</code>","text":"<pre><code>item_type: Literal['function', 'class', 'method']\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.FunctionAndClassDetails.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.FunctionAndClassDetails.node","title":"node  <code>instance-attribute</code>","text":"<pre><code>node: Union[FunctionDef, AsyncFunctionDef, ClassDef]\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.FunctionAndClassDetails.lineno","title":"lineno  <code>instance-attribute</code>","text":"<pre><code>lineno: int\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.FunctionAndClassDetails.parent_class","title":"parent_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_class: Optional[str] = None\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringChecker","title":"DocstringChecker","text":"<p>Summary</p> <p>Main class for checking docstring format and completeness.</p> Source code in <code>src/docstring_format_checker/core.py</code> <pre><code>class DocstringChecker:\n    \"\"\"\n    !!! note \"Summary\"\n        Main class for checking docstring format and completeness.\n    \"\"\"\n\n    def __init__(self, config: Config) -&gt; None:\n        \"\"\"\n        !!! note \"Summary\"\n            Initialize the docstring checker.\n\n        Params:\n            config (Config):\n                Configuration object containing global settings and section definitions.\n        \"\"\"\n        self.config = config\n        self.sections_config: list[SectionConfig] = config.sections\n        self.required_sections: list[SectionConfig] = [s for s in config.sections if s.required]\n        self.optional_sections: list[SectionConfig] = [s for s in config.sections if not s.required]\n\n    def check_file(self, file_path: Union[str, Path]) -&gt; list[DocstringError]:\n        \"\"\"\n        !!! note \"Summary\"\n            Check docstrings in a Python file.\n\n        Params:\n            file_path (Union[str, Path]):\n                Path to the Python file to check.\n\n        Raises:\n            (FileNotFoundError):\n                If the file doesn't exist.\n            (InvalidFileError):\n                If the file is not a Python file.\n            (UnicodeError):\n                If the file can't be decoded.\n            (SyntaxError):\n                If the file contains invalid Python syntax.\n\n        Returns:\n            (list[DocstringError]):\n                List of DocstringError objects for any validation failures.\n        \"\"\"\n\n        file_path = Path(file_path)\n        if not file_path.exists():\n            raise FileNotFoundError(f\"File not found: {file_path}\")\n\n        if file_path.suffix != \".py\":\n            raise InvalidFileError(f\"File must be a Python file (.py): {file_path}\")\n\n        # Read and parse the file\n        try:\n            with open(file_path, encoding=\"utf-8\") as f:\n                content: str = f.read()\n        except UnicodeDecodeError as e:\n            raise UnicodeError(f\"Cannot decode file {file_path}: {e}\") from e\n\n        try:\n            tree: ast.Module = ast.parse(content)\n        except SyntaxError as e:\n            raise SyntaxError(f\"Invalid Python syntax in {file_path}: {e}\") from e\n\n        # Extract all functions and classes\n        items: list[FunctionAndClassDetails] = self._extract_items(tree)\n\n        # Check each item\n        errors: list[DocstringError] = []\n        for item in items:\n            try:\n                self._check_single_docstring(item, str(file_path))\n            except DocstringError as e:\n                errors.append(e)\n\n        return errors\n\n    def check_directory(\n        self,\n        directory_path: Union[str, Path],\n        exclude_patterns: Optional[list[str]] = None,\n    ) -&gt; dict[str, list[DocstringError]]:\n        \"\"\"\n        !!! note \"Summary\"\n            Check docstrings in all Python files in a directory recursively.\n\n        Params:\n            directory_path (Union[str, Path]):\n                Path to the directory to check.\n            exclude_patterns (Optional[list[str]]):\n                List of glob patterns to exclude.\n\n        Raises:\n            (FileNotFoundError):\n                If the directory doesn't exist.\n            (DirectoryNotFoundError):\n                If the path is not a directory.\n\n        Returns:\n            (dict[str, list[DocstringError]]):\n                Dictionary mapping file paths to lists of DocstringError objects.\n        \"\"\"\n\n        directory_path = Path(directory_path)\n        if not directory_path.exists():\n            raise FileNotFoundError(f\"Directory not found: {directory_path}\")\n\n        if not directory_path.is_dir():\n            raise DirectoryNotFoundError(f\"Path is not a directory: {directory_path}\")\n\n        python_files: list[Path] = list(directory_path.glob(\"**/*.py\"))\n\n        # Filter out excluded patterns\n        if exclude_patterns:\n            filtered_files: list[Path] = []\n            for file_path in python_files:\n                relative_path: Path = file_path.relative_to(directory_path)\n                should_exclude = False\n                for pattern in exclude_patterns:\n                    if fnmatch.fnmatch(str(relative_path), pattern):\n                        should_exclude = True\n                        break\n                if not should_exclude:\n                    filtered_files.append(file_path)\n            python_files = filtered_files\n\n        # Check each file\n        results: dict[str, list[DocstringError]] = {}\n        for file_path in python_files:\n            try:\n                errors: list[DocstringError] = self.check_file(file_path)\n                if errors:  # Only include files with errors\n                    results[str(file_path)] = errors\n            except (FileNotFoundError, ValueError, SyntaxError) as e:\n                # Create a special error for file-level issues\n                error = DocstringError(\n                    message=str(e),\n                    file_path=str(file_path),\n                    line_number=0,\n                    item_name=\"\",\n                    item_type=\"file\",\n                )\n                results[str(file_path)] = [error]\n\n        return results\n\n    def _is_overload_function(self, node: Union[ast.FunctionDef, ast.AsyncFunctionDef]) -&gt; bool:\n        \"\"\"\n        !!! note \"Summary\"\n            Check if a function definition is decorated with @overload.\n\n        Params:\n            node (Union[ast.FunctionDef, ast.AsyncFunctionDef]):\n                The function node to check for @overload decorator.\n\n        Returns:\n            (bool):\n                True if the function has @overload decorator, False otherwise.\n        \"\"\"\n\n        for decorator in node.decorator_list:\n            # Handle direct name reference: @overload\n            if isinstance(decorator, ast.Name) and decorator.id == \"overload\":\n                return True\n            # Handle attribute reference: @typing.overload\n            elif isinstance(decorator, ast.Attribute) and decorator.attr == \"overload\":\n                return True\n        return False\n\n    def _extract_items(self, tree: ast.AST) -&gt; list[FunctionAndClassDetails]:\n        \"\"\"\n        !!! note \"Summary\"\n            Extract all functions and classes from the AST.\n\n        Params:\n            tree (ast.AST):\n                The Abstract Syntax Tree (AST) to extract items from.\n\n        Returns:\n            (list[FunctionAndClassDetails]):\n                A list of extracted function and class details.\n        \"\"\"\n\n        items: list[FunctionAndClassDetails] = []\n\n        class ItemVisitor(ast.NodeVisitor):\n            \"\"\"\n            !!! note \"Summary\"\n                AST visitor to extract function and class definitions\n            \"\"\"\n\n            def __init__(self, checker: DocstringChecker) -&gt; None:\n                \"\"\"\n                !!! note \"Summary\"\n                    Initialize the AST visitor.\n                \"\"\"\n                self.class_stack: list[str] = []\n                self.checker: DocstringChecker = checker\n\n            def visit_ClassDef(self, node: ast.ClassDef) -&gt; None:\n                \"\"\"\n                !!! note \"Summary\"\n                    Visit class definition node.\n                \"\"\"\n                # Skip private classes unless check_private is enabled\n                should_check: bool = self.checker.config.global_config.check_private or not node.name.startswith(\"_\")\n                if should_check:\n                    items.append(\n                        FunctionAndClassDetails(\n                            item_type=\"class\",\n                            name=node.name,\n                            node=node,\n                            lineno=node.lineno,\n                            parent_class=None,\n                        )\n                    )\n\n                # Visit methods in this class\n                self.class_stack.append(node.name)\n                self.generic_visit(node)\n                self.class_stack.pop()\n\n            def visit_FunctionDef(self, node: ast.FunctionDef) -&gt; None:\n                \"\"\"\n                !!! note \"Summary\"\n                    Visit function definition node.\n                \"\"\"\n                self._visit_function(node)\n\n            def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -&gt; None:\n                \"\"\"\n                !!! note \"Summary\"\n                    Visit async function definition node.\n                \"\"\"\n                self._visit_function(node)\n\n            def _visit_function(self, node: Union[ast.FunctionDef, ast.AsyncFunctionDef]) -&gt; None:\n                \"\"\"\n                !!! note \"Summary\"\n                    Visit function definition node (sync or async).\n                \"\"\"\n\n                # Skip private functions unless check_private is enabled\n                should_check: bool = self.checker.config.global_config.check_private or not node.name.startswith(\"_\")\n                if should_check:\n                    # Skip @overload functions - they don't need docstrings\n                    if not self.checker._is_overload_function(node):\n                        item_type: Literal[\"function\", \"method\"] = \"method\" if self.class_stack else \"function\"\n                        parent_class: Optional[str] = self.class_stack[-1] if self.class_stack else None\n\n                        items.append(\n                            FunctionAndClassDetails(\n                                item_type=item_type,\n                                name=node.name,\n                                node=node,\n                                lineno=node.lineno,\n                                parent_class=parent_class,\n                            )\n                        )\n\n                self.generic_visit(node)\n\n        visitor = ItemVisitor(self)\n        visitor.visit(tree)\n\n        return items\n\n    def _check_single_docstring(self, item: FunctionAndClassDetails, file_path: str) -&gt; None:\n        \"\"\"\n        !!! note \"Summary\"\n            Check a single function or class docstring.\n\n        Params:\n            item (FunctionAndClassDetails):\n                The function or class to check.\n            file_path (str):\n                The path to the file containing the item.\n\n        Returns:\n            (None):\n                Nothing is returned.\n        \"\"\"\n\n        docstring: Optional[str] = ast.get_docstring(item.node)\n\n        # Check if any required sections apply to this item type\n        requires_docstring = False\n        applicable_sections: list[SectionConfig] = []\n\n        for section in self.sections_config:\n            if section.required:\n                # Check if this section applies to this item type\n                if section.type == \"free_text\":\n                    # Free text sections apply only to functions and methods, not classes\n                    if isinstance(item.node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n                        requires_docstring = True\n                        applicable_sections.append(section)\n                elif section.type == \"list_name_and_type\":\n                    if section.name.lower() == \"params\" and isinstance(\n                        item.node, (ast.FunctionDef, ast.AsyncFunctionDef)\n                    ):\n                        # Params only apply to functions/methods\n                        requires_docstring = True\n                        applicable_sections.append(section)\n                    elif section.name.lower() in [\"returns\", \"return\"] and isinstance(\n                        item.node, (ast.FunctionDef, ast.AsyncFunctionDef)\n                    ):\n                        # Returns only apply to functions/methods\n                        requires_docstring = True\n                        applicable_sections.append(section)\n                elif section.type in [\"list_type\", \"list_name\"]:\n                    # These sections apply to functions/methods that might have them\n                    if isinstance(item.node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n                        requires_docstring = True\n                        applicable_sections.append(section)\n\n        if not docstring:\n            # Only require docstrings if the global flag is enabled\n            if requires_docstring and self.config.global_config.require_docstrings:\n                message: str = f\"Missing docstring for {item.item_type}\"\n                raise DocstringError(\n                    message=message,\n                    file_path=file_path,\n                    line_number=item.lineno,\n                    item_name=item.name,\n                    item_type=item.item_type,\n                )\n            return  # No docstring required or docstring requirement disabled\n\n        # Validate docstring sections if docstring exists\n        self._validate_docstring_sections(docstring, item, file_path)\n\n    def _validate_docstring_sections(\n        self,\n        docstring: str,\n        item: FunctionAndClassDetails,\n        file_path: str,\n    ) -&gt; None:\n        \"\"\"\n        !!! note \"Summary\"\n            Validate the sections within a docstring.\n\n        Params:\n            docstring (str):\n                The docstring to validate.\n            item (FunctionAndClassDetails):\n                The function or class to check.\n            file_path (str):\n                The path to the file containing the item.\n\n        Returns:\n            (None):\n                Nothing is returned.\n        \"\"\"\n\n        errors: list[str] = []\n\n        # Check each required section\n        for section in self.required_sections:\n            if section.type == \"free_text\":\n                if not self._check_free_text_section(docstring, section):\n                    errors.append(f\"Missing required section: {section.name}\")\n\n            elif section.type == \"list_name_and_type\":\n                if section.name.lower() == \"params\" and isinstance(item.node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n                    if not self._check_params_section(docstring, item.node):\n                        errors.append(\"Missing or invalid Params section\")\n                elif section.name.lower() in [\"returns\", \"return\"]:\n                    if not self._check_returns_section(docstring):\n                        errors.append(\"Missing or invalid Returns section\")\n\n            elif section.type == \"list_type\":\n                if section.name.lower() in [\"raises\", \"raise\"]:\n                    if not self._check_raises_section(docstring):\n                        errors.append(\"Missing or invalid Raises section\")\n                elif section.name.lower() in [\"yields\", \"yield\"]:\n                    if not self._check_yields_section(docstring):\n                        errors.append(\"Missing or invalid Yields section\")\n\n            elif section.type == \"list_name\":\n                # Simple name sections - check if they exist\n                if not self._check_simple_section(docstring, section.name):\n                    errors.append(f\"Missing required section: {section.name}\")\n\n        # Check section order\n        order_errors: list[str] = self._check_section_order(docstring)\n        errors.extend(order_errors)\n\n        # Check for mutual exclusivity (returns vs yields)\n        if self._has_both_returns_and_yields(docstring):\n            errors.append(\"Docstring cannot have both Returns and Yields sections\")\n\n        # Check for undefined sections in docstring (only if not allowed)\n        if not self.config.global_config.allow_undefined_sections:\n            undefined_errors: list[str] = self._check_undefined_sections(docstring)\n            errors.extend(undefined_errors)\n\n        # Check admonition values match configuration\n        admonition_errors: list[str] = self._check_admonition_values(docstring)\n        errors.extend(admonition_errors)\n\n        # Check colon usage for admonition vs non-admonition sections\n        colon_errors: list[str] = self._check_colon_usage(docstring)\n        errors.extend(colon_errors)\n\n        # Check title case for non-admonition sections\n        title_case_errors: list[str] = self._check_title_case_sections(docstring)\n        errors.extend(title_case_errors)\n\n        # Check parentheses for list type sections\n        parentheses_errors: list[str] = self._check_parentheses_validation(docstring)\n        errors.extend(parentheses_errors)\n\n        if errors:\n            combined_message: str = \"; \".join(errors)\n            raise DocstringError(\n                message=combined_message,\n                file_path=file_path,\n                line_number=item.lineno,\n                item_name=item.name,\n                item_type=item.item_type,\n            )\n\n    def _check_free_text_section(self, docstring: str, section: SectionConfig) -&gt; bool:\n        \"\"\"\n        !!! note \"Summary\"\n            Check if a free text section exists in the docstring.\n\n        Params:\n            docstring (str):\n                The docstring to check.\n            section (SectionConfig):\n                The section configuration to validate.\n\n        Returns:\n            (bool):\n                `True` if the section exists, `False` otherwise.\n        \"\"\"\n\n        if isinstance(section.admonition, str) and section.admonition and section.prefix:\n            # Format like: !!! note \"Summary\"\n            # Make the section name part case-insensitive too\n            escaped_name = re.escape(section.name)\n            pattern = rf'{re.escape(section.prefix)}\\s+{re.escape(section.admonition)}\\s+\"[^\"]*{escaped_name}[^\"]*\"'\n            return bool(re.search(pattern, docstring, re.IGNORECASE))\n        elif section.name.lower() in [\"summary\"]:\n            # For summary, accept either formal format or simple docstring\n            formal_pattern = r'!!! note \"Summary\"'\n            if re.search(formal_pattern, docstring, re.IGNORECASE):\n                return True\n            # Accept any non-empty docstring as summary\n            return len(docstring.strip()) &gt; 0\n        elif section.name.lower() in [\"examples\", \"example\"]:\n            # Look for examples section\n            return bool(re.search(r'\\?\\?\\?\\+ example \"Examples\"', docstring, re.IGNORECASE))\n\n        return True  # Default to true for unknown free text sections\n\n    def _check_params_section(self, docstring: str, node: Union[ast.FunctionDef, ast.AsyncFunctionDef]) -&gt; bool:\n        \"\"\"\n        !!! note \"Summary\"\n            Check if the Params section exists and documents all parameters.\n\n        Params:\n            docstring (str):\n                The docstring to check.\n            node (Union[ast.FunctionDef, ast.AsyncFunctionDef]):\n                The function node to check.\n\n        Returns:\n            (bool):\n                `True` if the section exists and is valid, `False` otherwise.\n        \"\"\"\n\n        # Get function parameters (excluding 'self' for methods)\n        params: list[str] = [arg.arg for arg in node.args.args if arg.arg != \"self\"]\n\n        if not params:\n            return True  # No parameters to document\n\n        # Check if Params section exists\n        if not re.search(r\"Params:\", docstring):\n            return False\n\n        # Check each parameter is documented\n        for param in params:\n            param_pattern: str = rf\"{re.escape(param)}\\s*\\([^)]+\\):\"\n            if not re.search(param_pattern, docstring):\n                return False\n\n        return True\n\n    def _check_returns_section(self, docstring: str) -&gt; bool:\n        \"\"\"\n        !!! note \"Summary\"\n            Check if the Returns section exists.\n\n        Params:\n            docstring (str):\n                The docstring to check.\n\n        Returns:\n            (bool):\n                `True` if the section exists, `False` otherwise.\n        \"\"\"\n\n        return bool(re.search(r\"Returns:\", docstring))\n\n    def _check_raises_section(self, docstring: str) -&gt; bool:\n        \"\"\"\n        !!! note \"Summary\"\n            Check if the Raises section exists.\n\n        Params:\n            docstring (str):\n                The docstring to check.\n\n        Returns:\n            (bool):\n                `True` if the section exists, `False` otherwise.\n        \"\"\"\n\n        return bool(re.search(r\"Raises:\", docstring))\n\n    def _has_both_returns_and_yields(self, docstring: str) -&gt; bool:\n        \"\"\"\n        !!! note \"Summary\"\n            Check if docstring has both Returns and Yields sections.\n\n        Params:\n            docstring (str):\n                The docstring to check.\n\n        Returns:\n            (bool):\n                `True` if the section exists, `False` otherwise.\n        \"\"\"\n\n        has_returns = bool(re.search(r\"Returns:\", docstring))\n        has_yields = bool(re.search(r\"Yields:\", docstring))\n        return has_returns and has_yields\n\n    def _check_section_order(self, docstring: str) -&gt; list[str]:\n        \"\"\"\n        !!! note \"Summary\"\n            Check that sections appear in the correct order.\n\n        Params:\n            docstring (str):\n                The docstring to check.\n\n        Returns:\n            (list[str]):\n                A list of error messages, if any.\n        \"\"\"\n\n        # Build expected order from configuration\n        section_patterns: list[tuple[str, str]] = []\n        for section in sorted(self.sections_config, key=lambda x: x.order):\n            if (\n                section.type == \"free_text\"\n                and isinstance(section.admonition, str)\n                and section.admonition\n                and section.prefix\n            ):\n                pattern: str = (\n                    rf'{re.escape(section.prefix)}\\s+{re.escape(section.admonition)}\\s+\".*{re.escape(section.name)}\"'\n                )\n                section_patterns.append((pattern, section.name))\n            elif section.name.lower() == \"params\":\n                section_patterns.append((r\"Params:\", \"Params\"))\n            elif section.name.lower() in [\"returns\", \"return\"]:\n                section_patterns.append((r\"Returns:\", \"Returns\"))\n            elif section.name.lower() in [\"yields\", \"yield\"]:\n                section_patterns.append((r\"Yields:\", \"Yields\"))\n            elif section.name.lower() in [\"raises\", \"raise\"]:\n                section_patterns.append((r\"Raises:\", \"Raises\"))\n\n        # Add some default patterns for common sections\n        default_patterns: list[tuple[str, str]] = [\n            (r'!!! note \"Summary\"', \"Summary\"),\n            (r'!!! details \"Details\"', \"Details\"),\n            (r'\\?\\?\\?\\+ example \"Examples\"', \"Examples\"),\n            (r'\\?\\?\\?\\+ success \"Credit\"', \"Credit\"),\n            (r'\\?\\?\\?\\+ calculation \"Equation\"', \"Equation\"),\n            (r'\\?\\?\\?\\+ info \"Notes\"', \"Notes\"),\n            (r'\\?\\?\\? question \"References\"', \"References\"),\n            (r'\\?\\?\\? tip \"See Also\"', \"See Also\"),\n        ]\n\n        all_patterns: list[tuple[str, str]] = section_patterns + default_patterns\n\n        found_sections: list[tuple[int, str]] = []\n        for pattern, section_name in all_patterns:\n            match: Optional[re.Match[str]] = re.search(pattern, docstring, re.IGNORECASE)\n            if match:\n                found_sections.append((match.start(), section_name))\n\n        # Sort by position in docstring\n        found_sections.sort(key=lambda x: x[0])\n\n        # Build expected order\n        expected_order: list[str] = [s.name.title() for s in sorted(self.sections_config, key=lambda x: x.order)]\n        expected_order.extend(\n            [\n                \"Summary\",\n                \"Details\",\n                \"Examples\",\n                \"Credit\",\n                \"Equation\",\n                \"Notes\",\n                \"References\",\n                \"See Also\",\n            ]\n        )\n\n        # Check order matches expected order\n        errors: list[str] = []\n        last_expected_index = -1\n        for _, section_name in found_sections:\n            try:\n                current_index: int = expected_order.index(section_name)\n                if current_index &lt; last_expected_index:\n                    errors.append(f\"Section '{section_name}' appears out of order\")\n                last_expected_index: int = current_index\n            except ValueError:\n                # Section not in expected order list - might be OK\n                pass\n\n        return errors\n\n    def _check_yields_section(self, docstring: str) -&gt; bool:\n        \"\"\"\n        !!! note \"Summary\"\n            Check if the Yields section exists.\n\n        Params:\n            docstring (str):\n                The docstring to check.\n\n        Returns:\n            (bool):\n                `True` if the section exists, `False` otherwise.\n        \"\"\"\n\n        return bool(re.search(r\"Yields:\", docstring))\n\n    def _check_simple_section(self, docstring: str, section_name: str) -&gt; bool:\n        \"\"\"\n        !!! note \"Summary\"\n            Check if a simple named section exists.\n\n        Params:\n            docstring (str):\n                The docstring to check.\n            section_name (str):\n                The name of the section to check for.\n\n        Returns:\n            (bool):\n                `True` if the section exists, `False` otherwise.\n        \"\"\"\n\n        pattern: str = rf\"{re.escape(section_name)}:\"\n        return bool(re.search(pattern, docstring, re.IGNORECASE))\n\n    def _check_undefined_sections(self, docstring: str) -&gt; list[str]:\n        \"\"\"\n        !!! note \"Summary\"\n            Check for sections in docstring that are not defined in configuration.\n\n        Params:\n            docstring (str):\n                The docstring to check.\n\n        Returns:\n            (list[str]):\n                A list of error messages for undefined sections.\n        \"\"\"\n\n        errors: list[str] = []\n\n        # Get all configured section names (case-insensitive)\n        configured_sections: set[str] = {section.name.lower() for section in self.sections_config}\n\n        # Common patterns for different section types\n        section_patterns: list[tuple[str, str]] = [\n            # Standard sections with colons (but not inside quotes)\n            (r\"^(\\w+):\\s*\", \"colon\"),\n            # Admonition sections with various prefixes\n            (r\"(?:\\?\\?\\?[+]?|!!!)\\s+\\w+\\s+\\\"([^\\\"]+)\\\"\", \"admonition\"),\n        ]\n\n        found_sections: set[str] = set()\n\n        for pattern, pattern_type in section_patterns:\n            matches: Iterator[re.Match[str]] = re.finditer(pattern, docstring, re.IGNORECASE | re.MULTILINE)\n            for match in matches:\n                section_name: str = match.group(1).lower().strip()\n\n                # Remove colon if present (for colon pattern matches)\n                section_name = section_name.rstrip(\":\")\n\n                # Skip empty matches or common docstring content\n                if not section_name or section_name in [\"\", \"py\", \"python\", \"sh\", \"shell\"]:\n                    continue\n\n                # Skip code blocks and inline code\n                if any(char in section_name for char in [\"`\", \".\", \"/\", \"\\\\\"]):\n                    continue\n\n                found_sections.add(section_name)\n\n        # Check which found sections are not configured\n        for section_name in found_sections:\n            if section_name not in configured_sections:\n                errors.append(f\"Section '{section_name}' found in docstring but not defined in configuration\")\n\n        return errors\n\n    def _check_admonition_values(self, docstring: str) -&gt; list[str]:\n        \"\"\"\n        !!! note \"Summary\"\n            Check that admonition values in docstring match configuration.\n\n        Params:\n            docstring (str):\n                The docstring to check.\n\n        Returns:\n            (list[str]):\n                A list of error messages for mismatched admonitions.\n        \"\"\"\n\n        errors: list[str] = []\n\n        # Create mapping of section names to expected admonitions\n        section_admonitions: dict[str, str] = {}\n        for section in self.sections_config:\n            if section.type == \"free_text\" and isinstance(section.admonition, str) and section.admonition:\n                section_admonitions[section.name.lower()] = section.admonition.lower()\n\n        # Pattern to find all admonition sections\n        admonition_pattern = r\"(?:\\?\\?\\?[+]?|!!!)\\s+(\\w+)\\s+\\\"([^\\\"]+)\\\"\"\n        matches: Iterator[re.Match[str]] = re.finditer(admonition_pattern, docstring, re.IGNORECASE)\n\n        for match in matches:\n            actual_admonition: str = match.group(1).lower()\n            section_title: str = match.group(2).lower()\n\n            # Check if this section is configured with a specific admonition\n            if section_title in section_admonitions:\n                expected_admonition: str = section_admonitions[section_title]\n                if actual_admonition != expected_admonition:\n                    errors.append(\n                        f\"Section '{section_title}' has incorrect admonition '{actual_admonition}', \"\n                        f\"expected '{expected_admonition}'\"\n                    )\n\n            # Check if section shouldn't have admonition but does\n            section_config: Optional[SectionConfig] = next(\n                (s for s in self.sections_config if s.name.lower() == section_title), None\n            )\n            if section_config and section_config.admonition is False:\n                errors.append(f\"Section '{section_title}' is configured as non-admonition but found as admonition\")\n\n        return errors\n\n    def _check_colon_usage(self, docstring: str) -&gt; list[str]:\n        \"\"\"\n        !!! note \"Summary\"\n            Check that colons are used correctly for admonition vs non-admonition sections.\n        \"\"\"\n\n        errors: list[str] = []\n\n        # Check admonition sections (should not end with colon)\n        admonition_pattern = r\"(?:\\?\\?\\?[+]?|!!!)\\s+\\w+\\s+\\\"([^\\\"]+)\\\"\"\n        matches: Iterator[re.Match[str]] = re.finditer(admonition_pattern, docstring, re.IGNORECASE)\n\n        for match in matches:\n            section_title: str = match.group(1)\n            has_colon: bool = section_title.endswith(\":\")\n            section_title_clean: str = section_title.rstrip(\":\").lower()\n\n            # Find config for this section\n            section_config: Optional[SectionConfig] = next(\n                (s for s in self.sections_config if s.name.lower() == section_title_clean), None\n            )\n            if section_config and isinstance(section_config.admonition, str) and section_config.admonition:\n                if has_colon:\n                    errors.append(\n                        f\"Section '{section_title_clean}' is an admonition, therefore it should not end with ':', \"\n                        f\"see: '{match.group(0)}'\"\n                    )\n\n        # Check non-admonition sections (should end with colon)\n        non_admonition_pattern = r\"^(\\w+)(:?)$\"\n        for line in docstring.split(\"\\n\"):\n            line: str = line.strip()\n            match: Optional[re.Match[str]] = re.match(non_admonition_pattern, line)\n            if match:\n                section_name: str = match.group(1).lower()\n                has_colon: bool = match.group(2) == \":\"\n\n                # Find config for this section\n                section_config = next((s for s in self.sections_config if s.name.lower() == section_name), None)\n                if section_config and section_config.admonition is False:\n                    if not has_colon:\n                        errors.append(\n                            f\"Section '{section_name}' is non-admonition, therefore it must end with ':', \"\n                            f\"see: '{line}'\"\n                        )\n\n        return errors\n\n    def _check_title_case_sections(self, docstring: str) -&gt; list[str]:\n        \"\"\"\n        !!! note \"Summary\"\n            Check that non-admonition sections are single word, title case, and match config name.\n        \"\"\"\n\n        errors: list[str] = []\n\n        # Pattern to find section headers (single word followed by optional colon)\n        section_pattern = r\"^(\\w+):?$\"\n\n        for line in docstring.split(\"\\n\"):\n            line: str = line.strip()\n            match: Optional[re.Match[str]] = re.match(section_pattern, line)\n            if match:\n                section_word: str = match.group(1)\n                section_name_lower: str = section_word.lower()\n\n                # Check if this is a configured non-admonition section\n                section_config: Optional[SectionConfig] = next(\n                    (s for s in self.sections_config if s.name.lower() == section_name_lower), None\n                )\n                if section_config and section_config.admonition is False:\n                    # Check if it's title case\n                    expected_title_case: str = section_config.name.title()\n                    if section_word != expected_title_case:\n                        errors.append(\n                            f\"Section '{section_name_lower}' must be in title case as '{expected_title_case}', \"\n                            f\"found: '{section_word}'\"\n                        )\n\n        return errors\n\n    def _check_parentheses_validation(self, docstring: str) -&gt; list[str]:\n        \"\"\"\n        !!! note \"Summary\"\n            Check that list_type and list_name_and_type sections have proper parentheses.\n        \"\"\"\n\n        errors: list[str] = []\n\n        # Get sections that require parentheses\n        parentheses_sections: list[SectionConfig] = [\n            s for s in self.sections_config if s.type in [\"list_type\", \"list_name_and_type\"]\n        ]\n\n        if not parentheses_sections:\n            return errors\n\n        # Check each line in the docstring\n        lines: list[str] = docstring.split(\"\\n\")\n        current_section = None\n        type_line_indent = None  # Track indentation of type definition lines\n\n        for i, line in enumerate(lines):\n            stripped_line: str = line.strip()\n\n            # Detect section headers\n            # Admonition sections\n            admonition_match: Optional[re.Match[str]] = re.match(\n                r\"(?:\\?\\?\\?[+]?|!!!)\\s+\\w+\\s+\\\"([^\\\"]+)\\\"\", stripped_line, re.IGNORECASE\n            )\n            if admonition_match:\n                section_name: str = admonition_match.group(1).lower()\n                current_section: Optional[SectionConfig] = next(\n                    (s for s in parentheses_sections if s.name.lower() == section_name), None\n                )\n                type_line_indent = None  # Reset for new section\n                continue\n\n            # Non-admonition sections - only match actual section headers, not indented content\n            # Section headers should be at the start of the line (no leading whitespace)\n            if not line.startswith((\" \", \"\\t\")):  # Not indented\n                simple_section_match: Optional[re.Match[str]] = re.match(r\"^(\\w+):?$\", stripped_line)\n                if simple_section_match:\n                    section_name: str = simple_section_match.group(1).lower()\n                    # Only consider it a section if it matches our known sections\n                    potential_section: Optional[SectionConfig] = next(\n                        (s for s in self.sections_config if s.name.lower() == section_name), None\n                    )\n                    if potential_section:\n                        # This is a real section header\n                        current_section = next(\n                            (s for s in parentheses_sections if s.name.lower() == section_name), None\n                        )\n                        type_line_indent = None  # Reset for new section\n                        continue\n                    # If it doesn't match a known section, fall through to content processing\n\n            # Check content lines if we're in a parentheses-required section\n            if current_section and stripped_line and not stripped_line.startswith((\"!\", \"?\", \"#\")):\n                # Look for parameter/type definitions\n                if \":\" in stripped_line:\n                    # Calculate current line indentation\n                    current_indent = len(line) - len(line.lstrip())\n\n                    # Skip description lines that start with common description words\n                    description_prefixes = [\n                        \"default:\",\n                        \"note:\",\n                        \"example:\",\n                        \"see:\",\n                        \"warning:\",\n                        \"info:\",\n                        \"tip:\",\n                        \"returns:\",\n                    ]\n                    is_description_line = any(\n                        stripped_line.lower().startswith(prefix) for prefix in description_prefixes\n                    )\n\n                    # Skip lines that are clearly descriptions (containing \"Default:\", etc.)\n                    if (\n                        is_description_line\n                        or \"Default:\" in stripped_line\n                        or \"Output format:\" in stripped_line\n                        or \"Show examples:\" in stripped_line\n                    ):\n                        continue\n\n                    # For list_type sections, we need special handling\n                    if current_section.type == \"list_type\":\n                        # Check if this line has parentheses at the beginning\n                        if re.search(r\"^\\s*\\([^)]+\\):\", stripped_line):\n                            # This is a valid type definition line, remember its indentation\n                            type_line_indent = current_indent\n                            continue\n                        else:\n                            # If no type definition has been found yet, allow lines with colons as possible descriptions\n                            if type_line_indent is None:\n                                continue\n                            # Check if this is a description line (more indented than type line)\n                            if current_indent &gt; type_line_indent:\n                                # This is a description line, skip validation\n                                continue\n                            else:\n                                # This should be a type definition but doesn't have proper format\n                                errors.append(\n                                    f\"Section '{current_section.name}' (type: '{current_section.type}') requires \"\n                                    f\"parenthesized types, see: '{stripped_line}'\"\n                                )\n                    # For list_name_and_type sections, check format like \"name (type):\" or \"(type):\"\n                    elif current_section.type == \"list_name_and_type\":\n                        # Check if this line has parentheses and looks like a parameter definition\n                        if re.search(r\"\\([^)]+\\):\", stripped_line):\n                            # This is a valid parameter definition line, remember its indentation\n                            type_line_indent = current_indent\n                            continue\n                        else:\n                            # Check if this is likely a description line based on various criteria\n                            colon_part = stripped_line.split(\":\")[0].strip()\n\n                            # Skip if it contains phrases that indicate it's a description, not a parameter\n                            if any(\n                                word in colon_part.lower()\n                                for word in [\"default\", \"output\", \"format\", \"show\", \"example\"]\n                            ):\n                                continue\n\n                            # Skip if it starts with bullet points or list markers\n                            if stripped_line.strip().startswith((\"-\", \"*\", \"\u2022\", \"+\")):\n                                continue\n\n                            # If we have found a parameter definition, check if this is a description line\n                            if type_line_indent is not None:\n                                # Skip if this is more indented than the parameter definition (description line)\n                                if current_indent &gt; type_line_indent:\n                                    continue\n\n                            # Skip if the line before the colon contains multiple words (likely description)\n                            words_before_colon = colon_part.split()\n                            if len(words_before_colon) &gt; 2:  # More than \"param_name (type)\"\n                                continue\n\n                            # Only flag lines that could reasonably be parameter definitions\n                            if \":\" in stripped_line and not stripped_line.strip().startswith(\"#\"):\n                                errors.append(\n                                    f\"Section '{current_section.name}' (type: '{current_section.type}') requires \"\n                                    f\"parenthesized types, see: '{stripped_line}'\"\n                                )\n\n        return errors\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringChecker.__init__","title":"__init__","text":"<pre><code>__init__(config: Config) -&gt; None\n</code></pre> <p>Summary</p> <p>Initialize the docstring checker.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>Configuration object containing global settings and section definitions.</p> required Source code in <code>src/docstring_format_checker/core.py</code> <pre><code>def __init__(self, config: Config) -&gt; None:\n    \"\"\"\n    !!! note \"Summary\"\n        Initialize the docstring checker.\n\n    Params:\n        config (Config):\n            Configuration object containing global settings and section definitions.\n    \"\"\"\n    self.config = config\n    self.sections_config: list[SectionConfig] = config.sections\n    self.required_sections: list[SectionConfig] = [s for s in config.sections if s.required]\n    self.optional_sections: list[SectionConfig] = [s for s in config.sections if not s.required]\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringChecker.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringChecker.sections_config","title":"sections_config  <code>instance-attribute</code>","text":"<pre><code>sections_config: list[SectionConfig] = sections\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringChecker.required_sections","title":"required_sections  <code>instance-attribute</code>","text":"<pre><code>required_sections: list[SectionConfig] = [\n    s for s in (sections) if required\n]\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringChecker.optional_sections","title":"optional_sections  <code>instance-attribute</code>","text":"<pre><code>optional_sections: list[SectionConfig] = [\n    s for s in (sections) if not required\n]\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringChecker.check_file","title":"check_file","text":"<pre><code>check_file(\n    file_path: Union[str, Path],\n) -&gt; list[DocstringError]\n</code></pre> <p>Summary</p> <p>Check docstrings in a Python file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Union[str, Path]</code> <p>Path to the Python file to check.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist.</p> <code>InvalidFileError</code> <p>If the file is not a Python file.</p> <code>UnicodeError</code> <p>If the file can't be decoded.</p> <code>SyntaxError</code> <p>If the file contains invalid Python syntax.</p> <p>Returns:</p> Type Description <code>list[DocstringError]</code> <p>List of DocstringError objects for any validation failures.</p> Source code in <code>src/docstring_format_checker/core.py</code> <pre><code>def check_file(self, file_path: Union[str, Path]) -&gt; list[DocstringError]:\n    \"\"\"\n    !!! note \"Summary\"\n        Check docstrings in a Python file.\n\n    Params:\n        file_path (Union[str, Path]):\n            Path to the Python file to check.\n\n    Raises:\n        (FileNotFoundError):\n            If the file doesn't exist.\n        (InvalidFileError):\n            If the file is not a Python file.\n        (UnicodeError):\n            If the file can't be decoded.\n        (SyntaxError):\n            If the file contains invalid Python syntax.\n\n    Returns:\n        (list[DocstringError]):\n            List of DocstringError objects for any validation failures.\n    \"\"\"\n\n    file_path = Path(file_path)\n    if not file_path.exists():\n        raise FileNotFoundError(f\"File not found: {file_path}\")\n\n    if file_path.suffix != \".py\":\n        raise InvalidFileError(f\"File must be a Python file (.py): {file_path}\")\n\n    # Read and parse the file\n    try:\n        with open(file_path, encoding=\"utf-8\") as f:\n            content: str = f.read()\n    except UnicodeDecodeError as e:\n        raise UnicodeError(f\"Cannot decode file {file_path}: {e}\") from e\n\n    try:\n        tree: ast.Module = ast.parse(content)\n    except SyntaxError as e:\n        raise SyntaxError(f\"Invalid Python syntax in {file_path}: {e}\") from e\n\n    # Extract all functions and classes\n    items: list[FunctionAndClassDetails] = self._extract_items(tree)\n\n    # Check each item\n    errors: list[DocstringError] = []\n    for item in items:\n        try:\n            self._check_single_docstring(item, str(file_path))\n        except DocstringError as e:\n            errors.append(e)\n\n    return errors\n</code></pre>"},{"location":"code/core/#docstring_format_checker.core.DocstringChecker.check_directory","title":"check_directory","text":"<pre><code>check_directory(\n    directory_path: Union[str, Path],\n    exclude_patterns: Optional[list[str]] = None,\n) -&gt; dict[str, list[DocstringError]]\n</code></pre> <p>Summary</p> <p>Check docstrings in all Python files in a directory recursively.</p> <p>Parameters:</p> Name Type Description Default <code>directory_path</code> <code>Union[str, Path]</code> <p>Path to the directory to check.</p> required <code>exclude_patterns</code> <code>Optional[list[str]]</code> <p>List of glob patterns to exclude.</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the directory doesn't exist.</p> <code>DirectoryNotFoundError</code> <p>If the path is not a directory.</p> <p>Returns:</p> Type Description <code>dict[str, list[DocstringError]]</code> <p>Dictionary mapping file paths to lists of DocstringError objects.</p> Source code in <code>src/docstring_format_checker/core.py</code> <pre><code>def check_directory(\n    self,\n    directory_path: Union[str, Path],\n    exclude_patterns: Optional[list[str]] = None,\n) -&gt; dict[str, list[DocstringError]]:\n    \"\"\"\n    !!! note \"Summary\"\n        Check docstrings in all Python files in a directory recursively.\n\n    Params:\n        directory_path (Union[str, Path]):\n            Path to the directory to check.\n        exclude_patterns (Optional[list[str]]):\n            List of glob patterns to exclude.\n\n    Raises:\n        (FileNotFoundError):\n            If the directory doesn't exist.\n        (DirectoryNotFoundError):\n            If the path is not a directory.\n\n    Returns:\n        (dict[str, list[DocstringError]]):\n            Dictionary mapping file paths to lists of DocstringError objects.\n    \"\"\"\n\n    directory_path = Path(directory_path)\n    if not directory_path.exists():\n        raise FileNotFoundError(f\"Directory not found: {directory_path}\")\n\n    if not directory_path.is_dir():\n        raise DirectoryNotFoundError(f\"Path is not a directory: {directory_path}\")\n\n    python_files: list[Path] = list(directory_path.glob(\"**/*.py\"))\n\n    # Filter out excluded patterns\n    if exclude_patterns:\n        filtered_files: list[Path] = []\n        for file_path in python_files:\n            relative_path: Path = file_path.relative_to(directory_path)\n            should_exclude = False\n            for pattern in exclude_patterns:\n                if fnmatch.fnmatch(str(relative_path), pattern):\n                    should_exclude = True\n                    break\n            if not should_exclude:\n                filtered_files.append(file_path)\n        python_files = filtered_files\n\n    # Check each file\n    results: dict[str, list[DocstringError]] = {}\n    for file_path in python_files:\n        try:\n            errors: list[DocstringError] = self.check_file(file_path)\n            if errors:  # Only include files with errors\n                results[str(file_path)] = errors\n        except (FileNotFoundError, ValueError, SyntaxError) as e:\n            # Create a special error for file-level issues\n            error = DocstringError(\n                message=str(e),\n                file_path=str(file_path),\n                line_number=0,\n                item_name=\"\",\n                item_type=\"file\",\n            )\n            results[str(file_path)] = [error]\n\n    return results\n</code></pre>"},{"location":"code/exceptions/","title":"Exceptions","text":""},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions","title":"docstring_format_checker.utils.exceptions","text":""},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.DocstringError","title":"DocstringError","text":"<p>               Bases: <code>Exception</code></p> <p>Summary</p> <p>Exception raised when a docstring validation error occurs.</p> Source code in <code>src/docstring_format_checker/utils/exceptions.py</code> <pre><code>class DocstringError(Exception):\n    \"\"\"\n    !!! note \"Summary\"\n        Exception raised when a docstring validation error occurs.\n    \"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        file_path: str,\n        line_number: int,\n        item_name: str,\n        item_type: str,\n    ) -&gt; None:\n        \"\"\"\n        !!! note \"Summary\"\n            Initialize a DocstringError.\n        \"\"\"\n        self.message = message\n        self.file_path = file_path\n        self.line_number = line_number\n        self.item_name = item_name\n        self.item_type = item_type\n        super().__init__(f\"Line {line_number}, {item_type} '{item_name}': {message}\")\n</code></pre>"},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.DocstringError.__init__","title":"__init__","text":"<pre><code>__init__(\n    message: str,\n    file_path: str,\n    line_number: int,\n    item_name: str,\n    item_type: str,\n) -&gt; None\n</code></pre> <p>Summary</p> <p>Initialize a DocstringError.</p> Source code in <code>src/docstring_format_checker/utils/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    file_path: str,\n    line_number: int,\n    item_name: str,\n    item_type: str,\n) -&gt; None:\n    \"\"\"\n    !!! note \"Summary\"\n        Initialize a DocstringError.\n    \"\"\"\n    self.message = message\n    self.file_path = file_path\n    self.line_number = line_number\n    self.item_name = item_name\n    self.item_type = item_type\n    super().__init__(f\"Line {line_number}, {item_type} '{item_name}': {message}\")\n</code></pre>"},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.DocstringError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.DocstringError.file_path","title":"file_path  <code>instance-attribute</code>","text":"<pre><code>file_path = file_path\n</code></pre>"},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.DocstringError.line_number","title":"line_number  <code>instance-attribute</code>","text":"<pre><code>line_number = line_number\n</code></pre>"},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.DocstringError.item_name","title":"item_name  <code>instance-attribute</code>","text":"<pre><code>item_name = item_name\n</code></pre>"},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.DocstringError.item_type","title":"item_type  <code>instance-attribute</code>","text":"<pre><code>item_type = item_type\n</code></pre>"},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.InvalidConfigError","title":"InvalidConfigError","text":"<p>               Bases: <code>Exception</code></p> <p>Summary</p> <p>Exception raised for invalid configuration errors.</p> Source code in <code>src/docstring_format_checker/utils/exceptions.py</code> <pre><code>class InvalidConfigError(Exception):\n    \"\"\"\n    !!! note \"Summary\"\n        Exception raised for invalid configuration errors.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.InvalidConfigError_DuplicateOrderValues","title":"InvalidConfigError_DuplicateOrderValues","text":"<p>               Bases: <code>Exception</code></p> <p>Summary</p> <p>Exception raised for duplicate order values in configuration.</p> Source code in <code>src/docstring_format_checker/utils/exceptions.py</code> <pre><code>class InvalidConfigError_DuplicateOrderValues(Exception):\n    \"\"\"\n    !!! note \"Summary\"\n        Exception raised for duplicate order values in configuration.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.InvalidTypeValuesError","title":"InvalidTypeValuesError","text":"<p>               Bases: <code>Exception</code></p> <p>Summary</p> <p>Exception raised for invalid type values in configuration.</p> Source code in <code>src/docstring_format_checker/utils/exceptions.py</code> <pre><code>class InvalidTypeValuesError(Exception):\n    \"\"\"\n    !!! note \"Summary\"\n        Exception raised for invalid type values in configuration.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.InvalidFileError","title":"InvalidFileError","text":"<p>               Bases: <code>OSError</code></p> <p>Summary</p> <p>Exception raised for invalid file errors.</p> Source code in <code>src/docstring_format_checker/utils/exceptions.py</code> <pre><code>class InvalidFileError(OSError):\n    \"\"\"\n    !!! note \"Summary\"\n        Exception raised for invalid file errors.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"code/exceptions/#docstring_format_checker.utils.exceptions.DirectoryNotFoundError","title":"DirectoryNotFoundError","text":"<p>               Bases: <code>OSError</code></p> <p>Summary</p> <p>Exception raised for directory not found errors.</p> Source code in <code>src/docstring_format_checker/utils/exceptions.py</code> <pre><code>class DirectoryNotFoundError(OSError):\n    \"\"\"\n    !!! note \"Summary\"\n        Exception raised for directory not found errors.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"usage/changelog/","title":"Change Log","text":"<p>v1.3.0</p> <p>v1.2.0</p> <p>v1.1.0</p> <p>v1.0.1</p> <p>v1.0.0</p> <p>v0.11.0</p> <p>v0.10.0</p> <p>v0.9.0</p> <p>v0.8.0</p> <p>v0.7.0</p> <p>v0.6.0</p> <p>v0.5.0</p> <p>v0.4.0</p> <p>v0.3.0</p> <p>v0.2.0</p> <p>v0.1.0</p>"},{"location":"usage/changelog/#v130-enhance-development-workflow-with-pre-commit-integration-and-improved-documentation-generation","title":"v1.3.0 - Enhance Development Workflow with Pre-commit Integration and Improved Documentation Generation","text":"<p><code>v1.3.0</code> <code>2025-10-06</code> data-science-extensions/docstring-format-checker/releases/v1.3.0</p> Release Notes Updates <ul> <li><code>9152084</code>: Enhance formatting of the <code>CHANGELOG.md</code> file     (by chrimaho)</li> <li><code>8c1327c</code>: Fix typo     The type ignore comment should have a space after 'type:' for consistency with standard Python type ignore formatting: '# type: ignore'.     (by chrimaho)</li> <li><code>ccd0a70</code>: Fix formatting     [nitpick] Using NEW_LINE constant instead of hardcoded '\\n' would be more consistent with the rest of the codebase where NEW_LINE is used for line separation.     (by chrimaho)</li> <li><code>9f09d46</code>: Add pre-commit hook configuration for docstring formatting<ul> <li>Introduces pre-commit hook to automatically check and format Python docstrings</li> <li>Ensures consistent docstring style guidelines across the codebase</li> <li>Targets Python files with <code>.py</code> extension for docstring validation</li> <li>Improves code quality and documentation standards through automated checks (by chrimaho)</li> </ul> </li> <li><code>33cf57e</code>: Remove UV package manager dependency from CD workflow<ul> <li>Replace UV with standard pip for package installation to simplify the workflow</li> <li>Remove UV setup step and Python version verification steps as they are no longer needed</li> <li>Add <code>--no-python-version-warning</code> flag to pip install command to suppress version warnings</li> <li>Streamline the continuous deployment process by reducing external tool dependencies (by chrimaho)</li> </ul> </li> <li><code>04635f7</code>: Improve changelog generation with stricter typing and enhanced commit formatting<ul> <li>Add <code>Literal</code> type hints to string constants for better type safety and IDE support</li> <li>Change release title reference from <code>release.title</code> to <code>release.name</code> for correct property access</li> <li>Enhance commit message processing to filter out co-authored-by lines and empty lines for cleaner output</li> <li>Restructure commit entry format to include short SHA, improved layout with author attribution on separate line</li> <li>Add type ignore comment for repository access to suppress type checker warnings (by chrimaho)</li> </ul> </li> </ul>"},{"location":"usage/changelog/#summary","title":"\ud83c\udfaf Summary","text":"<p>Introduce comprehensive development workflow enhancements that establish automated quality assurance and superior documentation generation capabilities. This release delivers significant improvements to the development pipeline through pre-commit hook integration, CI/CD workflow optimisation, and enhanced changelog generation with advanced type safety and formatting improvements.</p> <p>Transform the development experience by implementing automated docstring validation through standardised pre-commit hooks whilst streamlining deployment processes and providing enhanced documentation generation. These enhancements establish robust quality gates that ensure consistent code standards across the codebase whilst improving developer productivity through automation and simplified tooling.</p> <p>Key Enhancement Areas:</p> <ul> <li>Pre-commit Integration: Automated docstring validation through standardised pre-commit hooks for consistent code quality enforcement</li> <li>CI/CD Optimisation: Streamlined deployment workflows through UV package manager dependency removal and simplified tooling</li> <li>Enhanced Documentation: Superior changelog generation with stricter typing, improved formatting, and cleaner output presentation</li> <li>Type Safety Enhancement: Advanced <code>Literal</code> type hints for better IDE support and comprehensive static analysis capabilities</li> <li>Quality Automation: Integration of automated docstring format checking into standard development workflows</li> </ul>"},{"location":"usage/changelog/#release-statistics","title":"\ud83d\udcc8 Release Statistics","text":""},{"location":"usage/changelog/#code-changes-summary","title":"\ud83d\udd22 Code Changes Summary","text":"<ul> <li>Files Modified: 4 core files with targeted workflow and documentation enhancements</li> <li>Lines Added: 1,500+ new lines including comprehensive changelog improvements and configuration updates</li> <li>Workflow Simplification: 11 lines removed from CI/CD workflow reducing external dependencies</li> <li>Pre-commit Integration: 6 new configuration lines enabling automated quality validation</li> <li>Type Safety: 5+ enhanced type annotations with <code>Literal</code> types for superior IDE support</li> </ul>"},{"location":"usage/changelog/#development-experience-enhancement","title":"\ud83d\udcca Development Experience Enhancement","text":"<ul> <li>Automated Quality Gates: Pre-commit hooks providing immediate feedback on docstring formatting standards</li> <li>Simplified Dependencies: Reduced CI/CD complexity through standard Python tooling adoption</li> <li>Enhanced Documentation: Superior changelog formatting with improved readability and professional presentation</li> <li>Type Checking: Advanced static analysis support through comprehensive type hints and IDE integration</li> </ul>"},{"location":"usage/changelog/#pre-commit-hook-integration","title":"\ud83d\udee0\ufe0f Pre-commit Hook Integration","text":""},{"location":"usage/changelog/#automated-quality-assurance-implementation","title":"\ud83d\udccb Automated Quality Assurance Implementation","text":"<p>Establish comprehensive pre-commit integration supporting automated docstring validation:</p> <ul> <li>Hook Configuration: Introduce <code>.pre-commit-hooks.yaml</code> configuration enabling seamless integration with development workflows</li> <li>Python File Targeting: Configure regex pattern <code>\\.(py)$</code> ensuring comprehensive coverage of all Python source code files</li> <li>Entry Point Integration: Utilise <code>docstring-format-checker</code> command for consistent execution across development environments</li> <li>Quality Gate Enforcement: Prevent commits violating docstring formatting standards through automated pre-commit validation</li> </ul> <p>Pre-commit Configuration:</p> <pre><code># .pre-commit-hooks.yaml - Automated docstring validation\n- id: docstring-format-checker\n  name: docstring-format-checker  \n  description: A CLI tool to check and format Python docstrings to adhere to specified style guidelines.\n  entry: docstring-format-checker\n  language: python\n  files: '\\.(py)$'\n</code></pre>"},{"location":"usage/changelog/#development-workflow-enhancement","title":"\ud83d\udd04 Development Workflow Enhancement","text":"<p>Enable seamless integration with established development practices:</p> <ul> <li>IDE Compatibility: Support integration with popular development environments utilising pre-commit hooks for automated quality checking</li> <li>Git Integration: Automatic execution during commit operations preventing commits that violate established docstring formatting standards</li> <li>CI/CD Compatibility: Compatible with continuous integration systems executing pre-commit hooks as automated testing pipeline components</li> <li>Developer Experience: Provide immediate feedback on formatting violations before code reaches repository for enhanced productivity</li> </ul>"},{"location":"usage/changelog/#cicd-workflow-optimisation","title":"\u2699\ufe0f CI/CD Workflow Optimisation","text":""},{"location":"usage/changelog/#deployment-pipeline-simplification","title":"\ud83d\ude80 Deployment Pipeline Simplification","text":"<p>Streamline continuous deployment workflow through dependency reduction and tooling standardisation:</p> <ul> <li>UV Dependency Removal: Eliminate <code>astral-sh/setup-uv@v6</code> action reducing external tool dependencies and potential deployment failure points</li> <li>Standard Python Setup: Utilise established <code>actions/setup-python@v5</code> for reliable, well-supported Python environment configuration</li> <li>Simplified Installation: Replace UV-specific commands with standard <code>pip install</code> for enhanced compatibility and reduced complexity</li> <li>Maintained Functionality: Preserve essential installation flags whilst simplifying overall deployment workflow execution</li> </ul> <p>Workflow Transformation:</p> <pre><code># Before: UV-based installation with multiple setup dependencies\n- name: Set up UV\n  uses: astral-sh/setup-uv@v6\n- name: Verify Python Version  \n  run: |\n    uv --version\n    python --version\n- name: Install Package\n  run: uv pip install --no-cache --verbose \"${{ env.PACKAGE_NAME }}==${{ env.VERSION }}\"\n\n# After: Simplified standard pip installation\n- name: Set up Python\n  uses: actions/setup-python@v5\n  with:\n    python-version: ${{ matrix.python-version }}\n- name: Install Package\n  run: pip install --no-cache --verbose --no-python-version-warning \"${{ env.PACKAGE_NAME }}==${{ env.VERSION }}\"\n</code></pre>"},{"location":"usage/changelog/#installation-process-enhancement","title":"\ud83d\udd27 Installation Process Enhancement","text":"<p>Improve deployment reliability and cross-platform compatibility:</p> <ul> <li>Standard Tooling: Utilise standard <code>pip</code> installation for consistent behaviour across operating systems and deployment environments</li> <li>Warning Suppression: Add <code>--no-python-version-warning</code> flag preventing unnecessary warning messages during installation processes</li> <li>Verbose Logging: Maintain <code>--verbose</code> flag ensuring comprehensive installation logging for debugging and monitoring capabilities</li> <li>Cache Management: Preserve <code>--no-cache</code> flag ensuring fresh package installations and avoiding potential caching-related deployment issues</li> </ul>"},{"location":"usage/changelog/#enhanced-documentation-generation","title":"\ud83d\udcda Enhanced Documentation Generation","text":""},{"location":"usage/changelog/#type-safety-and-ide-support-enhancement","title":"\ud83d\udd24 Type Safety and IDE Support Enhancement","text":"<p>Implement comprehensive type hints for improved development experience and static analysis:</p> <ul> <li>Literal Type Annotations: Replace generic <code>str</code> types with <code>Literal</code> annotations for constants (<code>OUTPUT_FILENAME</code>, <code>NEW_LINE</code>, <code>BLANK_LINE</code>, <code>LINE_BREAK</code>, <code>TAB</code>) enhancing type safety</li> <li>Import Enhancement: Add <code>Literal</code> import from <code>typing</code> module supporting advanced type hinting and static analysis capabilities</li> <li>Static Analysis: Improve IDE support with enhanced type information enabling better code navigation, autocompletion, and refactoring</li> <li>Type Checking: Add strategic <code>type: ignore</code> comments for repository access ensuring compatibility with type checkers whilst maintaining functionality</li> </ul> <p>Type Safety Implementation:</p> <pre><code># Enhanced type safety with Literal annotations\nfrom typing import Literal, Optional\n\nOUTPUT_FILENAME: Literal[\"CHANGELOG.md\"] = \"CHANGELOG.md\"\nNEW_LINE: Literal[\"\\n\"] = \"\\n\"  \nBLANK_LINE: Literal[\"\\n\\n\"] = \"\\n\\n\"\nLINE_BREAK: Literal[\"&lt;br&gt;\"] = \"&lt;br&gt;\"\nTAB: Literal[\"    \"] = \"    \"\n</code></pre>"},{"location":"usage/changelog/#commit-message-processing-enhancement","title":"\ud83d\udcdd Commit Message Processing Enhancement","text":"<p>Improve changelog formatting through enhanced commit message processing and filtering:</p> <ul> <li>Co-authored Line Filtering: Remove \"Co-authored-by\" lines from commit messages focusing on primary commit content for improved readability</li> <li>Empty Line Handling: Filter out blank lines and whitespace-only content ensuring cleaner changelog presentation and professional formatting</li> <li>Message Structure: Restructure commit entry format with enhanced layout including short SHA and improved author attribution formatting</li> <li>Output Quality: Generate superior changelog output with consistent formatting, professional presentation, and enhanced navigation capabilities</li> </ul> <p>Processing Logic Enhancement:</p> <pre><code># Enhanced commit message processing with comprehensive filtering\ncommit_message_list: list[str] = []\nfor line in commit.commit.message.split(NEW_LINE):\n    line_stripped: str = line.strip()\n    # Filter out blank lines and \"Co-authored-by\" lines for cleaner output\n    if line_stripped and not line_stripped.lower().startswith(\"co-authored-by:\"):\n        commit_message_list.append(line_stripped)\n</code></pre>"},{"location":"usage/changelog/#release-information-enhancement","title":"\ud83c\udfd7\ufe0f Release Information Enhancement","text":"<p>Correct GitHub API property access and improve changelog structure consistency:</p> <ul> <li>Property Access Fix: Change from <code>release.title</code> to <code>release.name</code> ensuring correct GitHub API property access and accurate release information</li> <li>Title Formatting: Establish proper release title formatting in generated changelog documentation for structural consistency</li> <li>Metadata Accuracy: Provide accurate release metadata including correct title, date, and link information enhancing documentation quality</li> <li>Structure Consistency: Maintain uniform changelog structure across all release entries improving readability and professional presentation</li> </ul>"},{"location":"usage/changelog/#development-experience-enhancement_1","title":"\ud83c\udfaf Development Experience Enhancement","text":""},{"location":"usage/changelog/#quality-assurance-automation","title":"\ud83d\udee1\ufe0f Quality Assurance Automation","text":"<p>Establish comprehensive automated quality gates for consistent code standards:</p> <ul> <li>Pre-commit Validation: Automatic docstring format checking preventing formatting violations from entering repository codebase</li> <li>Consistent Standards: Enforce uniform docstring formatting standards across entire codebase through automated validation and immediate feedback</li> <li>Developer Feedback: Provide instant feedback on formatting violations during development workflow enabling rapid issue resolution</li> <li>CI/CD Integration: Support seamless integration with continuous integration systems ensuring comprehensive quality assurance coverage</li> </ul>"},{"location":"usage/changelog/#workflow-streamlining","title":"\ud83d\udd27 Workflow Streamlining","text":"<p>Simplify development and deployment processes through standardisation and automation:</p> <ul> <li>Reduced Dependencies: Minimise external tool dependencies in CI/CD workflows improving reliability and reducing potential deployment failure points</li> <li>Faster Execution: Streamline workflow execution through unnecessary step elimination and simplified setup procedures</li> <li>Improved Reliability: Utilise standard, well-established tools and practices ensuring better long-term maintainability and cross-platform compatibility</li> <li>Enhanced Debugging: Maintain comprehensive logging capabilities whilst simplifying overall workflow structure for superior troubleshooting</li> </ul>"},{"location":"usage/changelog/#documentation-quality-enhancement","title":"\ud83d\udcd6 Documentation Quality Enhancement","text":"<p>Improve documentation generation capabilities and presentation quality:</p> <ul> <li>Enhanced Type Safety: Provide superior IDE support and static analysis capabilities through comprehensive type hints and advanced annotations</li> <li>Cleaner Output: Generate professional changelog formatting with improved readability, consistent structure, and enhanced presentation quality</li> <li>Accurate Metadata: Ensure correct release information and commit details in generated documentation preventing information inconsistencies</li> <li>Consistent Formatting: Maintain uniform documentation structure and formatting across all generated content ensuring professional presentation</li> </ul>"},{"location":"usage/changelog/#technical-implementation-details","title":"\ud83d\udd0d Technical Implementation Details","text":""},{"location":"usage/changelog/#architecture-enhancement","title":"\ud83d\udcd0 Architecture Enhancement","text":"<p>Implementation maintains comprehensive separation of concerns whilst introducing enhanced capabilities:</p> <ul> <li>Quality Integration Layer: Pre-commit configuration providing seamless development workflow integration with automated validation</li> <li>CI/CD Optimisation Layer: Simplified deployment pipeline with reduced dependencies and improved reliability through standard tooling</li> <li>Documentation Generation Layer: Enhanced changelog generation with superior formatting, type safety, and professional presentation</li> <li>Type Safety Layer: Comprehensive type hints improving IDE support, static analysis capabilities, and development experience</li> </ul>"},{"location":"usage/changelog/#quality-assurance-enhancement","title":"\ud83e\uddea Quality Assurance Enhancement","text":"<p>Comprehensive improvements ensuring reliability, maintainability, and professional development practices:</p> <ul> <li>Automated Testing: Pre-commit hooks providing automatic validation of docstring formatting standards and immediate developer feedback</li> <li>Type Checking: Enhanced type hints supporting superior static analysis and error detection capabilities during development</li> <li>Workflow Reliability: Simplified CI/CD workflows reducing potential failure points and improving deployment success rates through standardisation</li> <li>Documentation Quality: Improved changelog generation providing superior documentation presentation, accuracy, and professional formatting</li> </ul>"},{"location":"usage/changelog/#integration-and-compatibility-enhancement","title":"\ud83d\udcda Integration and Compatibility Enhancement","text":"<p>Enhanced compatibility and integration capabilities across development environments:</p> <ul> <li>IDE Support: Comprehensive type hints providing superior IDE integration with autocompletion, error detection, and enhanced development experience</li> <li>CI/CD Compatibility: Simplified workflows supporting enhanced integration with various CI/CD platforms and deployment configurations</li> <li>Development Tool Integration: Pre-commit hooks integrating seamlessly with popular development tools and editor configurations</li> <li>Cross-Platform Support: Standard tooling ensuring consistent behaviour across different operating systems and deployment environments</li> </ul>"},{"location":"usage/changelog/#benefits-and-impact","title":"\ud83d\udcc8 Benefits and Impact","text":""},{"location":"usage/changelog/#developer-productivity-enhancement","title":"\ud83d\ude80 Developer Productivity Enhancement","text":"<p>Deliver significant productivity improvements through automation and streamlined workflows:</p> <ul> <li>Automated Quality Gates: Reduce manual code review overhead through automated docstring validation and formatting enforcement</li> <li>Seamless Integration: Provide transparent integration with existing development tools without disrupting established development practices</li> <li>Immediate Feedback: Enable rapid identification and resolution of formatting violations during development rather than post-commit review</li> <li>Consistent Standards: Ensure uniform code quality across all contributors and development environments through comprehensive automation</li> </ul>"},{"location":"usage/changelog/#workflow-reliability-improvement","title":"\ud83d\udca1 Workflow Reliability Improvement","text":"<p>Enhance deployment and documentation generation reliability through standardisation:</p> <ul> <li>Simplified Dependencies: Reduce potential CI/CD failure points through dependency simplification and adoption of standard tooling practices</li> <li>Improved Compatibility: Utilise established tools and practices ensuring superior cross-platform compatibility and long-term maintainability</li> <li>Enhanced Documentation: Provide superior changelog generation with accurate metadata, improved formatting, and professional presentation</li> <li>Type Safety: Improve code maintainability and IDE support through comprehensive type hints and advanced static analysis capabilities</li> </ul>"},{"location":"usage/changelog/#maintenance-and-sustainability-enhancement","title":"\ud83d\udd27 Maintenance and Sustainability Enhancement","text":"<p>Establish sustainable development practices supporting long-term project success:</p> <ul> <li>Standard Tooling: Utilise established, well-maintained tools ensuring superior long-term support and community compatibility</li> <li>Automated Quality: Reduce manual maintenance overhead through automated quality assurance and comprehensive formatting enforcement</li> <li>Enhanced Debugging: Provide superior debugging capabilities through improved logging and simplified workflow structure</li> <li>Future-Proof Architecture: Establish flexible, maintainable architecture supporting future enhancements and continuous improvement</li> </ul>"},{"location":"usage/changelog/#usage-examples-and-integration-patterns","title":"\ud83d\udccb Usage Examples and Integration Patterns","text":"<p>Enhanced development workflow supporting comprehensive quality assurance and automation:</p> <pre><code># Pre-commit hook integration (automatic validation)\ngit commit -m \"Add new feature\"  # Automatically validates docstring formatting\n\n# Manual docstring validation\ndocstring-format-checker src/  # Validates all Python files in src directory\n\n# Simplified CI/CD workflow execution  \npip install --no-cache --verbose --no-python-version-warning docstring-format-checker\n</code></pre> <p>Enhanced changelog generation with superior formatting and type safety:</p> <pre><code># Generate changelog with improved formatting and type safety\nexport GITHUB_TOKEN=\"${GITHUB_TOKEN}\"\nexport REPOSITORY_NAME=\"data-science-extensions/docstring-format-checker\" \nuv run ./src/utils/changelog.py\n</code></pre> <p>Pre-commit hook configuration for development teams:</p> <pre><code># .pre-commit-config.yaml (team configuration)\nrepos:\n  - repo: https://github.com/data-science-extensions/docstring-format-checker\n    rev: v1.3.0\n    hooks:\n      - id: docstring-format-checker\n</code></pre>"},{"location":"usage/changelog/#migration-and-compatibility","title":"\ud83d\udd04 Migration and Compatibility","text":"<p>Seamless upgrade path ensuring compatibility and enhanced functionality:</p> <ul> <li>Zero Breaking Changes: All existing functionality remains completely unchanged ensuring smooth upgrade experience</li> <li>Enhanced Capabilities: New features provide additional functionality without affecting existing workflows or user experience</li> <li>Backward Compatibility: Complete preservation of existing CLI behaviour, configuration options, and integration patterns</li> <li>Progressive Enhancement: Users can adopt new features gradually without migration requirements or workflow disruption</li> </ul>"},{"location":"usage/changelog/#pull-requests","title":"\ud83d\udcaa Pull Requests","text":"<ul> <li>Enhance Development Workflow with Pre-commit Integration and Improved Documentation Generation by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/17</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/docstring-format-checker/compare/v1.2.0...v1.3.0</p> <p>Pre-commit Integration: Automated docstring validation through <code>.pre-commit-hooks.yaml</code> configuration CI/CD Simplification: Streamlined deployment workflows with reduced dependencies and standard tooling Enhanced Documentation: Superior changelog generation with type safety and professional formatting Quality Automation: Comprehensive automated quality gates ensuring consistent development standards</p>"},{"location":"usage/changelog/#v120-enhance-cli-with-multiple-file-processing-capabilities","title":"v1.2.0 - Enhance CLI with Multiple File Processing Capabilities","text":"<p><code>v1.2.0</code> <code>2025-10-05</code> data-science-extensions/docstring-format-checker/releases/v1.2.0</p> Release Notes Updates <ul> <li><code>0e17a2f</code>: Refactor test imports to improve code organisation<ul> <li>Move repeated local imports to module level to reduce duplication</li> <li>Consolidate standard library imports at the top of the file</li> <li>Remove redundant inline import statements scattered throughout test methods</li> <li>Replace aliased <code>tempfile</code> import with direct module usage for consistency</li> <li>Standardise code formatting with proper <code>dedent()</code> usage in test strings (by chrimaho)</li> </ul> </li> <li><code>e1a318e</code>: Streamline <code>Path()</code> object creation     The path validation creates Path objects twice for each path. Consider creating Path objects once and then filtering based on existence to avoid redundant object creation.     (by chrimaho)</li> <li><code>7741d7c</code>: Fix formatting     (by chrimaho)</li> <li><code>fc0f0e0</code>: Remove deprecated python version warning flag from <code>uv pip install</code> command<ul> <li>Remove <code>--no-python-version-warning</code> flag from the package installation command</li> <li>Simplify the installation process by removing an obsolete warning suppression option</li> <li>Maintain existing installation behaviour with <code>--no-cache</code> and <code>--verbose</code> flags (by chrimaho)</li> </ul> </li> <li><code>76211c3</code>: Add support for checking multiple files and directories simultaneously<ul> <li>Change CLI argument from single <code>path</code> to multiple <code>paths</code> to enable batch processing</li> <li>Update <code>check_docstrings()</code> function to handle list of paths and aggregate results from all targets</li> <li>Enhance path validation to report all invalid paths at once rather than failing on first error</li> <li>Add comprehensive test coverage for multiple file scenarios including mixed file types, error handling, and output formats</li> <li>Update usage examples in help text to demonstrate new multi-path capabilities with exclusion patterns (by chrimaho)</li> </ul> </li> </ul>"},{"location":"usage/changelog/#summary_1","title":"\ud83c\udfaf Summary","text":"<p>Introduce comprehensive multiple file processing capabilities that transform the CLI tool from single-file operation to sophisticated batch processing whilst maintaining complete backwards compatibility. This release delivers significant functionality enhancement enabling developers to validate entire codebases efficiently through simultaneous checking of multiple files and directories in a single command.</p> <p>Transform the validation workflow by expanding CLI argument processing from individual file handling to comprehensive multi-path batch operations. Enhance developer productivity by enabling efficient validation of complex project structures whilst providing enhanced error reporting, improved path validation, and modernised CI/CD integration. Establish robust foundation for enterprise-scale docstring validation workflows.</p> <p>Key Enhancement Areas:</p> <ul> <li>Multi-Path CLI Processing: Comprehensive argument transformation supporting multiple file and directory targets</li> <li>Enhanced Path Validation: Advanced error reporting with detailed feedback for invalid paths  </li> <li>Backwards Compatibility Guarantee: Complete preservation of existing single-file functionality and behaviour</li> <li>Comprehensive Test Coverage: Seven new testing scenarios covering multiple file operations across all CLI features</li> <li>Workflow Modernisation: Removal of deprecated UV installation flags for improved CI reliability</li> </ul>"},{"location":"usage/changelog/#release-statistics_1","title":"\ud83d\udcc8 Release Statistics","text":""},{"location":"usage/changelog/#code-changes-summary_1","title":"\ud83d\udd22 Code Changes Summary","text":"<ul> <li>Files Modified: 4 core files with targeted enhancements</li> <li>Lines Added: 1,575+ new lines including comprehensive tests and documentation</li> <li>Test Enhancement: 354+ new test lines with 7 dedicated multiple file scenarios  </li> <li>CLI Functionality: 65+ lines of enhanced CLI logic for multi-path processing</li> <li>Documentation Updates: 1,215+ lines of changelog and usage examples</li> </ul>"},{"location":"usage/changelog/#testing-excellence","title":"\ud83d\udcca Testing Excellence","text":"<ul> <li>New Test Methods: 7 comprehensive multiple file testing scenarios</li> <li>Test Coverage: Maintained 100% code coverage across all enhanced functionality</li> <li>CLI Integration: Complete integration testing using authentic command-line simulation</li> <li>Edge Case Coverage: Comprehensive validation of mixed valid/invalid paths and error conditions</li> </ul>"},{"location":"usage/changelog/#multiple-file-processing-implementation","title":"\ud83d\ude80 Multiple File Processing Implementation","text":""},{"location":"usage/changelog/#core-cli-architecture-enhancement","title":"\ud83c\udfd7\ufe0f Core CLI Architecture Enhancement","text":"<p>Transform the CLI argument structure to support comprehensive multiple file and directory targets:</p> <ul> <li>Parameter Transformation: Enhance CLI argument from single <code>path: Optional[str]</code> to multiple <code>paths: Optional[list[str]]</code> enabling sophisticated batch processing</li> <li>Function Signature Evolution: Modify <code>check_docstrings()</code> function to accept <code>paths: list[str]</code> parameter supporting concurrent validation operations</li> <li>Advanced Path Validation: Implement comprehensive validation logic identifying and reporting all invalid paths simultaneously rather than failing on first error</li> <li>Result Aggregation System: Collect and merge docstring validation results from multiple sources into unified, structured output</li> </ul> <p>Enhanced CLI Signature:</p> <pre><code># CLI parameter transformation for multiple file support\ndef main(\n    ctx: Context,\n    paths: Optional[list[str]] = Argument(\n        None, \n        help=\"Path(s) to Python file(s) or directory(s) for DFC to check\"\n    ),\n    # ... other parameters preserved\n): ...\n</code></pre> <p>Function Processing Enhancement:</p> <pre><code># Multi-path processing with comprehensive validation\ndef check_docstrings(\n    paths: list[str],  # Enhanced from single path parameter\n    config: Optional[str] = None,\n    exclude: Optional[list[str]] = None,\n    # ... other parameters\n): ...\n</code></pre>"},{"location":"usage/changelog/#advanced-path-validation-and-error-management","title":"\ud83d\udd0d Advanced Path Validation and Error Management","text":"<p>Implement sophisticated validation logic supporting comprehensive multiple target path analysis:</p> <ul> <li>Batch Validation Processing: Validate all provided paths simultaneously before processing execution begins</li> <li>Structured Error Reporting: Report all invalid paths in single, comprehensively formatted error message with enhanced readability  </li> <li>Early Validation Strategy: Prevent unnecessary processing overhead by validating complete path set upfront</li> <li>Rich Text Error Output: Format invalid path errors with structured bullet points and enhanced terminal formatting</li> </ul> <p>Enhanced Path Validation Logic:</p> <pre><code># Comprehensive multi-path validation with detailed error reporting\npath_objs: list[Path] = [Path(path) for path in paths]\ntarget_paths: list[Path] = [p for p in path_objs if p.exists()]\ninvalid_paths: list[Path] = [p for p in path_objs if not p.exists()]\n\nif len(invalid_paths) &gt; 0:\n    console.print(\n        _red(f\"[bold]Error: Paths do not exist:[/bold]\"),\n        NEW_LINE,\n        NEW_LINE.join([f\"- '{invalid_path}'\" for invalid_path in invalid_paths]),\n    )\n    raise Exit(1)\n</code></pre>"},{"location":"usage/changelog/#result-aggregation-and-processing-architecture","title":"\ud83d\udd04 Result Aggregation and Processing Architecture","text":"<p>Implement comprehensive result collection system supporting diverse source integration:</p> <ul> <li>Iterative Path Processing: Process each valid path individually whilst maintaining complete error isolation between sources</li> <li>Advanced Result Merging: Aggregate docstring validation errors from all sources into unified result dictionary structure</li> <li>Mixed Path Type Support: Handle sophisticated combinations of individual files and directories seamlessly within single command execution</li> <li>Configuration Discovery Enhancement: Utilise first valid path for automatic configuration file discovery when no explicit configuration provided</li> </ul> <p>Multi-Path Processing Logic:</p> <pre><code># Enhanced processing supporting multiple paths with result aggregation  \nall_results: dict[str, list[DocstringError]] = {}\n\nfor target_path in target_paths:\n    if target_path.is_file():\n        errors: list[DocstringError] = checker.check_file(target_path)\n        if errors:\n            all_results[str(target_path)] = errors\n    else:\n        directory_results: dict[str, list[DocstringError]] = checker.check_directory(\n            target_path, exclude_patterns=exclude\n        )\n        all_results.update(directory_results)\n</code></pre>"},{"location":"usage/changelog/#enhanced-usage-examples-and-cli-integration","title":"\ud83d\udca1 Enhanced Usage Examples and CLI Integration","text":""},{"location":"usage/changelog/#comprehensive-usage-pattern-enhancement","title":"\ud83d\udee0\ufe0f Comprehensive Usage Pattern Enhancement","text":"<p>Expand CLI help documentation to demonstrate sophisticated multi-path capabilities:</p> <ul> <li>Multiple File Examples: Add comprehensive examples demonstrating simultaneous checking of multiple Python files</li> <li>Advanced Exclusion Integration: Showcase combining multiple path targets with exclusion patterns for sophisticated filtering operations  </li> <li>Mixed Usage Scenarios: Provide examples demonstrating concurrent checking of individual files and complete directories within single command execution</li> </ul> <p>New Usage Examples:</p> <pre><code># Enhanced multi-file processing capabilities\ndfc myfile.py other_file.py                    # Check multiple Python files simultaneously\ndfc -x src/app/__init__.py src/                 # Check directory excluding specific file  \ndfc file1.py file2.py src/ tests/               # Mixed files and directories\ndfc --output=table myfile.py src/ tests/       # Multiple paths with table output\ndfc --check src/models/ src/views/              # Batch processing with check flag\n</code></pre>"},{"location":"usage/changelog/#backwards-compatibility-preservation","title":"\ud83d\udd27 Backwards Compatibility Preservation","text":"<p>Maintain comprehensive backwards compatibility whilst delivering enhanced functionality:</p> <ul> <li>Single File Operation: Existing <code>dfc myfile.py</code> commands execute identically to previous behaviour patterns</li> <li>Directory Processing Continuity: Directory scanning behaviour remains completely unchanged for single directory operations  </li> <li>Flag Compatibility Assurance: All existing CLI flags (<code>--quiet</code>, <code>--check</code>, <code>--output</code>, etc.) function seamlessly with enhanced multiple path processing</li> <li>Consistent Error Handling: Maintain identical error behaviour patterns whether processing single or multiple path targets</li> </ul>"},{"location":"usage/changelog/#comprehensive-testing-enhancement","title":"\ud83e\uddea Comprehensive Testing Enhancement","text":""},{"location":"usage/changelog/#seven-new-testing-scenarios","title":"\ud83d\udcca Seven New Testing Scenarios","text":"<p>Implement comprehensive test coverage expansion supporting multiple file functionality validation:</p> <ul> <li><code>test_51_multiple_files_success()</code>: Validate successful processing of multiple valid files with appropriate success messaging output</li> <li><code>test_52_multiple_files_with_errors()</code>: Test sophisticated error aggregation when subset of files contain docstring validation issues</li> <li><code>test_53_multiple_files_with_check_flag()</code>: Verify <code>--check</code> flag behaviour with multiple files and appropriate exit code handling  </li> <li><code>test_54_multiple_files_nonexistent_path()</code>: Test comprehensive error handling when subset of paths don't exist alongside valid path targets</li> <li><code>test_55_multiple_files_mixed_types()</code>: Validate processing sophisticated combinations of individual files and complete directories</li> <li><code>test_56_multiple_files_table_output()</code>: Test table output formatting with aggregated results from multiple diverse sources</li> <li><code>test_57_multiple_files_quiet_mode()</code>: Verify quiet mode operational behaviour with comprehensive multiple file processing operations</li> </ul>"},{"location":"usage/changelog/#testing-architecture-enhancement","title":"\ud83d\udd0d Testing Architecture Enhancement","text":"<p>Achieve comprehensive coverage expansion supporting robust multiple file functionality validation:</p> <ul> <li>354+ New Test Lines: Extensive test coverage addition ensuring robust multiple file functionality across diverse scenarios</li> <li>Edge Case Coverage: Test scenarios encompass mixed valid/invalid paths, different output formatting options, and comprehensive error condition handling</li> <li>CLI Integration Testing: Complete integration testing utilising <code>typer.testing.CliRunner</code> for authentic CLI behaviour simulation across all scenarios  </li> <li>Temporary File Management: Robust temporary file creation and cleanup protocols in test scenarios using appropriate context management patterns</li> </ul>"},{"location":"usage/changelog/#cicd-workflow-modernisation","title":"\u2699\ufe0f CI/CD Workflow Modernisation","text":""},{"location":"usage/changelog/#deprecated-configuration-removal","title":"\ud83d\udd27 Deprecated Configuration Removal","text":"<p>Modernise CI/CD pipeline configuration by eliminating obsolete UV installation parameters:</p> <ul> <li>Remove <code>--no-python-version-warning</code>: Eliminate deprecated warning suppression flag from <code>uv pip install</code> command execution</li> <li>Maintain Installation Reliability: Preserve essential <code>--no-cache</code> and <code>--verbose</code> flags ensuring installation transparency and debugging capabilities</li> <li>Simplify Pipeline Configuration: Reduce command complexity whilst maintaining robust installation behaviour and monitoring</li> <li>Future Compatibility Assurance: Ensure CI pipeline compatibility with current and anticipated future UV versions and configurations</li> </ul> <p>Workflow Command Enhancement:</p> <pre><code># CI/CD workflow simplification removing deprecated flags\n# Before: With deprecated warning suppression\nrun: uv pip install --no-cache --verbose --no-python-version-warning \"${{ env.PACKAGE_NAME }}==${{ env.VERSION }}\"\n\n# After: Streamlined without deprecated configuration  \nrun: uv pip install --no-cache --verbose \"${{ env.PACKAGE_NAME }}==${{ env.VERSION }}\"\n</code></pre>"},{"location":"usage/changelog/#developer-experience-enhancement","title":"\ud83c\udfaf Developer Experience Enhancement","text":""},{"location":"usage/changelog/#productivity-and-workflow-benefits","title":"\ud83d\ude80 Productivity and Workflow Benefits","text":"<p>Deliver significant productivity improvements for comprehensive docstring validation workflows:</p> <ul> <li>Batch Processing Efficiency: Enable simultaneous checking of multiple files rather than requiring separate command invocations</li> <li>Workflow Integration Enhancement: Support comprehensive codebase validation within single command execution for sophisticated CI/CD integration  </li> <li>Reduced Command Complexity: Eliminate requirement for shell loops or multiple command invocations across project validation</li> <li>Unified Result Reporting: Provide consistent error reporting and formatting across all processed files and directories</li> </ul>"},{"location":"usage/changelog/#seamless-backwards-compatibility","title":"\ud83d\udca1 Seamless Backwards Compatibility","text":"<p>Ensure effortless upgrade path for existing user workflows:</p> <ul> <li>Zero Breaking Changes: All existing commands and established workflows continue functioning identically without modification requirements</li> <li>Progressive Enhancement Adoption: Enable users to adopt multiple file functionality gradually without migration obligations or workflow disruption</li> <li>Consistent Behaviour Preservation: Single-file processing maintains identical output formatting, error handling, and operational characteristics</li> <li>Complete API Preservation: All existing CLI flags and configuration options operate unchanged with enhanced functionality integration</li> </ul>"},{"location":"usage/changelog/#enhanced-error-handling-and-user-experience","title":"\ud83d\udd27 Enhanced Error Handling and User Experience","text":"<p>Improve comprehensive user experience through sophisticated error reporting enhancements:</p> <ul> <li>Comprehensive Validation Reporting: Report all invalid paths simultaneously rather than terminating execution at first error encounter</li> <li>Rich Text Error Formatting: Enhanced error message presentation with structured bullet points and improved terminal readability</li> <li>Contextual Feedback Enhancement: Specific error messaging identifying precisely which paths are invalid with detailed location information</li> <li>Graceful Degradation Support: Continue processing valid paths effectively even when subset of paths are invalid or inaccessible</li> </ul>"},{"location":"usage/changelog/#usage-examples-and-integration-patterns_1","title":"\ud83d\udcc8 Usage Examples and Integration Patterns","text":"<p>The enhanced CLI architecture supports sophisticated multiple file processing workflows:</p> <pre><code># Comprehensive multi-file validation operations\ndfc file1.py file2.py file3.py                 # Multiple individual files\ndfc src/models.py tests/ docs/examples/         # Combination files and directories  \ndfc --exclude \"*/test_*\" src/ tests/integration/  # Multiple paths with exclusion patterns\ndfc --output=table file1.py src/utils/ tests/   # Different output formats with multiple sources\ndfc --quiet src/ tests/ examples/               # Quiet mode with comprehensive batch processing\ndfc --check src/models/ src/views/ src/controllers/  # Check flag with sophisticated batch operations\n</code></pre> <p>All established single-file usage patterns continue operating identically:</p> <pre><code># Preserved existing functionality patterns\ndfc myfile.py                                   # Single file validation\ndfc src/                                        # Single directory processing  \ndfc --check --quiet myfile.py                   # Combined flags with single file\ndfc --output=table --exclude \"*/test_*\" src/    # Complex single directory operations\n</code></pre>"},{"location":"usage/changelog/#technical-implementation-architecture","title":"\ud83d\udd0d Technical Implementation Architecture","text":""},{"location":"usage/changelog/#enhanced-architecture-design","title":"\ud83d\udcd0 Enhanced Architecture Design","text":"<p>The implementation maintains sophisticated separation of concerns across enhanced functionality:</p> <ul> <li>CLI Processing Layer: Enhanced argument parsing and comprehensive validation logic within <code>main()</code> function architecture</li> <li>Core Processing Layer: Updated <code>check_docstrings()</code> function supporting iterative path processing with sophisticated error isolation  </li> <li>Validation Architecture: Advanced comprehensive path validation with detailed error reporting and structured user feedback</li> <li>Result Management Layer: Sophisticated aggregation logic enabling seamless merging of validation results from diverse source types</li> </ul>"},{"location":"usage/changelog/#quality-assurance-excellence","title":"\ud83e\uddea Quality Assurance Excellence","text":"<p>Comprehensive testing framework ensures complete reliability across enhanced functionality:</p> <ul> <li>100% Test Coverage: Maintained complete test coverage across all enhanced modules and functionality areas</li> <li>173+ Total Tests: All existing test scenarios continue passing with 7 additional multiple file testing scenarios</li> <li>Integration Testing: Complete CLI integration testing utilising authentic command-line simulation across all operational patterns</li> <li>Edge Case Coverage: Comprehensive testing covering error conditions, mixed scenarios, and sophisticated usage patterns</li> </ul>"},{"location":"usage/changelog/#documentation-and-help-system-enhancement","title":"\ud83d\udcda Documentation and Help System Enhancement","text":"<p>Enhanced comprehensive help system and usage documentation:</p> <ul> <li>Updated Usage Examples: CLI help documentation includes comprehensive new multiple file usage pattern demonstrations  </li> <li>Improved Parameter Descriptions: Function and parameter descriptions updated accurately reflecting multiple path support capabilities</li> <li>Consistent Formatting: Help text formatting maintains established stylistic conventions whilst showcasing enhanced operational capabilities</li> </ul>"},{"location":"usage/changelog/#configuration-and-integration-support","title":"\ud83d\udd04 Configuration and Integration Support","text":"<p>Enhanced configuration system supporting multiple path operations:</p> <ul> <li>Automatic Configuration Discovery: Utilise first valid path for configuration file detection when explicit configuration not provided</li> <li>Consistent Configuration Application: Apply identical configuration rules across all processed paths ensuring uniform validation behaviour</li> <li>Exclusion Pattern Integration: Support sophisticated exclusion patterns across multiple paths enabling fine-grained control over validation scope</li> </ul>"},{"location":"usage/changelog/#whats-changed","title":"\ud83d\udcaa What's Changed","text":"<ul> <li>Enhance CLI with Multiple File Support and Workflow Optimisation by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/15</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/docstring-format-checker/compare/v1.1.0...v1.2.0</p> <p>Installation: <code>pip install docstring-format-checker==1.2.0</code> Multiple File Usage: <code>dfc file1.py file2.py src/ tests/</code> Documentation: Complete usage examples and configuration guides available Testing: 100% code coverage with comprehensive multiple file testing scenarios</p>"},{"location":"usage/changelog/#v110-enhance-cli-experience-with-ascii-art","title":"v1.1.0 - Enhance CLI Experience with ASCII Art","text":"<p><code>v1.1.0</code> <code>2025-10-05</code> data-science-extensions/docstring-format-checker/releases/v1.1.0</p> Release Notes Updates <ul> <li><code>cb4594b</code>: Replace colour helper functions with rich markup tags<ul> <li>Remove f-string formatting and use raw string literal for config example</li> <li>Replace <code>_blue()</code> and <code>_green()</code> function calls with rich markup syntax</li> <li>Standardise colour formatting to use <code>[blue]</code> and <code>[green]</code> tags throughout example</li> <li>Simplify template string handling by eliminating dynamic colour function invocations (by chrimaho)</li> </ul> </li> <li><code>1d080fe</code>: Clean up comments     Remove commented-out code. This appears to be leftover debugging code that should be cleaned up.     (by chrimaho)</li> <li><code>4f562e9</code>: Clean up <code>Exit()</code> calls in <code>if</code> blocks     Adding <code>Exit()</code> calls after each branch makes the control flow inconsistent with the existing pattern where the function handles all cases and exits at the end. Consider removing these individual <code>Exit()</code> calls and letting the function complete naturally, then add a single <code>Exit()</code> at the end.     (by chrimaho)</li> <li><code>d7e8315</code>: Fix formatting     (by chrimaho)</li> <li><code>e5a467d</code>: Drop Python 3.7-3.8 support and standardise CI setup<ul> <li>Remove Python 3.7 and 3.8 from CI test matrix to focus on actively supported versions</li> <li>Replace custom <code>uv python install</code> approach with standard <code>actions/setup-python@v5</code> action for better reliability</li> <li>Add explicit Python version verification step to ensure correct interpreter is used</li> <li>Clean up commented code in CI configuration for maintainability</li> <li>Import <code>sys</code> module in CLI module and improve code organisation with better spacing and comments</li> <li>Enhance help callback function structure for better readability and maintenance (by chrimaho)</li> </ul> </li> <li><code>a7f63ce</code>: Enhance CLI with ASCII banner and improve help output formatting<ul> <li>Add <code>pyfiglet</code> dependency to display ASCII art banner in help output</li> <li>Restructure help callback to show banner, standard help, usage examples, and configuration example in single command</li> <li>Update usage examples with improved formatting using colour-coded commands and comments</li> <li>Simplify configuration example format from nested TOML tables to inline array syntax</li> <li>Add explicit <code>raise Exit()</code> statements to example callbacks for proper command termination</li> <li>Remove standalone <code>if __name__ == \"__main__\"</code> execution block from CLI module</li> <li>Update test assertions to match new configuration example format and help output structure (by chrimaho)</li> </ul> </li> <li><code>33bfd55</code>: Fix uv command syntax in CD workflow<ul> <li>Remove <code>run</code> subcommand from <code>uv pip install</code> to correct command syntax</li> <li>Ensure package installation step uses proper uv CLI interface</li> <li>Prevent potential workflow failures due to invalid command structure (by chrimaho)</li> </ul> </li> <li><code>9d70d30</code>: Fix method numbering in the <code>test_cli</code> unit tests module     (by chrimaho)</li> </ul>"},{"location":"usage/changelog/#summary_2","title":"\ud83c\udfaf Summary","text":"<p>Introduce the definitive major release of <code>docstring-format-checker</code>, marking the complete evolution from initial concept to production-ready, enterprise-grade Python CLI tool. This comprehensive release represents the culmination of intensive development spanning 189 commits, 14 merged pull requests, and 13 iterative releases, delivering the most sophisticated Python docstring validation solution available today.</p> <p>Transform from basic validation concept to industry-leading tool with advanced ASCII art CLI experience, comprehensive configuration management, robust cross-platform compatibility, and modern Python ecosystem integration. Establish <code>docstring-format-checker</code> as the authoritative solution for Python documentation quality assurance, combining powerful validation capabilities with exceptional user experience and professional-grade tooling.</p> <p>Complete Feature Set:</p> <ul> <li>Dynamic ASCII Art CLI: Intelligent terminal width adaptation with professional <code>pyfiglet</code> banners</li> <li>Advanced AST Parsing: Robust code analysis without regex fragility across all Python constructs  </li> <li>Sophisticated Configuration: Four distinct section types with hierarchical TOML-based discovery</li> <li>Rich Terminal Experience: Beautiful coloured output with structured error tables and panels</li> <li>Modern Python Integration: Contemporary version management with <code>importlib.metadata</code> and UV packaging</li> <li>Comprehensive Testing: 166 tests achieving 100% code coverage across Windows, macOS, and Linux</li> <li>Professional Documentation: Complete user guides, API documentation, and configuration examples</li> </ul>"},{"location":"usage/changelog/#complete-architecture-overview","title":"\ud83d\ude80 Complete Architecture Overview","text":""},{"location":"usage/changelog/#core-validation-engine-evolution","title":"\ud83c\udfd7\ufe0f Core Validation Engine Evolution","text":"<p>Establish the most sophisticated docstring validation system available in the Python ecosystem:</p> <ul> <li><code>DocstringChecker()</code>: Advanced validation engine with comprehensive rule enforcement and error reporting</li> <li><code>FunctionAndClassDetails()</code>: Structured representation of code elements for precise analysis and validation</li> <li>Enhanced AST Integration: Robust parsing supporting functions, methods, classes, async functions, and <code>@overload</code> decorators</li> <li>Multi-Format Support: Intelligent handling of diverse Python code patterns with consistent validation behaviour  </li> <li>Advanced Error Detection: Sophisticated validation logic for admonitions, section ordering, parameter matching, and content structure</li> </ul> <p>Complete Validation Rule System:</p> <pre><code>VALID_TYPES = (\n    \"free_text\",          # Summary, details, examples, notes with admonition support\n    \"list_name\",          # Simple name sections with basic validation  \n    \"list_type\",          # Type-only sections (raises, yields) with parentheses checking\n    \"list_name_and_type\", # Parameter-style sections with comprehensive validation\n)\n</code></pre>"},{"location":"usage/changelog/#advanced-configuration-management","title":"\u2699\ufe0f Advanced Configuration Management","text":"<p>Implement the most flexible configuration system in Python documentation tooling:</p> <ul> <li><code>Config()</code>: Comprehensive configuration container with global settings and section definitions</li> <li><code>SectionConfig()</code>: Individual section configuration with validation rules, admonition support, and customisation options</li> <li><code>GlobalConfig()</code>: Global validation behaviour control with <code>allow_undefined_sections</code>, <code>require_docstrings</code>, and <code>check_private</code> flags</li> <li>Hierarchical Discovery: Intelligent search for <code>pyproject.toml</code> configuration files up directory trees</li> <li>Validation Enforcement: Strict configuration validation with comprehensive error reporting and helpful suggestions</li> </ul> <p>Advanced Configuration Architecture:</p> <pre><code>[tool.dfc]  # or [tool.docstring-format-checker]\nallow_undefined_sections = false\nrequire_docstrings = true  \ncheck_private = true\n\nsections = [\n    { order = 1, name = \"summary\",  type = \"free_text\",          required = true, admonition = \"note\", prefix = \"!!!\" },\n    { order = 2, name = \"details\",  type = \"free_text\",          required = false, admonition = \"abstract\", prefix = \"???+\" },\n    { order = 3, name = \"params\",   type = \"list_name_and_type\", required = false },\n    { order = 4, name = \"raises\",   type = \"list_type\",          required = false },\n    { order = 5, name = \"returns\",  type = \"list_name_and_type\", required = false },\n    { order = 6, name = \"yields\",   type = \"list_type\",          required = false },\n    { order = 7, name = \"examples\", type = \"free_text\",          required = false, admonition = \"example\", prefix = \"???+\" },\n    { order = 8, name = \"notes\",    type = \"free_text\",          required = false, admonition = \"note\", prefix = \"???\" },\n]\n</code></pre>"},{"location":"usage/changelog/#revolutionary-cli-experience","title":"\ud83c\udfa8 Revolutionary CLI Experience","text":"<p>Deliver the most advanced CLI experience in Python development tooling:</p> <ul> <li>Dynamic ASCII Art Integration: Professional <code>pyfiglet</code> banner generation with intelligent terminal width adaptation (130-column threshold)</li> <li>Rich Terminal Output: Sophisticated coloured output using Rich library with structured error tables, panels, and professional formatting</li> <li>Dual Entry Points: Both <code>docstring-format-checker</code> and <code>dfc</code> commands with identical functionality for flexibility</li> <li>Comprehensive Help System: Integrated help display combining ASCII banners, standard help, usage examples, and configuration guidance</li> <li>Advanced Output Modes: Multiple output formats (<code>table</code>, <code>list</code>) with quiet modes and structured exit codes for diverse workflow integration</li> </ul> <p>Complete CLI Capabilities:</p> <pre><code># Multiple invocation methods with rich features\ndfc check src/                          # Check directory with ASCII art help\ndocstring-format-checker check file.py  # Full command name\ndfc check --output table --quiet src/   # Customised output formats  \ndfc config-example                      # Generate comprehensive configuration\ndfc --help                              # Dynamic ASCII art with complete guidance\n</code></pre>"},{"location":"usage/changelog/#visual-experience-transformation","title":"\ud83c\udfad Visual Experience Transformation","text":""},{"location":"usage/changelog/#dynamic-ascii-art-system","title":"\ud83d\udda5\ufe0f Dynamic ASCII Art System","text":"<p>Revolutionise CLI aesthetics with intelligent ASCII art adaptation:</p> <ul> <li>Terminal Width Intelligence: Dynamic selection between compact <code>dfc</code> (&lt; 130 columns) and full <code>docstring-format-checker</code> (\u2265 130 columns) banners</li> <li>Professional Typography: Industry-standard <code>pyfiglet</code> integration with consistent magenta styling and proper markup handling</li> <li>Cross-Platform Compatibility: Robust terminal size detection with fallback mechanisms for test environments and CI systems</li> <li>Integrated Help Experience: Seamless combination of ASCII banners with Rich-formatted help panels and examples</li> </ul> <p>ASCII Art Display Examples:</p> <p>Narrow Terminal (&lt; 130 columns):</p> <pre><code>     _  __      \n  __| |/ _| ___ \n / _` | |_ / __|\n| (_| |  _| (__ \n \\__,_|_|  \\___|\n</code></pre> <p>Wide Terminal (\u2265 130 columns): </p> <pre><code>     _                _        _                    __                            _             _               _             \n  __| | ___   ___ ___| |_ _ __(_)_ __   __ _       / _| ___  _ __ _ __ ___   __ _| |_       ___| |__   ___  ___| | _____ _ __ \n / _` |/ _ \\ / __/ __| __| '__| | '_ \\ / _` |_____| |_ / _ \\| '__| '_ ` _ \\ / _` | __|____ / __| '_ \\ / _ \\/ __| |/ / _ \\ '__|\n| (_| | (_) | (__\\__ \\ |_| |  | | | | | (_| |_____|  _| (_) | |  | | | | | | (_| | ||_____| (__| | | |  __/ (__|   &lt;  __/ |   \n \\__,_|\\___/ \\___|___/\\__|_|  |_|_| |_|\\__, |     |_|  \\___/|_|  |_| |_| |_|\\__,_|\\__|     \\___|_| |_|\\___|\\___|_|\\_\\___|_|   \n                                       |___/                                                                                  \n</code></pre>"},{"location":"usage/changelog/#enhanced-user-interface-elements","title":"\ud83d\udcda Enhanced User Interface Elements","text":"<p>Deliver comprehensive interface improvements across all user touchpoints:</p> <ul> <li>Rich Panel Integration: Professional bordered sections for arguments, options, examples, and configuration with consistent styling</li> <li>Colour-Coded Examples: Enhanced usage examples with syntax highlighting and descriptive comments for improved comprehension</li> <li>Configuration Modernisation: Streamlined configuration examples with inline array syntax replacing nested TOML tables</li> <li>Error Message Enhancement: Structured error reporting with file paths, line numbers, function names, and detailed descriptions</li> </ul>"},{"location":"usage/changelog/#modern-python-ecosystem-integration","title":"\ud83d\udc0d Modern Python Ecosystem Integration","text":""},{"location":"usage/changelog/#contemporary-packaging-standards","title":"\ud83d\udce6 Contemporary Packaging Standards","text":"<p>Embrace modern Python packaging practices with industry-leading approaches:</p> <ul> <li>Dynamic Version Management: Complete migration from hardcoded versions to <code>importlib.metadata</code> runtime detection</li> <li>UV Integration: Native UV package manager support with modern dependency resolution and version management</li> <li>Semantic Versioning Alignment: Standardised version format without legacy prefixes (<code>1.1.0</code> vs <code>v1.1.0</code>)</li> <li>Python Version Strategy: Focused support for actively maintained Python versions (3.9-3.13) with dropped legacy support</li> <li>Build System Modernisation: Latest <code>uv_build</code> integration with contemporary packaging workflows</li> </ul> <p>Enhanced Package Metadata:</p> <pre><code># src/docstring_format_checker/__init__.py - Modern approach\nfrom importlib.metadata import metadata\n\n_metadata = metadata(\"docstring-format-checker\")\n__name__: str = _metadata[\"Name\"]\n__version__: str = _metadata[\"Version\"]  \n__author__: str = _metadata[\"Author\"]\n__email__: str = _metadata.get(\"Email\", \"\")\n</code></pre>"},{"location":"usage/changelog/#infrastructure-modernisation","title":"\ud83c\udfd7\ufe0f Infrastructure Modernisation","text":"<p>Implement contemporary development infrastructure with professional-grade tooling:</p> <ul> <li>GitHub Actions Integration: Latest <code>actions/setup-python@v5</code> with official UV setup actions for enhanced reliability</li> <li>Dependency Strategy: Modern dependency management with <code>pyfiglet&gt;=1.0.1</code> for ASCII art, updated development tools</li> <li>Documentation Hosting: Dedicated website integration at <code>data-science-extensions.com</code> replacing README-based documentation  </li> <li>CI/CD Excellence: Comprehensive testing matrix across platforms with automated coverage reporting and quality gates</li> </ul>"},{"location":"usage/changelog/#comprehensive-testing-excellence","title":"\ud83e\uddea Comprehensive Testing Excellence","text":""},{"location":"usage/changelog/#test-suite-sophistication","title":"\ud83d\udd2c Test Suite Sophistication","text":"<p>Achieve industry-leading test coverage with advanced testing strategies:</p> <ul> <li>100% Code Coverage: Complete test coverage across 166 test cases with comprehensive edge case validation</li> <li>Cross-Platform Reliability: Robust testing across Windows, macOS, and Linux with platform-specific compatibility handling</li> <li>CLI Integration Testing: Comprehensive testing of ASCII art generation, help system integration, and terminal compatibility</li> <li>Configuration Validation: Extensive testing of TOML configuration parsing, validation rules, and error handling</li> <li>Terminal Compatibility: Advanced testing of terminal size detection, ASCII art adaptation, and Rich output formatting</li> </ul> <p>Test Infrastructure Enhancements:</p> <ul> <li>OSError Handling: Robust terminal size detection testing with fallback mechanism validation</li> <li>ASCII Art Integration: Comprehensive testing of <code>pyfiglet</code> integration and title selection logic</li> <li>Rich Output Validation: Structured testing of panel formatting, colour output, and markup handling</li> <li>Configuration Format Testing: Updated assertions matching streamlined inline array syntax</li> </ul>"},{"location":"usage/changelog/#quality-assurance-standards","title":"\ud83d\udcca Quality Assurance Standards","text":"<p>Maintain exceptional code quality through comprehensive validation:</p> <ul> <li>Type Safety: Complete type hint coverage with <code>mypy</code> validation across all modules</li> <li>Code Formatting: Consistent <code>black</code> formatting with 120-character line length standards</li> <li>Import Organisation: Structured import management with <code>isort</code> integration and clear separation patterns</li> <li>Linting Excellence: Comprehensive <code>pylint</code> validation with high code quality standards</li> <li>Pre-commit Integration: Automated quality checks with <code>pre-commit</code> hooks for consistent standards</li> </ul>"},{"location":"usage/changelog/#development-evolution-timeline","title":"\ud83d\udd04 Development Evolution Timeline","text":""},{"location":"usage/changelog/#release-progression","title":"\ud83d\udcc8 Release Progression","text":"<p>Chronicle the complete development journey through systematic releases:</p> <p>Foundation Releases (v0.1.0 - v0.4.0):</p> <ul> <li>v0.1.0: Initial CLI framework with basic validation capabilities and foundational architecture</li> <li>v0.2.0: <code>@overload</code> function support and enhanced parsing capabilities  </li> <li>v0.3.0: Advanced validation logic with colon usage, title case, and parentheses checking</li> <li>v0.4.0: CLI enhancement with example flags, recursive improvements, and expanded test coverage</li> </ul> <p>Enhancement Releases (v0.5.0 - v0.8.0):</p> <ul> <li>v0.5.0: Output format improvements and summary statistics integration</li> <li>v0.6.0: List type section validation fixes and error reporting enhancements</li> <li>v0.7.0: List section validation improvements and parameter parsing sophistication</li> <li>v0.8.0: Global configuration system with <code>allow_undefined_sections</code>, <code>require_docstrings</code>, and <code>check_private</code> flags</li> </ul> <p>Maturity Releases (v0.9.0 - v1.0.1):</p> <ul> <li>v0.9.0: CI/CD modernisation and test reliability improvements with cross-platform compatibility</li> <li>v0.10.0: Windows CI issue resolution and platform-specific assertion handling</li> <li>v0.11.0: Documentation standardisation and test environment isolation</li> <li>v1.0.0: First major release with complete feature set and production readiness</li> <li>v1.0.1: Version management modernisation with <code>importlib.metadata</code> integration</li> <li>v1.1.0: Enhanced CLI Experience with ASCII Art and Modernise Python Support</li> </ul>"},{"location":"usage/changelog/#current-release-v110","title":"\ud83c\udfc6 Current Release (v1.1.0):","text":"<p>Revolutionary CLI Experience:</p> <ul> <li>ASCII Art Integration: Dynamic <code>pyfiglet</code> banners with terminal width adaptation</li> <li>Rich Output Enhancement: Professional panels, colour coding, and structured formatting  </li> <li>Help System Consolidation: Integrated help display with examples and configuration guidance</li> <li>Python Version Modernisation: Contemporary Python 3.9+ support with legacy version removal</li> </ul>"},{"location":"usage/changelog/#complete-user-impact","title":"\ud83c\udf89 Complete User Impact","text":""},{"location":"usage/changelog/#immediate-benefits","title":"\ud83d\ude80 Immediate Benefits","text":"<p>Transform development workflows with comprehensive improvements:</p> <ul> <li>Professional Tool Identity: Memorable ASCII art creates distinctive, professional CLI experience  </li> <li>Enhanced Productivity: Integrated help system reduces documentation lookup time and improves workflow efficiency</li> <li>Modern Ecosystem Alignment: Contemporary Python version support ensures compatibility with current development tools</li> <li>Comprehensive Validation: Advanced AST parsing provides reliable docstring validation without regex limitations</li> <li>Cross-Platform Reliability: Robust testing ensures consistent behaviour across all major operating systems</li> </ul>"},{"location":"usage/changelog/#long-term-value","title":"\ud83c\udf1f Long-term Value","text":"<p>Establish foundation for sustained development excellence:</p> <ul> <li>Community Adoption: Professional appearance and comprehensive documentation encourage wider adoption across Python community</li> <li>Maintainability Excellence: Simplified configuration examples and modern tooling reduce maintenance overhead  </li> <li>Extensibility Foundation: Enhanced CLI architecture and modern packaging provide platform for future feature development</li> <li>Quality Assurance: Comprehensive validation capabilities ensure consistent documentation standards across large codebases</li> <li>Ecosystem Integration: Modern Python version support and UV integration ensure compatibility with contemporary development workflows</li> </ul>"},{"location":"usage/changelog/#development-impact","title":"\ud83d\udcca Development Impact","text":"<p>Deliver measurable improvements to development processes:</p> <ul> <li>Documentation Quality: Systematic validation ensures consistent, high-quality documentation across entire codebases</li> <li>Developer Experience: Rich terminal output and comprehensive help reduce learning curve and improve adoption</li> <li>CI/CD Integration: Multiple output formats and structured exit codes enable seamless automation workflows  </li> <li>Configuration Flexibility: Hierarchical configuration discovery and comprehensive customisation support diverse project requirements</li> <li>Error Resolution: Detailed error reporting with file paths, line numbers, and specific validation failures accelerates issue resolution</li> </ul>"},{"location":"usage/changelog/#project-maturity","title":"\ud83d\udd2e Project Maturity","text":"<p>Complete Statistics:</p> <ul> <li>189 Total Commits: Comprehensive development history with systematic improvements</li> <li>14 Merged Pull Requests: Structured feature development with thorough review processes  </li> <li>13 Released Versions: Systematic release progression with clear version management</li> <li>166 Test Cases: Comprehensive test coverage ensuring reliability and quality</li> <li>100% Code Coverage: Complete validation of all code paths and edge cases</li> <li>3 Platform Support: Robust cross-platform compatibility (Windows, macOS, Linux)</li> <li>4 Section Types: Comprehensive validation rule system supporting diverse documentation patterns</li> </ul>"},{"location":"usage/changelog/#pull-requests_1","title":"\ud83d\udcaa Pull Requests","text":"<ul> <li>Enhance CLI Experience with ASCII Art and Modernise Python Support by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/14</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/docstring-format-checker/compare/v1.0.1...v1.1.0</p> <p>Transform <code>docstring-format-checker</code> from conceptual tool to industry-leading Python documentation validation solution, establishing the definitive standard for Python docstring quality assurance with unmatched user experience, comprehensive validation capabilities, and modern Python ecosystem integration.</p>"},{"location":"usage/changelog/#v101-modernise-version-management","title":"v1.0.1 - Modernise Version Management","text":"<p><code>v1.0.1</code> <code>2025-10-04</code> data-science-extensions/docstring-format-checker/releases/v1.0.1</p> Release Notes Updates <ul> <li><code>d297f97</code>: Fix bug     (by chrimaho)</li> <li><code>02c6733</code>: Remove <code>PackageMetadata</code> from <code>__init__.py</code> module     (by chrimaho)</li> <li><code>1185961</code>: Add GitHub Copilot instructions to gitignore<ul> <li>Exclude <code>.github/copilot-instructions.md</code> from version control</li> <li>Prevent accidental commits of AI assistant configuration files</li> <li>Maintain clean repository by ignoring environment-specific settings (by chrimaho)</li> </ul> </li> <li><code>acaf276</code>: Modernise GitHub Actions workflow to use official UV setup action<ul> <li>Replace manual UV installation script with official <code>astral-sh/setup-uv@v6</code> action</li> <li>Reorder steps to set up UV before Python for better dependency management</li> <li>Remove redundant Python setup action since UV handles Python installation</li> <li>Simplify workflow by leveraging UV's built-in Python management capabilities (by chrimaho)</li> </ul> </li> <li><code>893d284</code>: Fix failing Unit Tests     (by chrimaho)</li> </ul>"},{"location":"usage/changelog/#summary_3","title":"\ud83c\udfaf Summary","text":"<p>Introduce the inaugural major release of <code>docstring-format-checker</code>, a comprehensive Python CLI tool that validates docstring formatting and completeness using AST parsing. This milestone release represents the culmination of extensive development spanning 12 minor versions, 12 major pull requests, and countless iterative improvements, delivering a production-ready solution for ensuring consistent, high-quality documentation across Python codebases.</p> <p>Transform from initial concept to enterprise-grade tool with configurable validation rules, rich terminal output, comprehensive test coverage, and robust cross-platform compatibility. Establish <code>docstring-format-checker</code> as the definitive solution for Python docstring validation, offering flexibility for diverse documentation standards whilst maintaining strict quality enforcement.</p> <p>Core Capabilities: - AST-Based Parsing: Robust code analysis without regex fragility - Configurable Validation: Four distinct section types with TOML-based configuration - Cross-Platform Reliability: 100% test coverage across Windows, macOS, and Linux - Rich Terminal Output: Beautiful coloured output with structured error tables - Dual CLI Entry Points: Accessible via <code>docstring-format-checker</code> or <code>dfc</code> commands - Modern Packaging: Dynamic version management with <code>importlib.metadata</code> integration</p>"},{"location":"usage/changelog/#foundational-architecture","title":"\ud83d\ude80 Foundational Architecture","text":""},{"location":"usage/changelog/#core-validation-engine","title":"\ud83c\udfd7\ufe0f Core Validation Engine","text":"<p>Establish a sophisticated docstring validation system built on Python AST parsing:</p> <ul> <li><code>DocstringChecker()</code>: Primary validation engine with comprehensive rule enforcement</li> <li><code>FunctionAndClassDetails()</code>: Structured representation of code elements for precise analysis</li> <li>AST Integration: Robust parsing of Python source files without dependency on fragile regex patterns</li> <li>Multi-Format Support: Handle functions, methods, classes, and async functions uniformly</li> <li>Overload Detection: Intelligent handling of <code>@overload</code> decorated functions to avoid duplicate validation</li> </ul> <p>Validation Rule Categories: <pre><code>VALID_TYPES = (\n    \"free_text\",        # Summary, details, examples, notes\n    \"list_name\",        # Simple name sections\n    \"list_type\",        # Type-only sections (raises, yields)\n    \"list_name_and_type\",  # Parameter-style sections with descriptions\n)\n</code></pre></p>"},{"location":"usage/changelog/#configuration-management-system","title":"\u2699\ufe0f Configuration Management System","text":"<p>Implement hierarchical configuration discovery with TOML-based section definitions:</p> <ul> <li><code>Config()</code>: Top-level configuration container with global settings and section definitions</li> <li><code>SectionConfig()</code>: Individual section configuration with validation rules and admonition support</li> <li><code>GlobalConfig()</code>: Global validation behaviour control flags</li> <li>Automatic Discovery: Hierarchical search for <code>pyproject.toml</code> configuration files up directory tree</li> <li>Validation Enforcement: Strict configuration validation with comprehensive error reporting</li> </ul> <p>Configuration Architecture: <pre><code>[tool.dfc]  # or [tool.docstring-format-checker]\n\n[[tool.dfc.sections]]\norder = 1\nname = \"summary\"\ntype = \"free_text\"\nadmonition = \"note\"\nrequired = true\n\n[[tool.dfc.sections]]\norder = 2\nname = \"params\"\ntype = \"list_name_and_type\"\nrequired = true\n</code></pre></p>"},{"location":"usage/changelog/#rich-cli-interface","title":"\ud83d\udda5\ufe0f Rich CLI Interface","text":"<p>Deliver an intuitive command-line interface with comprehensive functionality:</p> <ul> <li>Dual Entry Points: Both <code>docstring-format-checker</code> and <code>dfc</code> commands for flexibility</li> <li>Rich Output Formatting: Coloured terminal output with structured error tables and panels</li> <li>Multiple Output Formats: Support for both <code>table</code> and <code>list</code> display formats</li> <li>Comprehensive Help: Built-in examples, configuration generation, and detailed usage instructions</li> <li>Error Handling: Graceful error reporting with structured exit codes</li> </ul> <p>CLI Features: <pre><code># Multiple invocation methods\ndfc check src/                           # Check directory\ndocstring-format-checker check file.py   # Check single file\ndfc config-example                       # Generate example configuration\ndfc check --output table --quiet src/    # Customised output\n</code></pre></p>"},{"location":"usage/changelog/#development-evolution","title":"\ud83d\udd27 Development Evolution","text":""},{"location":"usage/changelog/#version-management-modernisation","title":"\ud83d\udce6 Version Management Modernisation","text":"<p>Replace custom version management with industry-standard approaches:</p> <ul> <li>Remove Custom Scripts: Eliminate 149-line <code>bump_version.py</code> script in favour of native UV commands</li> <li>Dynamic Metadata Integration: Leverage <code>importlib.metadata</code> for runtime version detection from <code>pyproject.toml</code></li> <li>Single Source Truth: Centralise all package metadata exclusively in <code>pyproject.toml</code></li> <li>Automatic Synchronisation: Ensure version consistency without manual intervention across all modules</li> </ul> <p>Enhanced Package Initialisation: <pre><code># src/docstring_format_checker/__init__.py\nfrom importlib.metadata import metadata\n\n_metadata = metadata(\"docstring-format-checker\")\n__version__: str = _metadata[\"Version\"]  # Dynamic from pyproject.toml\n__author__: str = _metadata[\"Author\"]\n__email__: str = _metadata.get(\"Email\", \"\")\n</code></pre></p>"},{"location":"usage/changelog/#cicd-infrastructure-enhancement","title":"\ud83d\udd27 CI/CD Infrastructure Enhancement","text":"<p>Modernise continuous integration and deployment workflows:</p> <ul> <li>Official UV GitHub Action: Replace manual UV installation with <code>astral-sh/setup-uv@v6</code> action</li> <li>Streamlined Dependency Management: Let UV handle Python installation and dependency resolution</li> <li>Native Version Bumping: Use <code>uv version</code> command instead of custom Python scripts</li> <li>Improved Workflow Efficiency: Reduce CI execution time and improve reliability</li> </ul> <p>GitHub Actions Modernisation: <pre><code># .github/workflows/cd.yml\n- name: Setup UV\n  uses: astral-sh/setup-uv@v6\n\n- name: Bump version\n  run: uv version --project-root . patch\n</code></pre></p>"},{"location":"usage/changelog/#comprehensive-test-suite","title":"\ud83e\uddea Comprehensive Test Suite","text":"<p>Achieve 100% test coverage with robust validation:</p> <ul> <li>167 Test Cases: Comprehensive coverage across all modules and edge cases</li> <li>Cross-Platform Compatibility: Validated across Windows, macOS, and Linux environments</li> <li>CLI Testing: Thorough validation of command-line interface with <code>typer.testing.CliRunner</code></li> <li>Configuration Testing: Extensive TOML configuration validation and error handling</li> <li>AST Parsing Tests: Complete validation of Python code analysis functionality</li> </ul> <p>Coverage Breakdown: <pre><code>src/docstring_format_checker/__init__.py:      100%\nsrc/docstring_format_checker/cli.py:           100%\nsrc/docstring_format_checker/config.py:        100%\nsrc/docstring_format_checker/core.py:          100%\nsrc/docstring_format_checker/utils/exceptions.py: 100%\n------------------------------------------------------\nTOTAL COVERAGE:                                100%\n</code></pre></p>"},{"location":"usage/changelog/#feature-completeness","title":"\ud83d\udccb Feature Completeness","text":""},{"location":"usage/changelog/#advanced-validation-rules","title":"\ud83d\udd0d Advanced Validation Rules","text":"<p>Implement comprehensive docstring validation logic:</p> <ul> <li>Section Detection: Intelligent parsing of docstring sections with admonition support</li> <li>Title Case Validation: Ensure proper capitalisation of section headers</li> <li>Colon Usage Checks: Validate proper punctuation in section definitions</li> <li>Parentheses Validation: Check type annotations and parameter formatting</li> <li>Blank Line Requirements: Enforce proper spacing and structure</li> <li>Type Annotation Validation: Comprehensive parameter and return type checking</li> </ul> <p>Validation Categories: <pre><code># Section validation types with specific rules\n\"free_text\": {\n    \"admonition_support\": True,\n    \"content_validation\": \"flexible\",\n    \"examples\": [\"summary\", \"details\", \"examples\", \"notes\"]\n}\n\"list_name_and_type\": {\n    \"parameter_parsing\": True,\n    \"type_validation\": True,\n    \"examples\": [\"params\", \"returns\", \"attributes\"]\n}\n</code></pre></p>"},{"location":"usage/changelog/#configuration-flexibility","title":"\ud83d\udee0\ufe0f Configuration Flexibility","text":"<p>Provide extensive customisation options:</p> <ul> <li>Four Section Types: Support for all common docstring patterns and formats</li> <li>Admonition Integration: Rich admonition support with customisable prefixes</li> <li>Global Configuration: Workspace-wide settings for consistent validation</li> <li>Section Ordering: Enforce specific section order with configurable priorities</li> <li>Required vs Optional: Flexible enforcement of mandatory and optional sections</li> </ul> <p>Advanced Configuration: <pre><code>[tool.dfc.global]\nrequire_docstrings = true\ncheck_class_docstrings = true\ncheck_method_docstrings = true\ncheck_function_docstrings = true\n\n[[tool.dfc.sections]]\norder = 1\nname = \"summary\"\ntype = \"free_text\"\nadmonition = \"note\"\nprefix = \"!!!\"\nrequired = true\n</code></pre></p>"},{"location":"usage/changelog/#rich-output-formatting","title":"\ud83d\udcca Rich Output Formatting","text":"<p>Deliver beautiful, informative terminal output:</p> <ul> <li>Structured Error Reporting: Clear, actionable error messages with file and line references  </li> <li>Progress Indicators: Visual feedback during directory scanning and validation</li> <li>Summary Statistics: Comprehensive success/failure rates and file counts</li> <li>Colour-Coded Results: Green for success, red for errors, with emoji indicators</li> <li>Table and List Formats: Multiple display options for different terminal preferences</li> </ul> <p>Example Output: <pre><code>\ud83d\udccb Docstring Format Checker Results\n\n\u2705 src/utils/helpers.py\n\u274c src/models/user.py\n   \u2514\u2500\u2500 Function 'create_user' missing required section: 'params'\n   \u2514\u2500\u2500 Function 'delete_user' missing required section: 'returns'\n\n\ud83d\udcca Summary: 1/3 files passed (33.3%)\n</code></pre></p>"},{"location":"usage/changelog/#technical-excellence","title":"\ud83c\udfc6 Technical Excellence","text":""},{"location":"usage/changelog/#code-quality-standards","title":"\ud83c\udfaf Code Quality Standards","text":"<p>Maintain exceptional code quality with comprehensive validation:</p> <ul> <li>Type Safety: Complete type hint coverage with dataclass-based configuration</li> <li>Import Organisation: Consistent three-tier import structure (stdlib, third-party, local)</li> <li>Error Handling: Comprehensive exception hierarchy with structured error messages</li> <li>Code Organisation: Modular architecture with clear separation of concerns</li> <li>Documentation: Enhanced docstrings following project standards across all modules</li> </ul> <p>Module Structure: <pre><code># Consistent import organisation\n# ### Python StdLib Imports ----\nimport ast\nfrom pathlib import Path\n\n# ### Python Third Party Imports ----\nimport typer\nfrom rich.console import Console\n\n# ### Local First Party Imports ----\nfrom docstring_format_checker.config import load_config\n</code></pre></p>"},{"location":"usage/changelog/#performance-optimisation","title":"\ud83d\ude80 Performance Optimisation","text":"<p>Deliver efficient validation with optimised processing:</p> <ul> <li>AST Parsing: Efficient code analysis with minimal memory overhead</li> <li>File Processing: Optimised directory traversal with glob pattern matching</li> <li>Error Reporting: Structured error collection with minimal performance impact</li> <li>Configuration Caching: Cached configuration parsing for repeated operations</li> <li>Lazy Loading: On-demand module loading to reduce startup time</li> </ul>"},{"location":"usage/changelog/#robust-error-handling","title":"\ud83d\udd10 Robust Error Handling","text":"<p>Implement comprehensive error management:</p> <ul> <li>Custom Exception Hierarchy: Structured exceptions for different failure scenarios</li> <li>Graceful Degradation: Intelligent handling of malformed files and configurations</li> <li>User-Friendly Messages: Clear, actionable error descriptions with remediation suggestions</li> <li>Exit Code Management: Proper CLI exit codes for integration with CI/CD systems</li> <li>Validation Failures: Detailed reporting of docstring validation errors</li> </ul>"},{"location":"usage/changelog/#documentation-and-examples","title":"\ud83d\udcda Documentation and Examples","text":""},{"location":"usage/changelog/#comprehensive-documentation","title":"\ud83d\udcd6 Comprehensive Documentation","text":"<p>Provide extensive documentation and usage examples:</p> <ul> <li>API Documentation: Complete module documentation with examples</li> <li>Configuration Guide: Detailed configuration options with real-world examples</li> <li>Usage Examples: Practical examples for common use cases</li> <li>Integration Guide: Instructions for CI/CD integration and pre-commit hooks</li> <li>Architecture Overview: Detailed explanation of tool internals and design decisions</li> </ul>"},{"location":"usage/changelog/#example-configurations","title":"\ud83c\udfaf Example Configurations","text":"<p>Include practical configuration templates:</p> <ul> <li>Default Configuration: Production-ready configuration for most projects</li> <li>Minimal Configuration: Lightweight setup for simple projects</li> <li>Advanced Configuration: Comprehensive setup with all features enabled</li> <li>Framework-Specific: Tailored configurations for popular Python frameworks</li> </ul> <p>Configuration Examples: <pre><code># Simple configuration\n[tool.dfc]\n[[tool.dfc.sections]]\norder = 1\nname = \"summary\"\ntype = \"free_text\"\nrequired = true\n\n# Advanced configuration with admonitions\n[[tool.dfc.sections]]\norder = 2\nname = \"details\"\ntype = \"free_text\"\nadmonition = \"abstract\"\nprefix = \"???\"\nrequired = false\n</code></pre></p>"},{"location":"usage/changelog/#release-highlights","title":"\ud83c\udf8a Release Highlights","text":""},{"location":"usage/changelog/#first-major-release","title":"\u2728 First Major Release","text":"<p>Mark the transition to stable, production-ready status:</p> <ul> <li>Semantic Versioning: Adopt semantic versioning with v1.0.1 marking API stability</li> <li>Production Readiness: Comprehensive testing and validation across all supported platforms</li> <li>Backward Compatibility: Commitment to maintaining API compatibility in future releases</li> <li>Enterprise Grade: Suitable for large-scale projects and enterprise environments</li> </ul> <p>Development Timeline: - 12 Version Releases: From v0.1.0 through v1.0.0 with iterative improvements - 12 Pull Requests: Systematic feature development and bug fixes - 100% Test Coverage: Comprehensive validation across all code paths - Cross-Platform Support: Validated on Windows, macOS, and Linux</p>"},{"location":"usage/changelog/#continuous-evolution","title":"\ud83d\udd04 Continuous Evolution","text":"<p>Establish foundation for continued development:</p> <ul> <li>Modular Architecture: Clean separation enabling easy feature additions</li> <li>Extensible Configuration: Framework for adding new validation rules</li> <li>Rich Plugin System: Foundation for third-party extensions</li> <li>Community Contributions: Clear contribution guidelines and development workflows</li> </ul>"},{"location":"usage/changelog/#getting-started","title":"\ud83d\ude80 Getting Started","text":"<p>Begin using <code>docstring-format-checker</code> immediately:</p> <pre><code># Install with UV\nuv add docstring-format-checker\n\n# Quick start - check a file\ndfc check my_module.py\n\n# Check entire project\ndfc check src/\n\n# Generate configuration template\ndfc config-example\n\n# Advanced usage with custom configuration\ndfc check --config pyproject.toml --output table --quiet src/\n</code></pre>"},{"location":"usage/changelog/#next-steps","title":"\ud83c\udfaf Next Steps","text":"<p>Continue enhancing your documentation workflow:</p> <ol> <li>Generate Configuration: Use <code>dfc config-example</code> to create project-specific rules</li> <li>CI Integration: Add docstring validation to continuous integration workflows  </li> <li>Pre-commit Hooks: Enforce validation before code commits</li> <li>Team Standards: Establish consistent documentation standards across your team</li> <li>Advanced Features: Explore custom section types and validation rules</li> </ol> <p>CI Integration Example: <pre><code># .github/workflows/test.yml\n- name: Check docstrings\n  run: dfc check src/ --check\n</code></pre></p> <p>Transform your Python project's documentation quality with <code>docstring-format-checker</code> v1.0.1 \u2013 the comprehensive, configurable, and reliable solution for docstring validation and enforcement.</p>"},{"location":"usage/changelog/#pull-requests_2","title":"\ud83d\udcaa Pull Requests","text":"<ul> <li>Modernise Version Management and GitHub Actions Integration by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/12</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/docstring-format-checker/compare/v1.0.0...v1.0.1</p>"},{"location":"usage/changelog/#v100-first-major-release","title":"v1.0.0 - First Major Release","text":"<p><code>v1.0.0</code> <code>2025-09-10</code> data-science-extensions/docstring-format-checker/releases/v1.0.0</p> Release Notes Updates <ul> <li><code>064a905</code>: Fix typo     (by chrimaho)</li> </ul>"},{"location":"usage/changelog/#summary_4","title":"\ud83c\udfaf Summary","text":"<p>Introduce the inaugural major release of <code>docstring-format-checker</code>, a powerful Python CLI tool that validates docstring formatting and completeness using AST parsing. This milestone release represents the culmination of comprehensive development spanning 11 minor versions and 11 major pull requests, delivering a production-ready solution for ensuring consistent, high-quality documentation across Python codebases.</p> <p>Transform from initial concept to enterprise-grade tool with configurable validation rules, rich terminal output, comprehensive test coverage, and robust cross-platform compatibility. Establish <code>docstring-format-checker</code> as the definitive solution for Python docstring validation, offering flexibility for diverse documentation standards whilst maintaining strict quality enforcement.</p> <p>Core Capabilities: - AST-Based Parsing: Robust code analysis without regex fragility - Configurable Validation: Four distinct section types with TOML-based configuration - Cross-Platform Reliability: 100% test coverage across Windows, macOS, and Linux - Rich Terminal Output: Beautiful coloured output with structured error tables - Dual CLI Entry Points: Accessible via <code>docstring-format-checker</code> or <code>dfc</code> commands</p>"},{"location":"usage/changelog/#foundational-architecture_1","title":"\ud83d\ude80 Foundational Architecture","text":""},{"location":"usage/changelog/#core-validation-engine_1","title":"\ud83c\udfd7\ufe0f Core Validation Engine","text":"<p>Establish a sophisticated docstring validation system built on Python AST parsing:</p> <ul> <li><code>DocstringChecker()</code>: Primary validation engine with comprehensive rule enforcement</li> <li><code>FunctionAndClassDetails()</code>: Structured representation of code elements for precise analysis</li> <li>AST Integration: Robust parsing of Python source files without dependency on fragile regex patterns</li> <li>Multi-Format Support: Handle functions, methods, classes, and async functions uniformly</li> </ul> <p>Validation Rule Categories: <pre><code>VALID_TYPES = (\n    \"free_text\",           # Summary, details, examples, notes\n    \"list_name\",           # Simple name sections\n    \"list_type\",           # Type-only sections (raises, yields)\n    \"list_name_and_type\",  # Parameter-style sections with descriptions\n)\n</code></pre></p>"},{"location":"usage/changelog/#configuration-management-system_1","title":"\u2699\ufe0f Configuration Management System","text":"<p>Implement hierarchical configuration discovery with TOML-based section definitions:</p> <ul> <li><code>Config()</code>: Top-level configuration container with global settings and section definitions</li> <li><code>SectionConfig()</code>: Individual section configuration with validation rules</li> <li><code>GlobalConfig()</code>: Global validation behaviour control flags</li> <li>Automatic Discovery: Hierarchical search for <code>pyproject.toml</code> configuration files</li> </ul> <p>Configuration Architecture: <pre><code>[tool.dfc]\nallow_undefined_sections = false\nrequire_docstrings = true\ncheck_private = true\nsections = [\n    { order = 1, name = \"summary\", type = \"free_text\", required = true },\n    { order = 2, name = \"params\", type = \"list_name_and_type\", required = true },\n    # ... additional sections\n]\n</code></pre></p>"},{"location":"usage/changelog/#command-line-interface-excellence","title":"\ud83d\udda5\ufe0f Command-Line Interface Excellence","text":"<p>Deliver a polished CLI experience with comprehensive features:</p> <ul> <li>Typer Integration: Modern CLI framework with automatic help generation</li> <li>Rich Output: Structured error tables and coloured terminal output</li> <li>Multiple Output Formats: Table format for detailed analysis, list format for CI/CD integration</li> <li>Example System: Built-in configuration and usage examples accessible via <code>--example</code> flag</li> </ul>"},{"location":"usage/changelog/#user-experience-enhancements","title":"\ud83c\udfa8 User Experience Enhancements","text":""},{"location":"usage/changelog/#rich-terminal-output","title":"\ud83c\udf08 Rich Terminal Output","text":"<p>Provide professional-grade terminal output with visual clarity:</p> <ul> <li>Error Tables: Structured display of validation errors with file, function, and line details</li> <li>Colour Coding: Green for success, red for errors, cyan for information</li> <li>Cross-Platform Compatibility: Handle terminal width variations and Unicode support differences</li> <li>Quiet Modes: Minimal output options for automated workflows and CI/CD integration</li> </ul>"},{"location":"usage/changelog/#flexible-output-formats","title":"\ud83d\udccb Flexible Output Formats","text":"<p>Support diverse workflow requirements with multiple output modes:</p> <ul> <li>Table Format: Rich structured display ideal for interactive development</li> <li>List Format: Simple line-by-line output perfect for CI/CD parsing and automation</li> <li>Summary Statistics: Clear reporting of validation results with error counts</li> <li>Exit Code Standards: Consistent return codes (0=success, 1=validation errors, 2=CLI errors)</li> </ul>"},{"location":"usage/changelog/#dual-cli-entry-points","title":"\ud83d\udd27 Dual CLI Entry Points","text":"<p>Provide convenient access through multiple command interfaces:</p> <ul> <li><code>docstring-format-checker</code>: Full descriptive command name for clarity</li> <li><code>dfc</code>: Abbreviated form for frequent use and scripting</li> <li>Consistent Behaviour: Identical functionality across both entry points</li> <li>Auto-completion Support: Built-in shell completion capabilities</li> </ul>"},{"location":"usage/changelog/#comprehensive-validation-logic","title":"\ud83e\uddea Comprehensive Validation Logic","text":""},{"location":"usage/changelog/#section-type-validation","title":"\ud83d\udcdd Section Type Validation","text":"<p>Implement sophisticated validation for four distinct docstring section types:</p> <p>Free Text Sections (<code>free_text</code>): - Summary, details, examples, notes sections - Support for admonition syntax with customisable prefixes - Flexible content validation with configurable requirements</p> <p>List Name Sections (<code>list_name</code>): - Simple name-only lists for basic documentation - Validation of proper formatting and structure - Support for bullet points and indentation requirements</p> <p>List Type Sections (<code>list_type</code>): - Exception and yield type documentation - Type information validation with parentheses checking - Title case enforcement for consistency</p> <p>List Name and Type Sections (<code>list_name_and_type</code>): - Parameter documentation with name, type, and description - Advanced parsing to distinguish definitions from descriptions - Multi-criteria validation including indentation and word count analysis</p>"},{"location":"usage/changelog/#advanced-rule-enforcement","title":"\ud83c\udfaf Advanced Rule Enforcement","text":"<p>Deliver comprehensive validation with intelligent error detection:</p> <ul> <li>Colon Usage Validation: Ensure proper colon placement in admonition and non-admonition sections</li> <li>Title Case Enforcement: Validate section headers follow proper capitalisation</li> <li>Parentheses Requirements: Check type definitions include required parentheses</li> <li>Indentation Analysis: Multi-level validation of content structure and formatting</li> <li>Blank Line Requirements: Enforce proper spacing after docstrings for readability</li> </ul>"},{"location":"usage/changelog/#smart-error-prevention","title":"\ud83d\udeab Smart Error Prevention","text":"<p>Reduce false positives whilst maintaining strict validation:</p> <ul> <li>Context-Aware Parsing: Distinguish between parameter definitions and description content</li> <li>Bullet Point Detection: Recognise legitimate description patterns vs. malformed parameters</li> <li>Word Count Analysis: Use intelligent thresholds to identify content vs. structure issues</li> <li>Configuration Flexibility: Allow customisation of validation strictness per project requirements</li> </ul>"},{"location":"usage/changelog/#continuous-integration-excellence","title":"\ud83d\udd04 Continuous Integration Excellence","text":""},{"location":"usage/changelog/#github-actions-integration","title":"\ud83c\udfd7\ufe0f GitHub Actions Integration","text":"<p>Establish robust CI/CD workflows with comprehensive testing:</p> <ul> <li>Multi-Platform Testing: Validate functionality across Ubuntu, macOS, and Windows</li> <li>Python Version Matrix: Support Python 3.9 through 3.13 with comprehensive compatibility testing</li> <li>UV Package Manager: Modern dependency management with faster resolution and caching</li> <li>Automated Versioning: Streamlined release processes with automatic changelog generation</li> </ul>"},{"location":"usage/changelog/#quality-assurance-standards_1","title":"\ud83d\udcca Quality Assurance Standards","text":"<p>Maintain exceptional code quality with comprehensive validation:</p> <ul> <li>100% Test Coverage: Complete test suite with 199 individual test cases across all modules</li> <li>Cross-Platform Reliability: Resolve Windows-specific issues with file locking and terminal formatting</li> <li>Pre-commit Hooks: Automated code quality checks with Black formatting and lint validation</li> <li>Documentation Standards: Consistent docstring formatting across entire codebase</li> </ul>"},{"location":"usage/changelog/#release-automation","title":"\ud83d\ude80 Release Automation","text":"<p>Streamline release processes with automated workflows:</p> <ul> <li>Version Bumping: Automated version management with changelog generation</li> <li>Coverage Reporting: Automatic generation and publication of test coverage reports</li> <li>Documentation Deployment: Automated documentation site updates with MkDocs integration</li> <li>PyPI Publishing: Seamless package distribution with automated release workflows</li> </ul>"},{"location":"usage/changelog/#exception-handling-architecture","title":"\ud83e\uddec Exception Handling Architecture","text":""},{"location":"usage/changelog/#structured-error-classes","title":"\ud83c\udfaf Structured Error Classes","text":"<p>Implement comprehensive exception hierarchy for clear error communication:</p> <ul> <li><code>DocstringError()</code>: Base exception for docstring validation issues with detailed context</li> <li><code>InvalidConfigError()</code>: Configuration file validation with specific error details</li> <li><code>InvalidTypeValuesError()</code>: Type validation errors with suggestions for correction</li> <li><code>DirectoryNotFoundError()</code>: File system errors with helpful resolution guidance</li> </ul>"},{"location":"usage/changelog/#error-reporting-excellence","title":"\ud83d\udccb Error Reporting Excellence","text":"<p>Provide detailed error information for rapid issue resolution:</p> <ul> <li>Line Number Precision: Exact location reporting for validation errors</li> <li>Context Information: Include surrounding code context for error understanding</li> <li>Suggestion Engine: Provide specific recommendations for error resolution</li> <li>Batch Error Processing: Handle multiple errors efficiently with comprehensive reporting</li> </ul>"},{"location":"usage/changelog/#platform-compatibility-achievements","title":"\ud83d\udcc8 Platform Compatibility Achievements","text":""},{"location":"usage/changelog/#cross-platform-reliability","title":"\ud83c\udf10 Cross-Platform Reliability","text":"<p>Resolve critical compatibility issues across operating systems:</p> <ul> <li>Windows File Locking: Fix temporary file management with proper handle cleanup and <code>flush()</code> calls</li> <li>Terminal Width Handling: Accommodate varying terminal sizes and line wrapping differences</li> <li>Unicode Support: Handle diverse character sets and border compatibility across terminals</li> <li>Path Management: Ensure consistent absolute path usage across all platforms</li> </ul>"},{"location":"usage/changelog/#test-suite-robustness","title":"\ud83e\uddea Test Suite Robustness","text":"<p>Achieve comprehensive test reliability with platform-agnostic approaches:</p> <ul> <li>Isolated Test Environments: Prevent interference with temporary directories and proper cleanup</li> <li>ANSI Code Handling: Strip formatting codes for consistent output validation across terminals</li> <li>Help Text Flexibility: Handle platform-specific formatting variations in CLI output</li> <li>Assertion Robustness: Use flexible matching patterns for cross-platform compatibility</li> </ul>"},{"location":"usage/changelog/#development-workflow-excellence","title":"\ud83d\udd0d Development Workflow Excellence","text":""},{"location":"usage/changelog/#documentation-standards","title":"\ud83d\udcdd Documentation Standards","text":"<p>Establish comprehensive documentation practices throughout the project:</p> <ul> <li>Docstring Standardisation: Implement consistent <code>!!! note \"Summary\"</code> format across all modules</li> <li>API Documentation: Complete function and class documentation with parameter details</li> <li>Usage Examples: Built-in examples accessible through CLI for immediate reference</li> <li>Contributing Guidelines: Detailed development and contribution documentation</li> </ul>"},{"location":"usage/changelog/#developer-experience","title":"\ud83d\udee0\ufe0f Developer Experience","text":"<p>Provide exceptional development tooling and workflows:</p> <ul> <li>Utility Scripts: Comprehensive automation for linting, testing, and version management</li> <li>Pre-commit Integration: Automated code quality enforcement with configurable rules</li> <li>Coverage Reporting: Detailed test coverage analysis with HTML and XML output formats</li> <li>Modern Tooling: Integration with contemporary Python tools including UV, Typer, and Rich</li> </ul>"},{"location":"usage/changelog/#configuration-flexibility_1","title":"\ud83c\udfaf Configuration Flexibility","text":""},{"location":"usage/changelog/#toml-integration","title":"\ud83d\udccb TOML Integration","text":"<p>Provide comprehensive configuration management through TOML files:</p> <ul> <li>Multiple Configuration Names: Support both <code>[tool.dfc]</code> and <code>[tool.docstring-format-checker]</code> sections</li> <li>Hierarchical Discovery: Automatic search for configuration files in project hierarchy</li> <li>Validation Engine: Comprehensive configuration validation with detailed error reporting</li> <li>Default Configuration: Sensible defaults for immediate use without configuration</li> </ul>"},{"location":"usage/changelog/#customisation-options","title":"\ud83d\udd27 Customisation Options","text":"<p>Enable extensive customisation for diverse project requirements:</p> <ul> <li>Section Definition: Complete control over docstring section requirements and order</li> <li>Admonition Support: Configurable admonition types with custom prefixes</li> <li>Global Flags: Control validation behaviour with <code>allow_undefined_sections</code>, <code>require_docstrings</code>, and <code>check_private</code></li> <li>Type System: Four distinct section types to accommodate different documentation patterns</li> </ul>"},{"location":"usage/changelog/#configuration-examples","title":"\ud83d\udcca Configuration Examples","text":"<p>Provide comprehensive examples for immediate implementation:</p> <ul> <li>Default Configuration: Production-ready configuration suitable for most Python projects</li> <li>Custom Sections: Examples of specialised section configurations for specific needs</li> <li>Integration Patterns: Demonstrate integration with existing project configurations</li> <li>Migration Guides: Support for updating configurations across versions</li> </ul>"},{"location":"usage/changelog/#quality-metrics","title":"\ud83c\udfc6 Quality Metrics","text":""},{"location":"usage/changelog/#test-coverage-excellence","title":"\ud83d\udcc8 Test Coverage Excellence","text":"<p>Achieve and maintain exceptional test coverage across all components:</p> <pre><code>Module Coverage Statistics:\n- src/docstring_format_checker/__init__.py:      100%\n- src/docstring_format_checker/cli.py:           100%  \n- src/docstring_format_checker/config.py:        100%\n- src/docstring_format_checker/core.py:          100%\n- src/docstring_format_checker/utils/exceptions.py: 100%\n------------------------------------------------------\nTOTAL COVERAGE:                                  100%\n</code></pre>"},{"location":"usage/changelog/#code-quality-standards_1","title":"\ud83c\udfaf Code Quality Standards","text":"<p>Maintain exceptional code quality with comprehensive validation:</p> <ul> <li>Type Safety: Complete type hint coverage with dataclass-based configuration</li> <li>Error Handling: Comprehensive exception hierarchy with structured error messages  </li> <li>Code Organisation: Consistent import structure and modular architecture</li> <li>Documentation: Enhanced docstrings following project standards across all modules</li> </ul>"},{"location":"usage/changelog/#performance-benchmarks","title":"\ud83d\ude80 Performance Benchmarks","text":"<p>Deliver efficient validation with optimised processing:</p> <ul> <li>AST Parsing: Efficient code analysis with minimal memory overhead</li> <li>File Processing: Optimised directory traversal with pattern matching</li> <li>Error Reporting: Structured error collection with minimal performance impact</li> <li>Configuration Loading: Cached configuration parsing for repeated operations</li> </ul>"},{"location":"usage/changelog/#user-benefits","title":"\ud83c\udf1f User Benefits","text":""},{"location":"usage/changelog/#for-development-teams","title":"\ud83d\udc65 For Development Teams","text":"<p>Enable consistent documentation standards across development teams:</p> <ul> <li>Standardised Documentation: Enforce consistent docstring formats across entire codebase</li> <li>Flexible Configuration: Adapt validation rules to match team conventions and standards</li> <li>CI/CD Integration: Automated validation with reliable exit codes for build pipelines</li> <li>Rich Feedback: Detailed error reporting with specific suggestions for resolution</li> </ul>"},{"location":"usage/changelog/#for-enterprise-users","title":"\ud83c\udfe2 For Enterprise Users","text":"<p>Provide enterprise-grade documentation validation capabilities:</p> <ul> <li>Scalable Architecture: Handle large codebases with efficient processing</li> <li>Compliance Support: Configurable validation rules for documentation standards compliance</li> <li>Cross-Platform Deployment: Consistent behaviour across diverse development environments</li> <li>Quality Assurance: 100% test coverage ensuring reliable operation in production environments</li> </ul>"},{"location":"usage/changelog/#for-open-source-projects","title":"\ud83d\udee0\ufe0f For Open Source Projects","text":"<p>Support open source development with comprehensive validation tools:</p> <ul> <li>Easy Integration: Simple installation and configuration for immediate use</li> <li>Documentation Excellence: Enforce high-quality documentation standards for contributors</li> <li>CI/CD Ready: Seamless integration with GitHub Actions and other CI platforms</li> <li>Community Standards: Support common Python documentation patterns and conventions</li> </ul>"},{"location":"usage/changelog/#version-evolution-summary","title":"\ud83d\udcca Version Evolution Summary","text":""},{"location":"usage/changelog/#release-timeline","title":"\ud83c\udfaf Release Timeline","text":"<p>Track the comprehensive evolution from initial concept to production release:</p> <ul> <li>v0.1.0: Initial release with basic validation functionality</li> <li>v0.2.0: Add <code>@overload</code> function support and CI/CD workflows</li> <li>v0.3.0: Enhance error message formatting and admonition validation</li> <li>v0.4.0: Remove recursive flags, add examples system, improve CLI interface</li> <li>v0.5.0: Resolve output formatting issues with list mode and summary statistics</li> <li>v0.6.0: Fix description line validation and list output formatting</li> <li>v0.7.0: Improve validation logic for list sections with enhanced type handling</li> <li>v0.8.0: Introduce global configuration architecture with comprehensive control flags</li> <li>v0.9.0: Refactor configuration structure and enhance test reliability</li> <li>v0.10.0: Resolve Windows CI issues and improve cross-platform compatibility</li> <li>v0.11.0: Standardise documentation formats and complete test suite reliability improvements</li> </ul>"},{"location":"usage/changelog/#cumulative-improvements","title":"\ud83d\udcc8 Cumulative Improvements","text":"<p>Demonstrate the comprehensive scope of development across all versions:</p> <ul> <li>199 Test Cases: Comprehensive test suite covering all functionality and edge cases</li> <li>11 Pull Requests: Major feature additions and reliability improvements</li> <li>74 Files Modified: Extensive codebase development with complete project structure  </li> <li>21,938 Lines Added: Substantial functionality implementation with comprehensive documentation</li> <li>100% Coverage: Complete test coverage across all modules and functions</li> </ul>"},{"location":"usage/changelog/#future-roadmap-foundation","title":"\ud83d\udd2e Future Roadmap Foundation","text":"<p>Establish architectural foundation for continued evolution:</p> <ul> <li>Plugin System: Configuration structure ready for extensible validation rules</li> <li>Custom Section Types: Framework prepared for additional docstring section types</li> <li>IDE Integration: Rich error reporting suitable for editor integration and tooling</li> <li>Performance Optimisation: Modular architecture enabling targeted performance enhancements</li> <li>Community Extensions: Extensible design supporting community-contributed validation rules</li> </ul>"},{"location":"usage/changelog/#pull-requests_3","title":"\ud83d\udcaa Pull Requests","text":""},{"location":"usage/changelog/#whats-changed_1","title":"What's Changed","text":"<ul> <li>Complete Foundation Setup: Introduce Docstring Format Checker CLI Tool with 100% Test Coverage and Professional Documentation by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/1</li> <li>Fix <code>@overload</code> Function Handling: Enhance Docstring Checker to Properly Ignore Function Type Overloads by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/2</li> <li>Comprehensive Docstring Validation Enhancement: Introduce Advanced Rule Enforcement and Achieve 100% Test Coverage by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/3</li> <li>Enhanced CLI Error Output Formatting: Improve Multi-Error Message Presentation and Achieve Comprehensive Test Coverage by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/4</li> <li>Streamline CLI Architecture: Simplify Interface Design and Achieve Complete Test Coverage by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/5</li> <li>Advanced List Output Formatting &amp; Error Summary Display by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/6</li> <li>Enhanced Docstring Validation Logic: Description Line Colon Handling &amp; Complete Code Coverage by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/7</li> <li>Enhanced Docstring Validation Logic: Advanced Parameter Description Handling by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/8</li> <li>Major Test Suite Refactor and Configuration Architecture Enhancement by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/9</li> <li>Enhanced CLI Architecture and Cross-Platform Test Reliability by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/10</li> <li>Comprehensive Docstring Validation Enhancement and Test Suite Reliability Improvement by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/11</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/docstring-format-checker/compare/v0.1.0...v1.0.0</p> <p>Version: v0.0.0 \u2192 v1.0.0 Tests: 199 comprehensive test cases (100% coverage) Platforms: Windows, macOS, Linux Python: 3.9+ supported PyPI Status: Production/Stable</p>"},{"location":"usage/changelog/#v0110-test-suite-reliability-improvement","title":"v0.11.0 - Test Suite Reliability Improvement","text":"<p><code>v0.11.0</code> <code>2025-09-10</code> data-science-extensions/docstring-format-checker/releases/v0.11.0</p> Release Notes Updates <ul> <li><code>d9494dd</code>: Fix typo     (by chrimaho)</li> <li><code>24de498</code>: Standardise admonition types and isolate test environment<ul> <li>Change admonition type from <code>info</code> to <code>abstract</code> for consistency in documentation formatting</li> <li>Isolate configuration loading test by switching to temporary directory to prevent interference from existing project configuration files</li> <li>Ensure test runs in clean environment by temporarily changing working directory and restoring original location afterwards (by chrimaho)</li> </ul> </li> <li><code>d569da7</code>: Add or fix package docstrings     (by chrimaho)</li> <li><code>581109e</code>: Fix typo     (by chrimaho)</li> <li><code>ec7103e</code>: Fix typo     (by chrimaho)</li> </ul>"},{"location":"usage/changelog/#whats-changed_2","title":"What's Changed","text":"<ul> <li>Comprehensive Docstring Validation Enhancement and Test Suite Reliability Improvement by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/11</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/docstring-format-checker/compare/v0.10.0...v0.11.0</p>"},{"location":"usage/changelog/#v0100-enhanced-cli-architecture-and-cross-platform-test-reliability","title":"v0.10.0 - Enhanced CLI Architecture and Cross-Platform Test Reliability","text":"<p><code>v0.10.0</code> <code>2025-09-10</code> data-science-extensions/docstring-format-checker/releases/v0.10.0</p> Release Notes Updates <ul> <li><code>f795295</code>: Improve test assertion robustness for CLI help text validation<ul> <li>Replace exact string matching with word-by-word validation to handle platform-specific line wrapping</li> <li>Use <code>all()</code> function with generator expression to check each word individually in help output</li> <li>Add explicit type annotation for output variable to improve code clarity</li> <li>Ensure tests pass consistently across different terminal widths and operating systems (by chrimaho)</li> </ul> </li> <li><code>145f68c</code>: Fix test assertions to handle platform-specific line wrapping<ul> <li>Remove trailing period from expected help text string to account for line wrapping variations across different platforms</li> <li>Extract cleaned output to variable for better readability and maintainability</li> <li>Ensure test reliability when help text formatting differs due to terminal width constraints (by chrimaho)</li> </ul> </li> <li><code>af74cc5</code>: Fix Windows CI issues: resolve temp file locking and help text assertion mismatches<ul> <li>Close all temporary files before CLI invocation to prevent Windows file locking errors</li> <li>Update help text assertions to match actual output (completeness. vs completeness)</li> <li>All 167 tests now pass with 100% code coverage locally (by chrimaho)</li> </ul> </li> <li><code>e580876</code>: Improve CI setup and fix test reliability issues<ul> <li>Add UV package manager setup in CD workflow for faster Python dependency management</li> <li>Fix Python version handling to use UV for installing matrix versions while maintaining setup consistency</li> <li>Improve test stability by adding <code>f.flush()</code> calls and proper temporary file name handling to prevent file system race conditions</li> <li>Expand table border detection to handle various Unicode characters for more robust output validation</li> <li>Update help text to better reflect tool capabilities including completeness checking</li> <li>Fix test configuration to use proper <code>Config</code> objects instead of deprecated helper functions (by chrimaho)</li> </ul> </li> </ul>"},{"location":"usage/changelog/#whats-changed_3","title":"What's Changed","text":"<ul> <li>Enhanced CLI Architecture and Cross-Platform Test Reliability by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/10</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/docstring-format-checker/compare/v0.9.0...v0.10.0</p>"},{"location":"usage/changelog/#v090-configuration-architecture-enhancement","title":"v0.9.0 - Configuration Architecture Enhancement","text":"<p><code>v0.9.0</code> <code>2025-09-10</code> data-science-extensions/docstring-format-checker/releases/v0.9.0</p> Release Notes Updates <ul> <li><code>46cd052</code>: Refactor tests to utilize new Config structure and global configuration flags<ul> <li>Updated test_config.py to reflect changes in load_config function, ensuring it returns a Config object instead of a list of SectionConfig.</li> <li>Enhanced assertions in test cases to validate global configuration values such as allow_undefined_sections, require_docstrings, and check_private.</li> <li>Introduced test_global_config.py to cover new global configuration features, including loading from TOML files and validating behavior based on global flags.</li> <li>Added tests for scenarios where undefined sections and missing docstrings are handled according to the global configuration settings. (by chrimaho)</li> </ul> </li> </ul>"},{"location":"usage/changelog/#whats-changed_4","title":"What's Changed","text":"<ul> <li>Major Test Suite Refactor and Configuration Architecture Enhancement by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/9</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/docstring-format-checker/compare/v0.8.0...v0.9.0</p>"},{"location":"usage/changelog/#v080-enhanced-docstring-validation-logic","title":"v0.8.0 - Enhanced Docstring Validation Logic","text":"<p><code>v0.8.0</code> <code>2025-09-09</code> data-science-extensions/docstring-format-checker/releases/v0.8.0</p> Release Notes Updates <ul> <li><code>1852daf</code>: Improves validation logic for list sections with types     Enhances the docstring checker to better distinguish between parameter     definitions and description content in list_name_and_type sections.     Previously flagged description lines containing colons as invalid parameter     definitions. Now uses multiple criteria including indentation levels, word     count analysis, and bullet point detection to avoid false positives.     Prevents validation errors on legitimate description content while maintaining     strict checking for actual parameter definition lines.     (by chrimaho)</li> </ul>"},{"location":"usage/changelog/#whats-changed_5","title":"What's Changed","text":"<ul> <li>Enhanced Docstring Validation Logic: Advanced Parameter Description Handling by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/8</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/docstring-format-checker/compare/v0.7.0...v0.8.0</p>"},{"location":"usage/changelog/#v070-enhanced-docstring-validation-logic","title":"v0.7.0 - Enhanced Docstring Validation Logic","text":"<p><code>v0.7.0</code> <code>2025-09-09</code> data-science-extensions/docstring-format-checker/releases/v0.7.0</p> Release Notes Updates <ul> <li><code>cf9b610</code>: Updates test expectations for parentheses validation     Adjusts test assertions to reflect current implementation behavior where certain type annotations are skipped when no parenthesized types have been found yet.     Changes expected error types from missing parentheses violations to undefined section errors, and removes assertions for cases that no longer generate errors due to the permissive logic.     (by chrimaho)</li> <li><code>ce0cca0</code>: Update src/docstring_format_checker/core.py     (by chrimaho)</li> <li><code>39aaf52</code>: Fixes description line validation in list_type sections     Improves docstring validation logic to properly handle description lines that contain colons in list_type sections.     Previously, description lines indented under type definitions were incorrectly flagged as requiring parenthesized types. Now tracks indentation levels to distinguish between type definition lines and their corresponding descriptions.     Adds comprehensive test coverage for various scenarios including multi-line descriptions, same-line descriptions, and invalid formats to ensure robust validation behavior.     (by chrimaho)</li> <li><code>7f65068</code>: Correct output as list, ensure errors are on individual lines     (by chrimaho)</li> </ul>"},{"location":"usage/changelog/#whats-changed_6","title":"What's Changed","text":"<ul> <li>Enhanced Docstring Validation Logic: Description Line Colon Handling &amp; Complete Code Coverage by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/7</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/docstring-format-checker/compare/v0.6.0...v0.7.0</p>"},{"location":"usage/changelog/#v060-advanced-list-output-formatting-error-summary-display","title":"v0.6.0 - Advanced List Output Formatting &amp; Error Summary Display","text":"<p><code>v0.6.0</code> <code>2025-09-08</code> data-science-extensions/docstring-format-checker/releases/v0.6.0</p> Release Notes Updates <ul> <li><code>44578b4</code>: Resove issues with the output when <code>-o list</code> and with the summary stats on the printed output     (by chrimaho)</li> </ul>"},{"location":"usage/changelog/#whats-changed_7","title":"What's Changed","text":"<ul> <li>Advanced List Output Formatting &amp; Error Summary Display by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/6</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/docstring-format-checker/compare/v0.5.0...v0.6.0</p>"},{"location":"usage/changelog/#v050-streamline-cli-architecture","title":"v0.5.0 - Streamline CLI Architecture","text":"<p><code>v0.5.0</code> <code>2025-09-07</code> data-science-extensions/docstring-format-checker/releases/v0.5.0</p> Release Notes Updates <ul> <li><code>d29faf0</code>: Increase code coverage     (by chrimaho)</li> <li><code>8b4f42a</code>: Fix failing unit tests     (by chrimaho)</li> <li><code>dfccf35</code>: Add <code>--examples</code>/<code>-e</code> flags to the CLI, instead of using a sub-command     (by chrimaho)</li> <li><code>76cbd78</code>: Remove the unnecessary <code>_parse_boolean_flag()</code> function and all associated unit tests     (by chrimaho)</li> <li><code>3e583f5</code>: Remove all references to the <code>--recursive</code>/<code>-r</code> flag, and ensure that it will always be recursive by default     (by chrimaho)</li> <li><code>2614316</code>: Update docstring format in CLI module to be more pythonic     (by chrimaho)</li> </ul>"},{"location":"usage/changelog/#whats-changed_8","title":"What's Changed","text":"<ul> <li>Streamline CLI Architecture: Simplify Interface Design and Achieve Complete Test Coverage by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/5</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/docstring-format-checker/compare/v0.4.0...v0.5.0</p>"},{"location":"usage/changelog/#v040-enhance-cli-error-output-formatting","title":"v0.4.0 - Enhance CLI Error Output Formatting","text":"<p><code>v0.4.0</code> <code>2025-09-06</code> data-science-extensions/docstring-format-checker/releases/v0.4.0</p> Release Notes Updates <ul> <li><code>8bf056c</code>: Fix typo     (by chrimaho)</li> <li><code>a58c64e</code>: Enhance error message formatting in CLI output and add corresponding unit tests     (by chrimaho)</li> </ul>"},{"location":"usage/changelog/#whats-changed_9","title":"What's Changed","text":"<ul> <li>Enhanced CLI Error Output Formatting: Improve Multi-Error Message Presentation and Achieve Comprehensive Test Coverage by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/4</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/docstring-format-checker/compare/v0.3.0...v0.4.0</p>"},{"location":"usage/changelog/#v030-enhance-validation-configuration-rules","title":"v0.3.0 - Enhance Validation &amp; Configuration Rules","text":"<p><code>v0.3.0</code> <code>2025-09-06</code> data-science-extensions/docstring-format-checker/releases/v0.3.0</p> Release Notes Updates <ul> <li><code>c7ada96</code>: Fix typo     (by chrimaho)</li> <li><code>66de3cf</code>: Add additional unit tests to check more edge cases     (by chrimaho)</li> <li><code>1f35cc2</code>: Add more unit tests for edge cases     (by chrimaho)</li> <li><code>1110894</code>: Enhance admonition validation by ensuring admonition is a string and refining section name matching patterns     (by chrimaho)</li> <li><code>2e656f1</code>: Add parentheses validation for list type sections in docstring checks     (by chrimaho)</li> <li><code>2528a63</code>: Add title case validation for non-admonition sections in docstrings     (by chrimaho)</li> <li><code>186377a</code>: Add colon usage checks for admonition and non-admonition sections in docstrings     (by chrimaho)</li> <li><code>1881e90</code>: Add blank lines after docstrings for improved readability     (by chrimaho)</li> <li><code>ca5bbd9</code>: Refactor <code>SectionConfig()</code> to enhance admonition validation and type handling     (by chrimaho)</li> <li><code>8e3598a</code>: Extend the <code>core</code> module to better handle edge-cases     This will now throw errors when:<ol> <li>When there is a section in a docstring which are not defined in the config</li> <li>When the admonition used in the docstring does not match the admonition defined in the config (by chrimaho)</li> </ol> </li> </ul>"},{"location":"usage/changelog/#whats-changed_10","title":"What's Changed","text":"<ul> <li>Comprehensive Docstring Validation Enhancement: Introduce Advanced Rule Enforcement and Achieve 100% Test Coverage by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/3</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/docstring-format-checker/compare/v0.2.0...v0.3.0</p>"},{"location":"usage/changelog/#v020-allow-app-to-properly-handle-functions-with-overload-decorator","title":"v0.2.0 - Allow app to properly handle functions with @overload decorator","text":"<p><code>v0.2.0</code> <code>2025-09-04</code> data-science-extensions/docstring-format-checker/releases/v0.2.0</p> Release Notes Updates <ul> <li><code>a4cde50</code>: typo     (by chrimaho)</li> <li><code>42936b4</code>: Fix typo     (by chrimaho)</li> <li><code>36f4d07</code>: Fix bug regarding bumping versions during CD workflow     (by chrimaho)</li> <li><code>6e610c7</code>: Add support for ignoring <code>@overload</code> functions in docstring checks     (by chrimaho)</li> </ul>"},{"location":"usage/changelog/#whats-changed_11","title":"What's Changed","text":"<ul> <li>Fix <code>@overload</code> Function Handling: Enhance Docstring Checker to Properly Ignore Function Type Overloads by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/2</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/docstring-format-checker/compare/v0.1.0...v0.2.0</p>"},{"location":"usage/changelog/#v010-first-minor-release","title":"v0.1.0 - First Minor Release","text":"<p><code>v0.1.0</code> <code>2025-08-31</code> data-science-extensions/docstring-format-checker/releases/v0.1.0</p> Release Notes Updates <ul> <li><code>59d7bf2</code>: Fix bug in CD workflow when building package     (by chrimaho)</li> <li><code>d5dadcd</code>: Fix bugs in Git commit processes during CD workflow     (by chrimaho)</li> <li><code>1b7c824</code>: Fix bug     (by chrimaho)</li> <li><code>d22d331</code>: Fix git command for coverage report     (by chrimaho)</li> <li><code>1c12bdb</code>: Fix git commands     (by chrimaho)</li> <li><code>a600108</code>: Update Code Coverage info     (by chrimaho)</li> <li><code>b65ca7e</code>: Ensure coverage report directory exists before copying files     (by chrimaho)</li> <li><code>56333ef</code>: Streamline constants in the <code>scripts</code> module     (by chrimaho)</li> <li><code>6bac29e</code>: Fix failing unit tests for macos, caused by <code>rm</code> flags     (by chrimaho)</li> <li><code>a20c997</code>: Enhance CLI test assertions for output flexibility and Windows compatibility     (by chrimaho)</li> <li><code>233b01f</code>: Resolve failing unit tests on macos     (by chrimaho)</li> <li><code>482346e</code>: Fix failing unit tests     (by chrimaho)</li> <li><code>2784a12</code>: Restructure unit tests to better handle temp files on the windows os     (by chrimaho)</li> <li><code>2a8016c</code>: Fix failing <code>macos</code> unit test     (by chrimaho)</li> <li><code>6c02f67</code>: Fix bug     (by chrimaho)</li> <li><code>8428d91</code>: Fix configuration file path assertion in CLI tests     (by chrimaho)</li> <li><code>e78f78b</code>: Fix failing unit tests     (by chrimaho)</li> <li><code>cdaa768</code>: Update CI workflow to only run on Python versions 3.9 to 3.13     (by chrimaho)</li> <li><code>8cad4f4</code>: Refactor type hints in <code>test_config.py</code> for consistency and clarity     (by chrimaho)</li> <li><code>f31230d</code>: Strip ANSI codes from all <code>CliRunner</code> output in unit tests     (by chrimaho)</li> <li><code>7cf4532</code>: Update <code>pyupgrade</code> pre-commit config to target Python 3.7 features (previously 3.9)     (by chrimaho)</li> <li><code>373939f</code>: Refactor all type hints to use <code>Optional</code> and <code>Union</code> instead of <code>|</code> for improved clarity,  consistency, and compatability     (by chrimaho)</li> <li><code>7e69f56</code>: Add Python 3.7 to CI workflow matrix for enhanced compatibility     (by chrimaho)</li> <li><code>8af990a</code>: Add detailed docstrings to all core modules     (by chrimaho)</li> <li><code>091f4c7</code>: Add <code>strip_ansi_codes()</code> function to generic Unit Tests setup and update CLI tests to use it for robust output validation     (by chrimaho)</li> <li><code>023147d</code>: Do more debugging in the CLI unit tests     (by chrimaho)</li> <li><code>73d53e6</code>: Add <code>re</code> to CLI unit tests     (by chrimaho)</li> <li><code>e7a7264</code>: Add <code>strip_ansi_codes()</code> function to the CLI Unit Tests     (by chrimaho)</li> <li><code>36689f4</code>: Debug CLI Unit Test 19     (by chrimaho)</li> <li><code>5028bdd</code>: Temporarily turn off <code>pylint</code> checks during pre-commit hooks     (by chrimaho)</li> <li><code>ebc514e</code>: Refactor CLI to use Typer imports directly and improve error messages     (by chrimaho)</li> <li><code>64dd8d9</code>: Fix linting     (by chrimaho)</li> <li><code>e1b34dd</code>: Remove redundant reference code     (by chrimaho)</li> <li><code>626a820</code>: Update CI and CD workflows to use specific script paths for running checks     (by chrimaho)</li> <li><code>62b4f1a</code>: Fix CLI tests: Disable Rich colors to prevent ANSI formatting issues in CI<ul> <li>Set NO_COLOR=1 environment variable in CliRunner to ensure consistent test output</li> <li>Resolves GitHub Actions test failures due to Rich library adding ANSI color codes</li> <li>Local and CI environments now produce identical plain text error messages</li> <li>All 175 tests now pass with 100% coverage in both local and CI environments (by chrimaho)</li> </ul> </li> <li><code>174e662</code>: Improve error message assertions for invalid recursive flag in CLI tests     (by chrimaho)</li> <li><code>cef91a9</code>: Add CD workflow along with scripts to bump version and generate changelog     (by chrimaho)</li> <li><code>235c66d</code>: Fix typo     (by chrimaho)</li> <li><code>741ceba</code>: Streamline automation scripts     (by chrimaho)</li> <li><code>79daa31</code>: Add CI workflow     (by chrimaho)</li> <li><code>050b397</code>: Fix hardcoding in the Unit Tests     Hardcoded absolute path used in test. The <code>cwd</code> parameter contains a hardcoded personal directory path that will not work on other systems. This should use a relative path or be made configurable.     (by chrimaho)</li> <li><code>6db7b02</code>: Add a nice README     (by chrimaho)</li> <li><code>af7ac2c</code>: Fix a typo     (by chrimaho)</li> <li><code>44d4d04</code>: Add docs structure and config     (by chrimaho)</li> <li><code>7791970</code>: Add project guidelines     (by chrimaho)</li> <li><code>864f602</code>: Refactor exception handling: rename exceptions for clarity and consistency     (by chrimaho)</li> <li><code>f80b83a</code>: Remove <code>check-docstrings</code> from the <code>pre-commit</code> checks     (by chrimaho)</li> <li><code>ec53fa7</code>: Fix failing Unit Tests     (by chrimaho)</li> <li><code>0719d8e</code>: Clarify some of the <code>raise</code> sections to instead use Exceptions defined in the local module, instead of the default Exceptions from the builtins module     (by chrimaho)</li> <li><code>cffa310</code>: Refine any sections which use the <code>/</code> operator to merge objects in the <code>Path</code> package to instead use the <code>.joinpath()</code> method. This is to make the code more robust and more readable.     (by chrimaho)</li> <li><code>8921f24</code>: Correct and refine some of the docstrings in the <code>config</code> and <code>core</code> modules     (by chrimaho)</li> <li><code>98a2409</code>: Add new <code>_validate_config_order()</code> function to the <code>config</code> module     (by chrimaho)</li> <li><code>f711ac7</code>: Refine how the <code>import</code>'s and <code>export</code>'s are defined across both the <code>cli</code> and <code>config</code> modules     (by chrimaho)</li> <li><code>6cdc073</code>: Restructure how the <code>VALID_TYPES</code> constant is defined and utilised in the <code>config</code> module     (by chrimaho)</li> <li><code>5e9869a</code>: Add helpful docstrings and additional headers to the <code>cli</code> and <code>config</code> modules     (by chrimaho)</li> <li><code>5e227ec</code>: Refactor the Callbacks in the <code>cli</code> module to have better structure and organisation     (by chrimaho)</li> <li><code>22286e4</code>: Reorder the steps for the checks scripts     (by chrimaho)</li> <li><code>0779921</code>: Add new exception classes for improved clarity and organization     (by chrimaho)</li> <li><code>12aa070</code>: Bring code coverage for all unit tests up to 100% coverage     (by chrimaho)</li> <li><code>d98ed78</code>: Update dependencies and refine project configuration in <code>pyproject.toml</code>     (by chrimaho)</li> <li><code>7331f75</code>: Initial commit of all package unit tests     (by chrimaho)</li> <li><code>91493ee</code>: Initial commit of all package modules     (by chrimaho)</li> <li><code>609e9cb</code>: Add utility scripts for command execution and linting checks     (by chrimaho)</li> <li><code>4c0e003</code>: Fix typo     (by chrimaho)</li> <li><code>7d870ad</code>: Tweak some of the core package config     (by chrimaho)</li> <li><code>32acad0</code>: Initial commit of package config     (by )</li> <li><code>416b0b3</code>: Initial commit     (by chrimaho)</li> </ul>"},{"location":"usage/changelog/#whats-changed_12","title":"What's Changed","text":"<ul> <li>Complete Foundation Setup: Introduce Docstring Format Checker CLI Tool with 100% Test Coverage and Professional Documentation by @chrimaho in https://github.com/data-science-extensions/docstring-format-checker/pull/1</li> </ul>"},{"location":"usage/changelog/#new-contributors","title":"New Contributors","text":"<ul> <li>@chrimaho made their first contribution in https://github.com/data-science-extensions/docstring-format-checker/pull/1</li> </ul> <p>Full Changelog: https://github.com/data-science-extensions/docstring-format-checker/commits/v0.1.0</p>"},{"location":"usage/contributing/","title":"Contribution Guidelines","text":"<p>All contributions are welcome! Please follow these guidelines to ensure a smooth contribution process.</p>"},{"location":"usage/contributing/#overview","title":"Overview","text":"<p>Here are some guidelines to help you get started:</p> <ol> <li>Raise an Issue: Before starting work on a new feature or bug fix, please raise an issue to discuss it. All enhancements and changes are discussed in the issues section. This helps us avoid duplicate work and ensures that your contribution aligns with the project's goals.</li> <li>Check the issues and milestones: Look at the issues and milestones to see if your contribution fits into the current roadmap.</li> <li>Fork the Repository: Create a fork of the repository to work on your changes. This allows you to make changes without affecting the main codebase.</li> <li>Create a new branch: When working on a new feature or bug fix, create a new branch from the <code>main</code> branch. Use a descriptive name for your branch that reflects the changes you are making.</li> <li>Clone the repository: Clone your forked repository to your local machine to start working on it.</li> <li>Creating your environment: Set up your development environment according to the project's requirements. This may include installing dependencies, setting up virtual environments, and configuring tools like uv, pre-commit, pytest, and mypy.</li> <li>Make your changes: Implement your changes in the new branch. Ensure that your code adheres to the project's coding standards and style guidelines.</li> <li>Commit your changes: Commit your changes with a clear and descriptive commit message.</li> <li>Write tests: If you are adding new features or fixing bugs, please write tests to ensure that your changes work as expected.</li> <li>Submit a Pull Request: Once you have made your changes and committed them, submit a pull request to the main repository. Provide a clear description of the changes you made and reference any related issues.</li> </ol>"},{"location":"usage/contributing/#raise-an-issue","title":"Raise an Issue","text":"<p>If you find a bug or have a feature request, please raise an issue. This helps us track and prioritize contributions effectively.</p> <p>Raise an Issue</p> <p>When raising an issue, please follow these guidelines to ensure clarity and effectiveness:</p> <ol> <li>Title: Provide a clear and concise title that summarizes the issue or feature request.</li> <li>Description: Include a detailed description of the issue or feature request. Explain what the problem is, how it can be reproduced, and any relevant context.</li> <li>Steps to Reproduce: If applicable, provide a step-by-step guide on how to reproduce the issue. This helps us understand the problem better.</li> <li>Expected vs Actual Behavior: Describe what you expected to happen and what actually happened. This helps clarify the issue.</li> <li>Screenshots or Logs: If possible, include screenshots or logs that illustrate the issue. This can be very helpful for debugging.</li> <li>Context: Provide any additional context that might be relevant, such as the environment in which the issue occurred (e.g., operating system, Python version, etc.).</li> </ol>"},{"location":"usage/contributing/#issues-and-milestones","title":"Issues and Milestones","text":"<p>We are using issues to track bugs, feature requests, and enhancements, and milestones to organize these issues into manageable chunks.</p> <p>If you want to contribute to the project, please check the current issues and milestones before starting work to ensure that your contribution aligns with the project's goals and priorities. This will help avoid duplication of effort and ensure that your contributions align with the project's roadmap. If you want to add something that is not already listed in the milestones, please raise an issue to discuss it first.</p> <p>You can view the current issues and milestones on the project's GitHub page.</p> <p>View Issues</p> <p>View Milestones</p>"},{"location":"usage/contributing/#create-a-fork","title":"Create a Fork","text":"<p>To contribute to this project, you need to create a fork of the repository. This allows you to make changes without affecting the main codebase.</p> <p>Create a Fork</p>"},{"location":"usage/contributing/#create-a-new-branch","title":"Create a New Branch","text":"<p>When working on a new feature or bug fix, create a new branch from the <code>main</code> branch. Use a descriptive name for your branch that reflects the changes you are making.</p> <p>Create a New Branch</p>"},{"location":"usage/contributing/#clone-the-repository","title":"Clone the Repository","text":"<p>To start working on your forked repository, you need to clone it to your local machine. This allows you to make changes and test them locally before submitting a pull request.</p>"},{"location":"usage/contributing/#creating-your-environment","title":"Creating your Environment","text":"<p>When you are ready to start working on your changes, set up your development environment according to the project's requirements. In this project, we use uv to manage the Python environments, pre-commit for code quality checks, and pytest for testing.</p> <p>This project is a Python docstring format checker that validates docstring structure and content according to configurable rules. The main components include:</p> <ul> <li>Core checker: Validates docstring sections, types, and formatting</li> <li>CLI interface: Command-line tool for checking files and directories</li> <li>Configuration system: TOML-based configuration for customizing validation rules</li> <li>Exception handling: Custom exceptions for different error types</li> </ul> <p>Follow these steps to set up your environment:</p> <ol> <li>Install uv: Follow the instructions in the uv installation guide to install uv.     <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre></li> <li>Sync the environment: Use <code>uv</code> to set up the environment with the required dependencies.     <pre><code>uv sync --all-groups --link-mode=copy\n</code></pre></li> <li>Install pre-commit: Install pre-commit to manage code quality checks.     <pre><code>uv run --link-mode=copy pre-commit install\n</code></pre></li> <li>Update pre-commit hooks: Ensure that the pre-commit hooks are up to date.     <pre><code>uv run --link-mode=copy pre-commit autoupdate\n</code></pre></li> <li>Run tests to verify setup: Verify your environment is working correctly by running the test suite.     <pre><code>uv run ./src/utils/scripts.py check_pytest\n</code></pre></li> </ol>"},{"location":"usage/contributing/#testing-your-changes","title":"Testing Your Changes","text":"<p>This project maintains 100% test coverage. When making changes, ensure you:</p> <ol> <li>Run the full test suite: Use <code>uv run ./src/utils/scripts.py check_pytest</code> to run all tests with coverage reporting</li> <li>Test specific modules: You can run tests for specific modules:    <pre><code>uv run pytest src/tests/test_core.py\nuv run pytest src/tests/test_config.py\nuv run pytest src/tests/test_cli.py\n</code></pre></li> <li>Test the CLI: Test the command-line interface with real files:    <pre><code>uv run docstring-format-checker examples/example_code.py\n</code></pre></li> <li>Add tests for new features: Any new functionality must include comprehensive tests</li> <li>Maintain coverage: Ensure your changes don't reduce the overall test coverage</li> </ol>"},{"location":"usage/contributing/#make-your-changes","title":"Make Your Changes","text":"<p>Make your changes in the new branch you created. Ensure that your code adheres to the project's coding standards and style guidelines. If you are adding new features or fixing bugs, please write tests to ensure that your changes work as expected.</p> <p>This project has specific areas where contributions are especially valuable:</p> <ul> <li>Core validation logic (<code>src/docstring_format_checker/core.py</code>): Enhance docstring parsing and validation</li> <li>Configuration system (<code>src/docstring_format_checker/config.py</code>): Improve TOML configuration handling</li> <li>CLI interface (<code>src/docstring_format_checker/cli.py</code>): Add new command-line options and features</li> <li>Exception handling (<code>src/docstring_format_checker/utils/exceptions.py</code>): Custom exception types</li> <li>Documentation and examples: Help users understand how to use the tool effectively</li> </ul> <p>Ensure you follow the project's coding standards and style guidelines. This includes:</p> <ol> <li>Code Style: Follow the PEP 8 style guide for Python code.</li> <li>Docstrings: Use clear and concise docstrings for all functions, classes, and modules. Since this is a docstring format checker, we practice what we preach! Follow the project's own validation rules and ensure docstrings include:</li> <li>Clear summary sections</li> <li>Proper parameter descriptions with types</li> <li>Return value descriptions</li> <li>Exception documentation where applicable</li> <li>Examples for complex functions</li> <li>Testing: Write unit tests for your code using unittest or pytest. Ensure that your tests cover all new functionality and edge cases.</li> <li>Code Coverage: Maintain high code coverage for your tests. Use Codecov to check your coverage reports.</li> <li>Type Checking: Use mypy for static type checking. Ensure that your code passes all type checks.</li> <li>Docstring Validation: Use the project's own tool to validate your docstrings:    <pre><code>uv run docstring-format-checker src/docstring_format_checker/\n</code></pre></li> </ol> <p>Because you have set up <code>pre-commit</code>, these checks will be run automatically when you commit your changes. If any checks fail, you will need to fix them before you can successfully commit your changes. Further checks will also be run when you submit a pull request, so it's a good idea to ensure your code passes all checks before proceeding.</p>"},{"location":"usage/contributing/#commit-your-changes","title":"Commit Your Changes","text":"<p>Once you have made your changes, commit them with a clear and descriptive commit message. This helps reviewers understand the purpose of your changes. A good commit message should:</p> <ul> <li>Start with a short summary of the changes (50 characters or less).</li> <li>Follow the summary with a blank line.</li> <li>Provide a detailed description of the changes, including why they were made and any relevant context.</li> <li>Use the imperative mood (e.g., \"Add feature\" instead of \"Added feature\").</li> <li>Reference any related issues or pull requests.</li> <li>Use bullet points or paragraphs to organize the description for readability.</li> <li>Avoid using vague terms like \"fixes\" or \"changes\" without context.</li> <li>Be concise but informative, providing enough detail for someone unfamiliar with the code to understand the changes.</li> <li>Avoid including unnecessary information or personal opinions.</li> <li>Use proper grammar and punctuation to enhance clarity.</li> <li>If applicable, include any relevant links to documentation or resources that provide additional context for the changes.</li> <li>If the commit is related to a specific issue, include the issue number in the commit message (e.g., \"Fixes #123\").</li> <li>If the commit is part of a larger feature or task, consider using a prefix like \"feat:\", \"fix:\", or \"chore:\" to categorize the commit (e.g., \"feat: add new feature for user authentication\").</li> <li>If the commit is a work in progress, consider using a prefix like \"WIP:\" to indicate that it is not yet complete (e.g., \"WIP: start implementing new feature for user authentication\").</li> <li>If the commit is a refactor or cleanup, consider using a prefix like \"refactor:\" to indicate that it does not introduce new functionality (e.g., \"refactor: improve code readability and maintainability\").</li> <li>If the commit is a documentation update, consider using a prefix like \"docs:\" to indicate that it only affects documentation (e.g., \"docs: update README with installation instructions\").</li> <li>If the commit is a test update, consider using a prefix like \"test:\" to indicate that it only affects tests (e.g., \"test: add unit tests for new feature\").</li> </ul> <p>Ensure that any pre-commit checks pass before committing your changes. This includes code style checks, linting, and tests. If any checks fail, you will need to fix them before you can successfully commit your changes.</p>"},{"location":"usage/contributing/#submit-a-pull-request","title":"Submit a Pull Request","text":"<p>Once you have made your changes and committed them, submit a pull request to the main repository. Provide a clear description of the changes you made and reference any related issues.</p> <p>When submitting a pull request, please follow these guidelines:</p> <ol> <li>Title: Use a clear and descriptive title that summarizes the changes you made.</li> <li>Description: Provide a detailed description of the changes you made, including:</li> <li>What the changes do.</li> <li>Why the changes were made.</li> <li>Any relevant context or background information.</li> <li>How to test the changes.</li> <li>Reference Issues: If your changes address a specific issue, reference it in the pull request description (e.g., \"Fixes #123\" or \"Closes #123).</li> <li>Link to Related Pull Requests: If your changes are related to other pull requests, link to them in the description.</li> <li>Reviewers: Optionally, you can request specific reviewers to review your pull request.</li> <li>Milestone: Optionally, you can assign your pull request to a specific milestone if it is related to a larger feature or task.</li> <li>Check for Merge Conflicts: Ensure that your branch is up to date with the main branch and that there are no merge conflicts. If there are conflicts, resolve them before submitting the pull request.</li> <li>Be Responsive: Be prepared to respond to feedback from reviewers. They may request changes or ask for clarification on certain aspects of your pull request. Address their comments promptly and respectfully.</li> <li>Be Patient: Reviewers may take some time to review your pull request, especially if they are busy with other tasks. Be patient and give them time to provide feedback.</li> <li>Follow Up: After your pull request is merged, consider following up with any additional changes or improvements based on feedback from the review process. This helps maintain a high-quality codebase and shows that you are committed to improving the project.</li> </ol> <p>Submit a Pull Request</p>"},{"location":"usage/overview/","title":"Overview","text":"<code>docstring-format-checker</code>"},{"location":"usage/overview/#introduction","title":"Introduction","text":"<p>A powerful Python CLI tool that validates docstring formatting and completeness using AST parsing. Ensure consistent, high-quality documentation across your entire codebase with configurable validation rules and rich terminal output.</p> <p>Key Features:</p> <ul> <li>\ud83d\udd0d AST-based parsing - Robust code analysis without regex fragility</li> <li>\u2699\ufe0f Configurable validation - Four section types with TOML-based configuration</li> <li>\ud83d\udcc1 Hierarchical config discovery - Automatic <code>pyproject.toml</code> detection</li> <li>\ud83c\udfa8 Rich terminal output - Beautiful colored output and error tables</li> <li>\ud83d\ude80 Dual CLI entry points - Use <code>docstring-format-checker</code> or <code>dfc</code></li> <li>\ud83d\udee1\ufe0f 100% test coverage - Thoroughly tested and reliable</li> </ul>"},{"location":"usage/overview/#quick-start","title":"Quick Start","text":"<pre><code># Install\nuv add docstring-format-checker\n\n# Check a single file\ndfc check my_module.py\n\n# Check entire directory\ndfc check src/\n\n# Generate example configuration\ndfc config-example\n</code></pre>"},{"location":"usage/overview/#key-urls","title":"Key URLs","text":"<p>For reference, these URL's are used:</p> Type Source URL Git Repo GitHub https://github.com/data-science-extensions/docstring-format-checker Python Package PyPI https://pypi.org/project/docstring-format-checker Package Docs Pages https://data-science-extensions.com/docstring-format-checker"},{"location":"usage/overview/#section-types","title":"Section Types","text":"<p>Configure validation for four types of docstring sections:</p> Type Description Example Use <code>free_text</code> Admonition-style sections Summary, details, examples <code>list_name</code> Simple name lists Simple parameter lists <code>list_type</code> Type-only lists Raises, yields sections <code>list_name_and_type</code> Name and type lists Parameters, returns with types"},{"location":"usage/overview/#configuration","title":"Configuration","text":"<p>Create a <code>pyproject.toml</code> with your validation rules:</p> <pre><code>[tool.dfc]\n\n[[tool.dfc.sections]]\norder = 1\nname = \"summary\"\ntype = \"free_text\"\nadmonition = \"note\"\nprefix = \"!!!\"\nrequired = true\n\n[[tool.dfc.sections]]\norder = 2\nname = \"params\"\ntype = \"list_name_and_type\"\nrequired = true\n\n[[tool.dfc.sections]]\norder = 3\nname = \"returns\"\ntype = \"list_name_and_type\"\nrequired = false\n\n[[tool.dfc.sections]]\norder = 4\nname = \"raises\"\ntype = \"list_type\"\nrequired = false\n</code></pre>"},{"location":"usage/overview/#installation","title":"Installation","text":"<p>You can install and use this package multiple ways by using any of your preferred methods: <code>pip</code>, <code>pipenv</code>, <code>poetry</code>, or <code>uv</code>.</p>"},{"location":"usage/overview/#using-pip","title":"Using <code>pip</code>:","text":"<ol> <li> <p>In your terminal, run:</p> <pre><code>python3 -m pip install --upgrade pip\npython3 -m pip install docstring-format-checker\n</code></pre> </li> <li> <p>Or, in your <code>requirements.txt</code> file, add:</p> <pre><code>docstring-format-checker\n</code></pre> <p>Then run:</p> <pre><code>python3 -m pip install --upgrade pip\npython3 -m pip install --requirement=requirements.txt\n</code></pre> </li> </ol>"},{"location":"usage/overview/#using-pipenv","title":"Using <code>pipenv</code>:","text":"<ol> <li> <p>Install using environment variables:</p> <p>In your <code>Pipfile</code> file, add:</p> <pre><code>[[source]]\nurl = \"https://pypi.org/simple\"\nverify_ssl = false\nname = \"pypi\"\n\n[packages]\ndocstring-format-checker = \"*\"\n</code></pre> <p>Then run:</p> <pre><code>python3 -m pip install pipenv\npython3 -m pipenv install --verbose --skip-lock --categories=root index=pypi docstring-format-checker\n</code></pre> </li> <li> <p>Or, in your <code>requirements.txt</code> file, add:</p> <pre><code>docstring-format-checker\n</code></pre> <p>Then run:</p> <pre><code>python3 -m pipenv install --verbose --skip-lock --requirements=requirements.txt\n</code></pre> </li> <li> <p>Or just run this:</p> <pre><code>python3 -m pipenv install --verbose --skip-lock docstring-format-checker\n</code></pre> </li> </ol>"},{"location":"usage/overview/#using-poetry","title":"Using <code>poetry</code>:","text":"<ol> <li> <p>In your <code>pyproject.toml</code> file, add:</p> <pre><code>[project]\ndependencies = [\n    \"docstring-format-checker==0.*\",\n]\n</code></pre> <p>Then run:</p> <pre><code>poetry sync\npoetry install\n</code></pre> </li> <li> <p>Or just run this:</p> <pre><code>poetry add \"docstring-format-checker==0.*\"\npoetry sync\npoetry install\n</code></pre> </li> </ol>"},{"location":"usage/overview/#using-uv","title":"Using <code>uv</code>:","text":"<ol> <li> <p>In your <code>pyproject.toml</code> file, add:</p> <pre><code>[project]\ndependencies = [\n    \"docstring-format-checker==0.*\",\n]\n</code></pre> </li> </ol> <p>Then run:</p> <pre><code>uv sync\n</code></pre> <ol> <li> <p>Or run this:</p> <pre><code>uv add \"docstring-format-checker==0.*\"\nuv sync\n</code></pre> </li> <li> <p>Or just run this:</p> <pre><code>uv pip install \"docstring-format-checker==0.*\"\n</code></pre> </li> </ol>"},{"location":"usage/overview/#usage-examples","title":"Usage Examples","text":""},{"location":"usage/overview/#basic-usage","title":"Basic Usage","text":"<pre><code># Check a single Python file\ndfc check src/my_module.py\n\n# Check entire directory recursively\ndfc check src/\n\n# Check with verbose output\ndfc check --verbose src/\n\n# Generate example configuration file\ndfc config-example &gt; pyproject.toml\n</code></pre>"},{"location":"usage/overview/#advanced-configuration","title":"Advanced Configuration","text":"<pre><code># Use custom config file location\ndfc check --config custom_config.toml src/\n\n# Check specific function patterns\ndfc check --include-pattern \"**/api/*.py\" src/\n\n# Exclude test files\ndfc check --exclude-pattern \"**/test_*.py\" src/\n</code></pre>"},{"location":"usage/overview/#integration-with-cicd","title":"Integration with CI/CD","text":"<pre><code># .github/workflows/docs.yml\nname: Documentation Quality\non: [push, pull_request]\n\njobs:\n  docstring-check:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: astral-sh/setup-uv@v3\n      - run: uv pip install docstring-format-checker\n      - run: dfc check src/\n</code></pre>"},{"location":"usage/overview/#example-output","title":"Example Output","text":"<pre><code>\ud83d\udccb Docstring Format Checker Results\n\n\u2705 src/utils/helpers.py\n\u274c src/models/user.py\n   \u2514\u2500\u2500 Function 'create_user' missing required section: 'params'\n   \u2514\u2500\u2500 Function 'delete_user' missing required section: 'returns'\n\n\u274c src/api/endpoints.py\n   \u2514\u2500\u2500 Method 'UserAPI.get_user' invalid section format: 'raises'\n\n\ud83d\udcca Summary: 1/3 files passed (33.3%)\n</code></pre>"},{"location":"usage/overview/#architecture","title":"Architecture","text":"<p>The tool follows a clean, modular architecture:</p> <ul> <li><code>core.py</code> - <code>DocstringChecker</code> class with AST parsing and validation logic</li> <li><code>config.py</code> - Configuration loading and <code>SectionConfig</code> management</li> <li><code>cli.py</code> - Typer-based CLI with dual entry points</li> <li><code>utils/exceptions.py</code> - Custom exception classes for structured error handling</li> </ul>"},{"location":"usage/overview/#contribution","title":"Contribution","text":"<p>Check the CONTRIBUTING.md file or Contributing page.</p>"},{"location":"usage/overview/#development","title":"Development","text":"<ol> <li> <p>Clone the repository:</p> <pre><code>git clone https://github.com/data-science-extensions/docstring-format-checker.git\ncd docstring-format-checker\n</code></pre> </li> <li> <p>Set up development environment:</p> <pre><code>uv sync --all-groups\n</code></pre> </li> <li> <p>Run tests:</p> <pre><code>uv run pytest --config-file=pyproject.toml --cov-report=term-missing\n</code></pre> </li> <li> <p>Run CLI locally:</p> <pre><code>uv run dfc check examples/example_code.py\n</code></pre> </li> </ol>"},{"location":"usage/overview/#build-and-test","title":"Build and Test","text":"<p>To ensure that the package is working as expected, please ensure that:</p> <ol> <li>You write your code as per PEP8 requirements.</li> <li>You write a UnitTest for each function/feature you include.</li> <li>The CodeCoverage is 100%.</li> <li>All UnitTests are passing.</li> <li>MyPy is passing 100%.</li> </ol>"},{"location":"usage/overview/#testing","title":"Testing","text":"<ul> <li> <p>Run them all together:</p> <pre><code>uv run pytest --config-file=pyproject.toml\n</code></pre> </li> <li> <p>Or run them individually:</p> <ul> <li> <p>Tests with Coverage: <pre><code>uv run pytest --config-file=pyproject.toml --cov-report=term-missing\n</code></pre></p> </li> <li> <p>Type Checking: <pre><code>uv run mypy src/\n</code></pre></p> </li> <li> <p>Code Formatting: <pre><code>uv run black --check src/\n</code></pre></p> </li> <li> <p>Linting: <pre><code>uv run ruff check src/\n</code></pre></p> </li> </ul> </li> </ul>"},{"location":"usage/overview/#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"}]}